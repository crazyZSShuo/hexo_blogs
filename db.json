{"meta":{"version":1,"warehouse":"5.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","path":"js/jquery-3.6.4.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/Annie/source/css/Annie.styl","path":"css/Annie.styl","modified":0,"renderable":1},{"_id":"themes/Annie/source/css/comment.styl","path":"css/comment.styl","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/Annie_qq_qrcode.jpg","path":"img/Annie_qq_qrcode.jpg","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/cart_cover.jpg","path":"img/cart_cover.jpg","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/header-bg.jpg","path":"img/header-bg.jpg","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/lazy.gif","path":"img/lazy.gif","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/logo.png","path":"img/logo.png","modified":0,"renderable":1},{"_id":"themes/Annie/source/js/leancloud-count.js","path":"js/leancloud-count.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":0,"renderable":1},{"_id":"themes/Annie/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":0,"renderable":1},{"_id":"themes/Annie/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":0,"renderable":1},{"_id":"themes/Annie/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/quote/danger.svg","path":"img/quote/danger.svg","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/quote/info.svg","path":"img/quote/info.svg","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/quote/quote-left.svg","path":"img/quote/quote-left.svg","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/quote/success.svg","path":"img/quote/success.svg","modified":0,"renderable":1},{"_id":"themes/Annie/source/img/quote/warning.svg","path":"img/quote/warning.svg","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/chinese/chinese.js","path":"plugin/chinese/chinese.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/clipboard/clipboard.js","path":"plugin/clipboard/clipboard.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/comment/valine.min.js","path":"plugin/comment/valine.min.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/fancybox/jquery.fancybox.css","path":"plugin/fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/fancybox/jquery.fancybox.js","path":"plugin/fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/gallerypage/data.json","path":"plugin/gallerypage/data.json","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/gallerypage/natural-gallery.full.css","path":"plugin/gallerypage/natural-gallery.full.css","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/gallerypage/natural-gallery.full.js","path":"plugin/gallerypage/natural-gallery.full.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/gallerypage/natural.css","path":"plugin/gallerypage/natural.css","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/imagelazyloader/yall.min.js","path":"plugin/imagelazyloader/yall.min.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/imageloaded/imagesloaded.pkgd.min.js","path":"plugin/imageloaded/imagesloaded.pkgd.min.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/jquery/jquery.min.js","path":"plugin/jquery/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/leancloud/av-min.js","path":"plugin/leancloud/av-min.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/love/love.js","path":"plugin/love/love.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/motto/motto.js","path":"plugin/motto/motto.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/nicescroll/jquery.nicescroll.js","path":"plugin/nicescroll/jquery.nicescroll.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/resizediv/resizediv.js","path":"plugin/resizediv/resizediv.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/search/ziploader.js","path":"plugin/search/ziploader.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/toc/katelog.min.js","path":"plugin/toc/katelog.min.js","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/gallerypage/images/default-skin.png","path":"plugin/gallerypage/images/default-skin.png","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/gallerypage/images/default-skin.svg","path":"plugin/gallerypage/images/default-skin.svg","modified":0,"renderable":1},{"_id":"themes/Annie/source/plugin/gallerypage/images/preloader.gif","path":"plugin/gallerypage/images/preloader.gif","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1702549745145},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1702549751949},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"1a9b279e6dd29fd19245f913f0c4a316ffaa62db","modified":1702549752333},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":1702549752389},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"4bf95d52f77edf811f23f6d264a7493311a8d078","modified":1702549752329},{"_id":"node_modules/hexo-theme-landscape/languages/de-DE.yml","hash":"d29d1c4256b7ed9df42f511c2ff0a23ad5fd6c1f","modified":1702549752389},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1702549752389},{"_id":"node_modules/hexo-theme-landscape/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1702549752389},{"_id":"node_modules/hexo-theme-landscape/languages/en-GB.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1702549752393},{"_id":"node_modules/hexo-theme-landscape/languages/en-US.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1702549752393},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1702549752393},{"_id":"node_modules/hexo-theme-landscape/languages/es-ES.yml","hash":"7008a8fc91f18d2a735864817b8ebda30c7a2c66","modified":1702549752397},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1702549752401},{"_id":"node_modules/hexo-theme-landscape/languages/fr-FR.yml","hash":"8d09dbdab00a30a2870b56f7c0a7ca7deafa7b88","modified":1702549752401},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1702549752401},{"_id":"node_modules/hexo-theme-landscape/languages/hu-HU.yml","hash":"712d18664898fa21ba38d4973e90ef41a324ea25","modified":1702549752401},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1702549752405},{"_id":"node_modules/hexo-theme-landscape/languages/it-IT.yml","hash":"2cb6dc2fab9bd2dbe1c8bb869a9e8bf85a564fdd","modified":1702549752405},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1702549752413},{"_id":"node_modules/hexo-theme-landscape/languages/ja-JP.yml","hash":"08481267e0c112e1f6855620f2837ec4c4a98bbd","modified":1702549752413},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1702549752413},{"_id":"node_modules/hexo-theme-landscape/languages/ko-KR.yml","hash":"19209ad8f9d4057e8df808937f950eb265e1db69","modified":1702549752417},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1702549752417},{"_id":"node_modules/hexo-theme-landscape/languages/mn-MN.yml","hash":"b9e5f3e7c0c2f779cf2cfded6db847b5941637ca","modified":1702549752421},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1702549752425},{"_id":"node_modules/hexo-theme-landscape/languages/nl-NL.yml","hash":"5ebbc30021f05d99938f96dfff280392df7f91f0","modified":1702549752425},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1702549752425},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1702549752429},{"_id":"node_modules/hexo-theme-landscape/languages/pt-PT.yml","hash":"0f852b6b228e6ea59aa3540574bb89b233f2a098","modified":1702549752429},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1702549752433},{"_id":"node_modules/hexo-theme-landscape/languages/ru-RU.yml","hash":"360d11a28bb768afb1dd15f63fa7fd3a8cc547ee","modified":1702549752433},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1702549752433},{"_id":"node_modules/hexo-theme-landscape/languages/th-TH.yml","hash":"ebfdba9bc4842c829473c1e6e4544344f182724d","modified":1702549752433},{"_id":"node_modules/hexo-theme-landscape/languages/th.yml","hash":"84a55b00aa01f03982be294e43c33a20e6d32862","modified":1702549752437},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1702549752437},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1702549752437},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1702549752437},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1702549752149},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1702549752165},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1702549752197},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1702549752205},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1702549752209},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1702549752213},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1702549752225},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1702549752289},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"377d257d5d16e0158a4405c72401517b074fd7ff","modified":1702549752065},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1702549752085},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":1702549752093},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"56597e951203dd662a6d2c817c7c4f1c920d4a25","modified":1702549752153},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1702549752173},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1702549752185},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1702549752189},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"f05bced793b0314d4f2ef0c993b3a51d0b7d203a","modified":1702549752193},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"6a5033d189554c9a6d42e2ef7952ae5c9742648e","modified":1702549752193},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1702549752205},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1702549752225},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1702549752133},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1702549752165},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1702549752221},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1702549752225},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1702549752229},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1702549752337},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"ca28281423ae57d76b6c1eb91cd845fd4e518bd6","modified":1702549752341},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"e55a1d92954ed20f6887f92dc727bb995a010a43","modified":1702549752389},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1702549752013},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1702549752329},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1702549752161},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1702549752169},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1702549752177},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1702549752209},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1702549752225},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1702549752229},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1702549752353},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"2d1f6f79ebf9cb55ebdb3865a2474437eb2b37c6","modified":1702549752353},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1702549752357},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1702549752361},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"268d2989acb06e2ddd06cc36a6918c6cd865476b","modified":1702549752365},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"9cc3b2927d814f2f6e8e188f9d3657b94f4c6ef3","modified":1702549752373},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1702549752377},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1702549752381},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1702549752381},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1702549752381},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1702549752365},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1702549752373},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1702549752325},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1702549752313},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1702549752273},{"_id":"themes/Annie/.project","hash":"e74f16ba9e77ca103622e508e45cff12955f9018","modified":1702552062417},{"_id":"themes/Annie/LICENSE","hash":"c224e65a5fd27ee195e6d1a205ae12c278e50147","modified":1702552062417},{"_id":"themes/Annie/README.md","hash":"22f78fda73dea27f0a782b16530fbf4e8ae42a1a","modified":1702552062417},{"_id":"themes/Annie/_config.yml","hash":"6461cb94376f9caeb672d64a07051168835cc6b2","modified":1702552062417},{"_id":"themes/Annie/languages/default.yml","hash":"5e989c01fddeaf74eb355512e3f1948af274ab9e","modified":1702552062417},{"_id":"themes/Annie/languages/en.yml","hash":"a16a32ea429a3b222c329296ce2758010d023978","modified":1702552062417},{"_id":"themes/Annie/languages/zh-CN.yml","hash":"290b1728a4ad75ed361cc00b4d9d80ee474eb196","modified":1702552062417},{"_id":"themes/Annie/languages/zh-TW.yml","hash":"ef76f849165403749cbdf71d9244262f2f872849","modified":1702552062417},{"_id":"themes/Annie/layout/about.ejs","hash":"83b6fb6fc7e194dce4e0565a0066fa2dc1496838","modified":1702552062417},{"_id":"themes/Annie/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1702552062417},{"_id":"themes/Annie/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1702552062417},{"_id":"themes/Annie/layout/gallery.ejs","hash":"1a440f00b762629bc33e5c568157c0d3e8f79514","modified":1702552062421},{"_id":"themes/Annie/layout/index.ejs","hash":"0040e60b70d31d5d841d291d407ff9b6e8c7e011","modified":1702552062421},{"_id":"themes/Annie/layout/layout.ejs","hash":"7eb75e119253ffb8809756b0aa9087d488ed9a8b","modified":1702552062421},{"_id":"themes/Annie/layout/page.ejs","hash":"7ea1bad6d26c79b7baccbf452ca8a52113be2716","modified":1702552062421},{"_id":"themes/Annie/layout/post.ejs","hash":"c1fe38aba639c318ba79eecab914c18c8272c818","modified":1702552062421},{"_id":"themes/Annie/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1702552062421},{"_id":"themes/Annie/scripts/colorquote.js","hash":"6afb13ee61b8aa95b293b588cc61b5052af92492","modified":1702552062421},{"_id":"themes/Annie/scripts/first-letter-sink.js","hash":"69f1409238f1589ea94e20e2c24b5130f9dad559","modified":1702552062421},{"_id":"themes/Annie/.github/ISSUE_TEMPLATE/bug_report.md","hash":"d032cefa84810dc7432c14da8ed30bef38558ada","modified":1702552062417},{"_id":"themes/Annie/.github/ISSUE_TEMPLATE/feature_request.md","hash":"e751c04e5ba9c084e904208360bc15b0c7291c53","modified":1702552062417},{"_id":"themes/Annie/.github/ISSUE_TEMPLATE/general-issue.md","hash":"4af71474cda52243b3e23d8dd3dae1463c878eb5","modified":1702552062417},{"_id":"themes/Annie/.github/ISSUE_TEMPLATE/pull-request.md","hash":"c06eb5ad4ddeefd7cf4ff254a2c11938eb795b7c","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/archive.ejs","hash":"330c868ac032afd4a571e2ebafd2a632f591c12d","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/footer-after.ejs","hash":"600b0842f473d6ecd8d477a1940a43cfcb26ee79","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/footer-social.ejs","hash":"0bc14a7ccd7f6ee3e0a176aef5793b0464fae4c9","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/footer.ejs","hash":"9238b49a9a01a4368af26b49e824909083a99d70","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/head.ejs","hash":"870d6c01bafdce39cf92831c348118468d3c6684","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/header.ejs","hash":"93afcd6423c5f3c782503f1104a11d0e412e27de","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/index-cart.ejs","hash":"8ec5ba1627ae200e477671c8581d30810e1c2f43","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/index-pure.ejs","hash":"0c65a64f743e13b6c31049f2e58815e004fd4452","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/nav.ejs","hash":"3dd3d39762db6b880e1ce7d880cac34fe32fbde9","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/page-header.ejs","hash":"8893f640792fdf23f03dd982a1c34f80fa0bef9d","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/page.ejs","hash":"82989821a8b8a7d173502f448b6f39bbb665e483","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/paginator.ejs","hash":"4bc4131fff9ee7ac15ac8375cff767cbcc86969f","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/post-number.ejs","hash":"bbca519feda03103f905fac6a453192035875e40","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/post-relate.ejs","hash":"78b0d3da73fb5fdfe51bda19e64814e28bf88103","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/post.ejs","hash":"4e8aaf938c6c261d752183c968018a64652321d7","modified":1702552062417},{"_id":"themes/Annie/source/css/Annie.styl","hash":"5c917d6abf0e5494e9c4de3ac2f9e6b41326c73f","modified":1702552062421},{"_id":"themes/Annie/source/css/comment.styl","hash":"e38672bfa1bc3fcc54829c48c0d4d49df42200d0","modified":1702552062421},{"_id":"themes/Annie/source/img/Annie_qq_qrcode.jpg","hash":"571f514f6ef9b4e085bb9c74523eade02a84e8ea","modified":1702552062421},{"_id":"themes/Annie/layout/_partial/post-like.ejs","hash":"17d57526e1cefb78b09ef115fa97d56655707cb7","modified":1702552062417},{"_id":"themes/Annie/source/img/lazy.gif","hash":"0bbc5084e6aaa8d6260645c49abc45659553f464","modified":1702552062425},{"_id":"themes/Annie/source/img/logo.png","hash":"6753531813b7157625c4eca2531d08edc65f846b","modified":1702552062425},{"_id":"themes/Annie/source/js/leancloud-count.js","hash":"3d713d7b5e9f473a8c44b2cc64f211568bac8c90","modified":1702552062425},{"_id":"themes/Annie/source/js/main.js","hash":"5c090a6312edcfee22d1a0b3a760cd467d9982bd","modified":1702552062425},{"_id":"themes/Annie/source/js/search.js","hash":"1a1bfdbf2ea98d387925f63246c15ef9e9556fef","modified":1702552062425},{"_id":"themes/Annie/layout/_partial/custom/XXX.ejs","hash":"bc338dc74c1b2d4668f8149b78d348c945a28d50","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/clipboard.ejs","hash":"b0c76a76c31abbed1255b057c8a9789294164bbe","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/comment.ejs","hash":"878a0cb2cb5fb6111b34e7ecb22572c7cb67369c","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/mathjax.ejs","hash":"4ddeccccdbf54fae9b0aebbf3df6c93215d7319d","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/motto.ejs","hash":"8c5177ba00c8017e1ebf25829866a7c461cb987c","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/search.ejs","hash":"8b0f064a55f9b44bb282d2bbb8065e273379a45d","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/share.ejs","hash":"5f438692d12423e910307feaa210b5ab6a2a272b","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/statistics.ejs","hash":"da3b8578df4b11575690a90e9d6cf1815eae99ee","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/toc.ejs","hash":"21a3a302e9feee793bde4c942433726a7a175f23","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/post/category.ejs","hash":"4c89f93ff34f620df53fb778e7005c658fcef05c","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/post/date.ejs","hash":"faf8da7eb617454a6e1e728af9ffc50fa17e3997","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/post/gallery.ejs","hash":"ba5f8d33d5cbc0e14709a9c9ba3d1b5f6c75cf3e","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/post/navigation.ejs","hash":"95cc8c6c893abacbfa793cb88501b247f26c0aae","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/post/tag.ejs","hash":"77a5a0a40dad69716e9980a0ae81af93fd05a1d3","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/post/title.ejs","hash":"8c62c05b4f9df9e43d0c20c283a750d25ece6074","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/widget/totop.ejs","hash":"7c88fcda5e4e4d9dc03ca516f4db7968a0a5c5a5","modified":1702552062417},{"_id":"themes/Annie/source/css/_base/base.styl","hash":"dca7912cc5876f63dc96e2cc0924a760829fd324","modified":1702552062421},{"_id":"themes/Annie/source/css/_base/icomoon.styl","hash":"79cec8bab5ed326bf9c6c326860e78a97f7bd48f","modified":1702552062421},{"_id":"themes/Annie/source/css/_base/normalize.styl","hash":"8b6cd89a691833ec86f6bee54c825ce32964b15a","modified":1702552062421},{"_id":"themes/Annie/source/css/_component/animation.styl","hash":"f30ef021bc9107ef542d26638606089718e214ca","modified":1702552062421},{"_id":"themes/Annie/source/css/_component/backtotop.styl","hash":"160f8ce6bc7fac15367b83e01ee0e54f67df6b26","modified":1702552062421},{"_id":"themes/Annie/source/css/_component/comment.styl","hash":"1f0cb38772b2401f750cf0d7d808842e030b53b2","modified":1702552062421},{"_id":"themes/Annie/source/css/_component/component.styl","hash":"92c86e9241a4e307a941b23e13f5c33206857a69","modified":1702552062421},{"_id":"themes/Annie/source/css/_component/menu.styl","hash":"466f278d6e3990014c8b8ed429a1506d2c8e220b","modified":1702552062421},{"_id":"themes/Annie/source/css/_component/pagination.styl","hash":"26c9100d451bab9e235bbb0c9b52d29a9b07a73d","modified":1702552062421},{"_id":"themes/Annie/source/css/_component/preloader.styl","hash":"10f6a20767f772dd3bf6f044e6f05164cf5e51e4","modified":1702552062421},{"_id":"themes/Annie/source/css/_component/progressbar.styl","hash":"f5ba35a421a202a07ff3fd78aa5daa8d64aef830","modified":1702552062421},{"_id":"themes/Annie/source/css/_component/scrollbar.styl","hash":"a650f916abb93942157aae0607caa6d22e7cbf63","modified":1702552062421},{"_id":"themes/Annie/source/css/_component/search.styl","hash":"5f0ad81dbb74003b347a726b53bc3dc86be07e70","modified":1702552062421},{"_id":"themes/Annie/source/css/_component/share.styl","hash":"63b5e771f37f4b370eb7fbdddd4b99b495b2a33e","modified":1702552062421},{"_id":"themes/Annie/source/css/_component/toc.styl","hash":"b4b5834657f86e6244ba0393297d862df3c975c1","modified":1702552062421},{"_id":"themes/Annie/source/css/_custom/custom.styl","hash":"2ae6d3186ef76677795162ecd3a537e236181d98","modified":1702552062421},{"_id":"themes/Annie/source/css/_helper/variable.styl","hash":"0fae4f9c8769f2b21e076a9befaf55e8674d07fe","modified":1702552062421},{"_id":"themes/Annie/source/css/_layout/footer.styl","hash":"055027b9f7b5fcff38ae77532ce07fbcddde66a7","modified":1702552062421},{"_id":"themes/Annie/source/css/_layout/header.styl","hash":"0fcedd0eb8f14e22869da83268b19fab1fac423a","modified":1702552062421},{"_id":"themes/Annie/source/css/_mobile/mobile.styl","hash":"579f3c95ff569b179327194d666caab43464ec11","modified":1702552062421},{"_id":"themes/Annie/source/css/_page/about.styl","hash":"8ac0926f60d5a5e29e03caebea331dfb225a72ef","modified":1702552062421},{"_id":"themes/Annie/source/css/_page/archive.styl","hash":"db223f6984c0f0a316f29cd94f9ea68367bac726","modified":1702552062421},{"_id":"themes/Annie/source/css/_page/category.styl","hash":"bd257bfb875ab0a4c8f04742e8c6c28235346387","modified":1702552062421},{"_id":"themes/Annie/source/css/_page/gallery.styl","hash":"677c9cc90c9c0f97ee6f4766561fbaceb15584bb","modified":1702552062421},{"_id":"themes/Annie/source/css/_page/index.styl","hash":"ed09eef30d13beed6fd9716f25de7e8351e5cc47","modified":1702552062421},{"_id":"themes/Annie/source/css/_page/page.styl","hash":"0ba62ad87c5ef004870f5a3dc4c9ba0303771ce8","modified":1702552062421},{"_id":"themes/Annie/source/css/_page/post.styl","hash":"d328911b729d27048c763511aa434ff71d839b10","modified":1702552062421},{"_id":"themes/Annie/source/css/_page/tag.styl","hash":"d2e5ec8ab09ddb686d78b013072788f5970d45cf","modified":1702552062421},{"_id":"themes/Annie/source/css/fonts/icomoon.eot","hash":"8b0e8a844b0db44cd73419c55ab9054e90844cf3","modified":1702552062421},{"_id":"themes/Annie/source/css/fonts/icomoon.ttf","hash":"7f5ba460f1c534dffd1f1bd92fa381fe93c6e8bc","modified":1702552062421},{"_id":"themes/Annie/source/css/fonts/icomoon.woff","hash":"4a4bcec7a051735d1fa587af3e53c6a9270dca79","modified":1702552062421},{"_id":"themes/Annie/source/img/quote/danger.svg","hash":"b2db56f2cc13fce73dbea46c7b446d9bcb3bf0fd","modified":1702552062425},{"_id":"themes/Annie/source/img/quote/info.svg","hash":"c8aa387e935ba9a7fa72c5dd000b7d46f2e030c4","modified":1702552062425},{"_id":"themes/Annie/source/img/quote/quote-left.svg","hash":"d2561fa8d13e63ff196b71232a5968415ec6e372","modified":1702552062425},{"_id":"themes/Annie/source/img/quote/success.svg","hash":"029b8b3523b7daa4005983b4463cd93408308aab","modified":1702552062425},{"_id":"themes/Annie/source/img/quote/warning.svg","hash":"7153fa2a0c21e32da6a1f96a333d8b66a178569d","modified":1702552062425},{"_id":"themes/Annie/source/plugin/chinese/chinese.js","hash":"986dfdf6f27852151e2225aaaa22d2302d5d24dc","modified":1702552062425},{"_id":"themes/Annie/source/plugin/clipboard/clipboard.js","hash":"43d4af727a32a793d9146eb828ed114e3ca29cec","modified":1702552062425},{"_id":"themes/Annie/source/plugin/comment/valine.min.js","hash":"0c698e2d51cdc0d2eb303c8c3a81ddd6d6cf667f","modified":1702552062425},{"_id":"themes/Annie/source/plugin/fancybox/jquery.fancybox.css","hash":"7a81dceacd45c9249b1da50c3a51eb6aec68424c","modified":1702552062429},{"_id":"themes/Annie/source/plugin/gallerypage/natural-gallery.full.css","hash":"d5c5ff93bf13e2d4ece69ccaa6cd72a2486daba0","modified":1702552062429},{"_id":"themes/Annie/source/plugin/gallerypage/natural.css","hash":"8014a4791f5789e55aa8921def9eb93b3f31d48d","modified":1702552062429},{"_id":"themes/Annie/source/plugin/imagelazyloader/yall.min.js","hash":"59e3ca7c5cc98368156826ea857fa1a8dea6aaa4","modified":1702552062429},{"_id":"themes/Annie/source/plugin/imageloaded/imagesloaded.pkgd.min.js","hash":"6d3e11174e22668e69df236e5c4542168f7cbfec","modified":1702552062429},{"_id":"themes/Annie/source/plugin/love/love.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1702552062429},{"_id":"themes/Annie/source/plugin/resizediv/resizediv.js","hash":"1b3e3eb33aee0de1f02384dbdbd3941716e0fda5","modified":1702552062433},{"_id":"themes/Annie/source/plugin/search/ziploader.js","hash":"93c976bea5ae21811807cf27b4ca8c3c94640b04","modified":1702552062433},{"_id":"themes/Annie/source/plugin/toc/katelog.min.js","hash":"7acaa9e4a1a3689b84382c1814b58b1168c57e2c","modified":1702552062433},{"_id":"themes/Annie/layout/_partial/plugin/comment/gitalk.ejs","hash":"532d99ba38db222f0a77b21283e128e93c15b809","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/comment/livere.ejs","hash":"2e3567bc92eaf9eaa9104063073d275109edf312","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/comment/valine.ejs","hash":"65ea46b14fe5724472046dd1a7169f963d720174","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/share/addThis.ejs","hash":"9cfc3545769c6d26916e909e93d69b4653d960a9","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/share/baidu-share.ejs","hash":"f110e432b633f6335f5b49dc9640d55450b34632","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/share/shareThis.ejs","hash":"e78f98551a3a27e8256d8eb278267a95485648f1","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/share/social-share.ejs","hash":"f38a4e16f6c1ab39888cb0641cbbb346aa5d4c90","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/statistics/baidu-analytics.ejs","hash":"1805f5c41145dbf3e56d030b2cc0083030ec6d9f","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/statistics/busuanzi.ejs","hash":"806f5ba2d3eb9d9230713d476761f11a7d38dd54","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/statistics/cnzz_analytics.ejs","hash":"a16b8110f98b0cd940d5d3dd4f41d7efcb755e97","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/statistics/google_analytics.ejs","hash":"470c58516777e6b16fdc00b529669631c826d7c6","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/statistics/leancloud.ejs","hash":"1ef9848c46e8c2270ec0b0a010c97ca64bc3c57a","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/statistics/tencent_analytics.ejs","hash":"4d1873b38be4510a5d93db27878d9ff7de5400d3","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/statistics/topN-post.ejs","hash":"5530110b6ed90c95165a2de1decb66f370f1ef51","modified":1702552062417},{"_id":"themes/Annie/layout/_partial/plugin/clipboard/code-copy.ejs","hash":"abb3d1e602c3eb8fc774bedd2432a3e3fc1c55e5","modified":1702552062417},{"_id":"themes/Annie/source/css/_component/_hexotags/colorquote.styl","hash":"d0c78c5cb2f477454b2bd8f2ed555420cb60ceaf","modified":1702552062421},{"_id":"themes/Annie/source/css/_component/_hexotags/first-letter-sink.styl","hash":"997d548725ea59e9142f90fd7b94c7f293023992","modified":1702552062421},{"_id":"themes/Annie/source/css/_component/_highlight/_code-copy.styl","hash":"ee51a7bcdae3c109c78f9f0b8f31a5e93291e53b","modified":1702552062421},{"_id":"themes/Annie/source/css/_component/_highlight/_diff.styl","hash":"ef9a09da02e61982a0a7adc2a609e0ab2f9c83eb","modified":1702552062421},{"_id":"themes/Annie/source/css/_component/_highlight/_theme.styl","hash":"53a02db002bd1062f4b55684b4cc268df7be578f","modified":1702552062421},{"_id":"themes/Annie/source/css/_component/_highlight/_variables.styl","hash":"3c84c1b2ea98abc97490190ae8f85b5a865b24e3","modified":1702552062421},{"_id":"themes/Annie/source/css/_component/_highlight/highlight.styl","hash":"99dc7738c2666901262ece43c0e4dd68204fb597","modified":1702552062421},{"_id":"themes/Annie/source/plugin/gallerypage/images/default-skin.png","hash":"f6c7bd39c5ceda639276e64447f6007ad28ac0dd","modified":1702552062429},{"_id":"themes/Annie/source/plugin/gallerypage/images/default-skin.svg","hash":"bf61aaab4ee361ac7537b68abee8780ac6fd22f3","modified":1702552062429},{"_id":"themes/Annie/source/plugin/gallerypage/images/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1702552062429},{"_id":"themes/Annie/source/plugin/gallerypage/data.json","hash":"b1af217109ef799dd029e9bd0d2a41f946702781","modified":1702552062429},{"_id":"themes/Annie/source/plugin/gallerypage/natural-gallery.full.js","hash":"5b3dfb0b5279055706c57484e14c8dac321be7e8","modified":1702552062429},{"_id":"themes/Annie/source/plugin/jquery/jquery.min.js","hash":"5a9dcfbef655a2668e78baebeaa8dc6f41d8dabb","modified":1702552062429},{"_id":"themes/Annie/source/plugin/nicescroll/jquery.nicescroll.js","hash":"25b8db3ad673a4661334b1cdeaf37ed881ffd17c","modified":1702552062433},{"_id":"themes/Annie/source/css/fonts/icomoon.svg","hash":"6e165b0a2f3497478b00503fe85c38e1c6e05e4d","modified":1702552062421},{"_id":"themes/Annie/source/plugin/fancybox/jquery.fancybox.js","hash":"c4461bc0cacd6a1d58885ca0f466ba1b7562c85d","modified":1702552062429},{"_id":"themes/Annie/source/plugin/leancloud/av-min.js","hash":"d16c3eb20daa240feea36cc607a2e8a22ac66f81","modified":1702552062429},{"_id":"themes/Annie/source/plugin/motto/motto.js","hash":"282eac08d66a6e14f1b170cf1dbea67e53fba436","modified":1702552062433},{"_id":"themes/Annie/source/img/favicon.ico","hash":"92da6723b6526aa98c23501e6086c5948a13083c","modified":1702552062425},{"_id":"themes/Annie/source/img/cart_cover.jpg","hash":"5c9561c6cc4637a1cfc03fb0399883f052e3340b","modified":1702552062425},{"_id":"themes/Annie/source/img/header-bg.jpg","hash":"509748b7822d48d510476d6168c96cc09d6d7502","modified":1702552062425},{"_id":"source/_posts/2023-06-14-0-计算机操作系统.md","hash":"029a39f93752917a484f20fdb96661a3e8700bd7","modified":1702607501955},{"_id":"source/_posts/2023-06-14-1-操作系统引论.md","hash":"7eef008f3b25a75b56c4b3d6207d84119e1d59ed","modified":1702607501991},{"_id":"source/_posts/2023-06-14-2-进程的描述与控制.md","hash":"5b0e2f821fa1cc424e7b89c34b0ceab8642a7a0d","modified":1702607502019},{"_id":"source/_posts/2023-06-14-3-处理机调度与死锁.md","hash":"0995ddaaa1d18d2a9787f8ed160d31549b720ac9","modified":1702607502039},{"_id":"source/_posts/2023-06-14-4-存储器管理.md","hash":"9b77cb497db635dd47bb95e510105a53632c941a","modified":1702607502083},{"_id":"source/_posts/2023-06-14-5-虚拟存储器.md","hash":"0ebc93b0ef6634a7c4b8459b1fab1248e127284c","modified":1702607502107},{"_id":"source/_posts/2023-06-14-6-输入输出系统.md","hash":"5f8f7e238a0a1b8b399a0aa6476962c0ba6ef6f0","modified":1702607502139},{"_id":"source/_posts/2023-06-14-7-文件管理.md","hash":"85fa39363c1ccf9868e891794d562777abccf59f","modified":1702607502159},{"_id":"source/_posts/2023-06-14-Git操作奇淫技巧.md","hash":"dd97f9748a5855b038132038802ca4655a6c6a0c","modified":1702607502215},{"_id":"source/_posts/2023-06-14-Vi操作命令.md","hash":"f11ea91f571bae4ada6c0596f1e519720c07ff58","modified":1702607502267},{"_id":"source/_posts/2023-06-14-git commit之后，撤销commit.md","hash":"86982dec93cf2e43f0a3cb5ef779eabce157172e","modified":1702607502191},{"_id":"source/_posts/2023-06-14-ubuntu-source-list.md","hash":"fd9344d438f75f950d5c3810333ac058a18db4d8","modified":1702607502239},{"_id":"source/_posts/2023-06-20-Chrome、Edge浏览器开启多线程下载.md","hash":"a965f74c42b458a6477d49d8927a9e652a94fe76","modified":1702607502327},{"_id":"source/_posts/2023-06-14-数据结构.md","hash":"f5dd51eb1ea7201a9ee7a508baaa697934e7a88b","modified":1702607502303},{"_id":"source/_posts/2023-07-17-sublime text 破解.md","hash":"5aecde258fe777efaa87a09acffdf539a4f3d4f1","modified":1702607502579},{"_id":"source/_posts/2023-08-07-ubuntu install python3.10.md","hash":"d689e8ee217e940adda701c0798c3554067166c8","modified":1702607502611},{"_id":"source/_posts/2023-08-10-IDM Activate 激活.md","hash":"49accb126d68284beaab8ca37a553f7315985366","modified":1702607502639},{"_id":"source/_posts/2023-08-25-Centos安装Docker.md","hash":"09d80b7f63d7a1fb45b4139850befb1fb77dc398","modified":1702607502663},{"_id":"source/_posts/2023-09-01-Goland License.md","hash":"97c0098d100b84ac70e68bff55bd966dcc456908","modified":1702607502699},{"_id":"source/_posts/2023-10-09-[教程] Windows 10~11重新支持永久激活 新方法为HWID 2可数字权利.md","hash":"b19b3cc7886bc114b03a03075a90a461a5581862","modified":1702607502747},{"_id":"source/_posts/2023-10-31-Centos安装python3.10流程.md","hash":"b02289b74e05d5405aa82240aea06f765c1b4aad","modified":1702607502947},{"_id":"source/_posts/2023-11-03-ubuntu安装mongodb.md","hash":"87113a49696c12ad95ca7fa97ac0539296422d62","modified":1702607503051},{"_id":"source/_posts/2023-11-06-ubuntu20.04安装Mysql8.0数据库.md","hash":"02921aae4679cc1b33f76a6123062cd887c1490a","modified":1702607503075},{"_id":"source/_posts/2023-11-06-ubuntu20.04安装Redis.md","hash":"4ecc5893d74a0db96a240ecb9f8968d07fc15dfb","modified":1702607503099},{"_id":"source/_posts/2023-11-24-ubuntu22.04安装docker.md","hash":"b02b3500d6501b8eaf4205be622ec3a338f0902c","modified":1702607503127},{"_id":"source/_posts/2023-11-24-ubuntu22.04配置国内源.md","hash":"be4eeb453759fa32ff0d0d7e6571d85e32775dd7","modified":1702607503151},{"_id":"source/_posts/2023-11-6-永久关闭小米电视广告.md","hash":"59e3343c3b4ebc73d2cd566ab91aa16a162fee02","modified":1702607503171},{"_id":"source/_posts/2023-12-05-docker容器启动提示iptables问题.md","hash":"7e02fa91a18f46deeea69a6de05110f093d3a3db","modified":1702607503199}],"Category":[],"Data":[],"Page":[],"Post":[{"_content":"# 计算机操作系统\n\n## 目录\n\n## 一.操作系统引论\n### 1.操作系统的目标和功能\n* 目标\n    * 方便性\n    * 有效性\n        * 提高系统资源利用率\n        * 提高系统吞吐量\n    * 可扩充性\n    * 开放性\n* 作用\n    * OS作为用户与计算机硬件系统之间的接口\n        * 命令方式\n        * 系统调用方式\n        * 图标–窗口方式\n    * OS实现了对计算机资源的抽象\n### 2.操作系统的发展过程\n* 未配置操作系统的计算机系统\n    * 人工操作方式\n     * > 用户独占全机 CPU等待人工操作 严重降低了计算机资源的利用率\n\n    * 脱机输入/输出(Off–Line I/O)方式\n     * > 减少了CPU的空闲时间 提高了I/O速度 效率仍然不理想\n\n* 单道批处理系统\n* 多道批处理系统\n* > 1.资源利用率高\n* > 2.系统吞吐量大\n* > 3.平均周转时间长\n* > 4.无交互能力\n\n    * (宏观并行，微观串行)\n* 分时系统\n* > 特征:\n* > 1.多路性\n* > 2.独立性\n* > 3.及时性\n* > 4.交互性\n\n* 实时系统\n* 集群系统–超算~云计算\n* 微机操作系统的发展\n### 3.操作系统的基本特征\n* 1.并发concurrence\n    * 区别并行和并发\n     * > 并行性是指两个或多个事件在同一时刻发生→宏观并行，微观并行\n     * > 并发性是指两个或多个事件在同一时间间隔内发生→宏观并行，微观串行\n\n        * 并发是进程宏观一起运行，微观上交替运行，而并行是指同时运行\n    * 引入进程\n     * > 进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令，数据和堆栈等组成的，是一个能独立运行的活动实体\n\n* 2.共享sharing\n    * 1.互斥共享方式\n    * 2.同时访问方式\n    * 并发和共享是多用户(多任务)OS的两个最基本的特征。它们又是互为存在的条件\n* 3.虚拟virtual\n    * 时分复用技术\n    * 空分复用技术\n* 4.异步asynchronism\n### 4.操作系统的主要功能\n* 1.处理机管理功能\n    * 进程控制\n    * 进程同步\n        * 进程互斥方式\n        * 进程同步方式(协同)\n    * 进程通信\n    * 调度\n        * 作业调度\n        * 进程调度\n* 2.存储器管理功能\n    * 内存分配\n        * 静态分配\n        * 动态分配\n    * 内存保护\n    * 地址映射\n    * 内存扩充\n* 3.设备管理功能\n    * 缓冲管理\n    * 设备分配\n    * 设备处理\n        * 设备处理程序又称设备驱动程序\n* 4.文件管理功能\n    * 文件存储空间的管理\n    * 目录管理\n    * 文件的读写管理和保护\n* 5.操作系统与用户之间的接口\n    * 用户接口\n    * 程序接口\n* 6.现代操作系统的新功能\n    * 系统安全\n    * 网络的功能和服务\n    * 支持多媒体\n### 5.OS结构设计\n* 传统操作系统结构\n    * 无结构操作系统\n    * 模块化OS\n    * 分层式结构OS\n* 微内核os结构\n    * 客户/服务器模式\n    * 面对对象的程序设计\n## 第二章进程的描述与控制\n### 前驱图和程序执行\n### 程序并发执行\n* 程序的并发执行\n* 程序并发执行时的特征\n    * 间断性\n    * 失去封闭性\n    * 不可再现性\n### 进程的描述\n* 进程的定义\n    * 进程是程序的一次执行\n    * 进程是一个程序及其数据在处理机上顺序执行时所发生的活动\n    * 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位\n* 进程的特征\n    * 动态性\n    * 并发性\n    * 独立性\n    * 异步性\n* 从操作系统角度分类\n    * 系统进程\n    * 用户进程\n* 进程和程序的区别\n    * 进程是动态概念，而程序则是静态概念\n    * 程序是指令的有序集合，永远存在；进程强调是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；\n    * 进程具有并发性，而程序没有\n    * 进程可创建其他进程，而程序并不能形成新的程序\n    * 进程是竞争计算机资源的基本单位，程序不是\n* 进程和程序的联系\n    * 进程是程序在数据集上的一次执行\n    * 程序是构成进程的组成部分，一个程序可对应多个进程，一个进程可包括多个程序\n    * 进程的运行目标是执行所对应的程序\n    * 从静态看，进程由程序、数据和进程控制块（PCB）组成\n* 进程的基本状态及转换\n    * 进程的三种基本状态\n        * 就绪状态ready\n        * 执行状态running\n        * 阻塞状态block\n    * 三种基本状态的转换\n    * 创建状态和终止状态\n        * 五状态进程模型\n    * 注意\n        * 阻塞态->运行态和就绪态->阻塞态这二种状态转换不可能发生\n* 挂起操作和进程状态的转换\n    * 挂起和阻塞的区别\n    * 挂起操作的目的\n        * 终端用户的需要: 修改、检查进程\n        * 父进程的需要：修改、协调子进程\n        * 对换的需要：缓和内存\n        * 负荷调节的需要：保证实时任务的执行\n    * 关键图\n* 进程管理中的数据结构\n    * 进程控制块PCB的作用\n        * 作为独立运行基本单位的标志\n        * 能实现间断性运行方式\n        * 提供进程管理所需要的信息\n        * 提供进程调度所需要的信息\n        * 实现与其他进程的同步与通信\n    * 进程控制块的信息\n        * 进程标识符\n            * 外部标识符PID\n            * 内部标识符(端口)\n        * 处理机状态\n            * 通用寄存器\n            * 指令计数器\n            * 程序状态字PSW\n            * 用户栈指针\n        * 进程调度信息\n            * 进程状态\n            * 进程优先级\n            * 进程调度所需的其他信息\n            * 事件\n        * 进程控制信息\n            * 程序和数据的地址\n            * 进程同步和通信机制\n            * 资源清单\n            * 链接指针\n        * 进程控制块的组织方式\n            * 线性方式\n            * 链接方式\n            * 索引方式\n### 进程控制\n* 操作系统内核\n    * 两大功能\n        * 支撑功能\n            * 中断管理\n            * 时钟管理\n            * 原语操作\n                * 进程的管理，由若干原语（primitive）来执行\n        * 资源管理功能\n            * 进程管理\n            * 存储器管理\n            * 设备管理\n    * 状态\n        * 系统态，管态，内核态\n        * 用户态，目态\n* 进程的创建\n    * 进程的层次结构\n        * 父进程\n        * 子进程\n    * 引起创建进程的事件\n        * 用户登录\n        * 作业调度\n        * 提供服务\n        * 应用请求\n    * 进程的创建过程\n        * 1.申请空白PCB\n        * 2.为新进程分配其运行所需的资源\n        * 3.初始化进程块PCB\n        * 4.如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列\n    * 进程的终止\n        * 引起进程终止的事件\n            * 1.正常结束\n            * 2.异常结束\n            * 3.外界干预\n        * 进程的终止过程\n            * 1.根据被终止进程的标识符\n    * 进程的阻塞与唤醒\n        * 引起进程阻塞和唤醒的事件\n            * 请求系统服务而未满足\n            * 启动某种操作而阻塞当前进程\n            * 新数据尚未到达\n            * 无新工作可做：系统进程\n        * 进程阻塞过程(自己阻塞自己)\n        * 进程唤醒过程(系统或其他进程唤醒自己)\n    * 进程的挂起与激活\n        * suspend\n        * active\n* 进程同步\n    * 基本概念\n        * 两种形式的制约关系\n            * 间接相互制约关系\n                * 互斥——竞争\n            * 直接相互制约关系\n                * 同步——协作\n        * 临界资源\n        * 分区\n            * 进入区enter section\n            * 临界区critical section\n            * 退出区exit section\n            * 剩余区remainder section\n        * 同步机制应遵循的规则\n            * 1.空闲让进\n            * 2.忙则等待\n            * 3.有限等待\n            * 4.让权等待\n    * 进程同步机制\n        * 软件同步机制:都没有解决让权等待，而且部分方法还会产生死锁的情况\n        * 硬件同步机制\n            * 关中断\n            * 利用Test-and-Set指令实现互斥\n            * 利用swap指令实现进程互斥\n        * 信号量机制\n            * 整型信号量\n            * 记录型信号量\n                * 由于整型信号量没有遵循让权等待原则，记录型允许负数，即阻塞链表\n            * AND型信号量\n            * 信号量集\n                * 理解:AND型号量的wait和signal仅能对信号施以加1或减1操作，意味着每次只能对某类临界资源进行一个单位的申请或释放。当一次需要N个单位时，便要进行N次wait操作，这显然是低效的，甚至会增加死锁的概率。此外，在有些情况下，为确保系统的安全性，当所申请的资源数量低于某一下限值时，还必须进行管制，不予以分配。因此，当进程申请某类临界资源时，在每次分配前，都必须测试资源数量，判断是否大于可分配的下限值，决定是否予以分配\n                * 操作\n                    * Swait(S1，t1，d1…Sn，tn，dn)\n                    * Ssignal(S1，d1…Sn，dn)\n                * 特殊情况\n    * 经典进程的同步问题\n        * 生产者–消费者问题\n        * 哲学家进餐问题\n        * 读者–写者问题\n### 进程通信\n* 进程通信是指进程之间的信息交换，又称低级进程通信\n* 进程通信的类型\n    * 共享存储器系统\n        * 基于共享数据结构的通信方式\n            * 生产者和消费者\n        * 基于共享存储区的通信方式\n            * 高级通信\n    * 管道通信系统(pipe)\n        * 高级通信\n    * 消息传递系统\n        * 高级通信\n        * 方式分类\n            * 直接通信\n            * 间接通信\n    * 客服机–服务器系统\n* 消息传递通信的实现方式\n    * 直接消息传递系统\n    * 信箱通信\n### 线程的基本概念\n* 线程的引入\n    * 线程的引入正是为了简化线程间的通信，以小的开销来提高进程内的并发程度\n    * 多线程并发的不足\n        * 进程的两个基本属性\n            * 一个拥有资源的独立单位，可独立分配系统资源\n            * 一个可独立调度和分派的基本单位，PCB\n        * 程序并发执行所需付出的时空开销\n            * 创建进程\n            * 撤销进程\n            * 进程切换\n        * 进程间通信效率低\n        * 将分配资源和调度两个属性分开\n    * 线程——作为调度和分派的基本单位\n        * 进程是系统资源分配的单位，线程是处理器调度的单位\n        * 线程表示进程的一个控制点，可以执行一系列的指令。通常，和应用程序的一个函数相对应\n        * 进程分解为线程还可以有效利用多处理器和多核计算机\n* 线程与进程的比较\n    * 不同点\n        * 调度的基本单位\n        * 并发性\n    * 相似点\n        * 状态：运行、阻塞、就绪\n        * 线程具有一定的生命期\n        * 进程可创建线程，一个线程可创建另一个子线程\n        * 多个线程并发执行时仍然存在互斥与同步\n* 线程的实现\n    * 线程的实现方式\n        * 内核支持线程KST\n        * 用户级线程ULT\n        * 组合方式\n    * 多线程OS中的进程属性\n        * 进程是一个可拥有资源的基本单位\n        * 多个线程可并发执行\n        * 进程已不是可执行的实体\n    * 线程的状态和线程控制块\n        * 线程运行的三个状态\n            * 执行状态\n            * 就绪状态\n            * 阻塞状态\n        * 线程控制块TCB\n## 第三章:处理机调度与死锁\n### 处理机调度算法的目标\n* 处理机调度算法的共同目标\n    * 资源利用率:CPU的利用率=CPU有效工作时间/(CPU有效工作时间+CPU空闲等待时间)\n    * 公平性\n    * 平衡性\n    * 策略强制执行\n* 批处理系统的目标\n    * 平均周转时间短\n    * 系统吞吐量高\n    * 处理机利用率高\n* 分时系统的目标\n    * 响应时间快\n    * 均衡性\n* 实时系统目标\n    * 截止时间的保证\n    * 可预测性\n* 处理机调度的层次\n    * 高级调度（作业调度）\n        * 分时系统无需作业调度，因为需要交互\n        * 批处理系统需要作业调度\n    * 中级调度（和挂起有关）\n    * 低级调度（进程调度）\n        * 进程调度是最基本的调度，任何操作系统都有进程调度。\n        * 低级调度的三个基本机制\n            * 排队器\n            * 分派器\n            * 上下文切换\n        * 进程调度方式\n            * 非抢占方式\n            * 抢占方式\n                * 优先权原则\n                * 短进程优先原则\n                * 时间片原则\n        * 进程调度的任务\n            * 保存处理机的现场信息\n            * 按某种算法选取进程\n            * 把处理器分配给进程\n        * 进程调度的算法\n            * 优先级调度算法\n                * 优先级调度算法的类型\n                    * 非抢占式优先级调度算法\n                        * 等当前进程执行完以后，再执行另一个优先权最高的进程\n                        * 这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。 \n                    * 抢占式优先级调度算法\n                        * 不等当前进程结束，直接抢处理机\n                        * 常用于要求比较严格的实时系统中， 以及对性能要求较高的批处理和分时系统中。\n                * 优先级的类型\n                    * 静态优先级\n                        * 优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，例如，0~7或0~255中的某一整数， 又把该整数称为优先数。\n                        * 可以参考BIOS系统中设置boot的优先级\n                    * 动态优先级\n                        * 在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。\n            * 轮转调度算法\n                * 基本原理:在轮转(RR)法中，系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并可设置每隔一定时间间隔(如30ms)即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其执行\n                * 进程切换时机\n                    * 时间片未用完，进程完成\n                    * 时间片到，进程未完成\n                * 时间片大小的确定\n                    * 太小利于短作业，增加系统切换开销\n                    * 太长就退化为FCFS算法\n                    * 一般选择: q略大于一次交互所需要的时间，使大多数进程在一个时间片内完成\n                * 一般来说，平均周转时间将比SJF长，但是有较好的响应时间\n            * 多队列调度算法\n            * 多级反馈队列调度算法\n                * 调度机制\n                    * 设置多个就绪队列\n                    * 每个队列都采用FCFS算法\n                    * 按照队列优先级调度，在第n队列中采取按时间片轮转的方式运行\n                * 调度算法的性能\n                    * 对于终端型用户，由于作业小，感觉满意\n                    * 对于短批处理作业用户，周转时间也较小\n                    * 长批处理作业用户，也能够得到执行\n            * 基于公平原则的调度算法\n                * 保证调度算法\n                * 公平分享调度算法\n### 作业与作业调度\n* 作业\n    * 作业不仅包含程序和数据，还配有一份作业说明书，系统根据说明书对程序的运行进行控制。批处理系统是以作业为单位从外存掉入内存的。\n* 作业控制块JCB\n    * 为每个作业设置一个JCB，保存了对作业管理调度的全部信息。是作业存在的标志。\n* 作业步\n    * 作业步，每个作业都必须经过若干相对独立，有相互关联的顺序步骤才能得到结果。每一个步骤就是一个作业步。\n* 作业运行的三个阶段\n    * 收容阶段\n    * 运行阶段\n    * 完成阶段\n* 作业运行的三个状态\n    * 后备状态\n    * 运行状态\n    * 完成状态\n* 作业调度的主要任务\n    * 接纳多少个作业\n    * 接纳哪些作业\n* 先来先服务(first–come first–served，FCFS)调度算法\n    * 比较有利于长作业，而不利于短作业。\n    * 有利于CPU繁忙的作业，而不利于I/O繁忙的作业。\n* 短作业优先(short job first，SJF)的调度算法\n    * 优点\n        * 比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；\n        * 提高系统的吞吐量；\n    * 缺点\n        * 必须预知作业的运行时间\n        * 对长作业非常不利，长作业的周转时间会明显地增长\n        * 在采用SJF算法时，人–机无法实现交互\n        * 该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理\n* 优先级调度算法(priority–scheduling algorithm，PSA)\n* 高响应比优先调度算法(Highest Response Ratio Next,HRRN)\n    * 原理\n        * 在每次选择作业投入运行时，先计算此时后备作业队列中每个作业的响应比RP然后选择其值最大的作业投入运行\n        * 优先权=(等待时间+要求服务时间)/要求服务时间=响应时间/要求服务时间=1+等待时间/要求服务时间\n    * 特点\n        * 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而类似于SJF算法，有利于短作业\n        * 当要求服务的时间相同时，作业的优先权又决定于其等待时间，因而该算法又类似于FCFS算法\n        * 对于长时间的优先级，可以为随等待时间的增加而提高，当等待时间足够长时，也可获得处理机\n### 实时调度(HRT和SRT任务)\n* 实现实时调度的基本条件\n    * 提供必要信息\n        * 就绪时间\n        * 开始截止时间和完成截止时间\n        * 处理时间\n        * 资源要求\n        * 优先级\n    * 系统处理能力强\n        * ∑(Ci/Pi)≤1\n        * N个处理机:∑(Ci/Pi)≤N\n    * 采用抢占式调度机制\n    * 具有快速切换机制\n        * 对中断的快速响应能力\n        * 快速的任务分派能力\n* 实时调度算法的分类\n    * 非抢占式调度算法\n        * 非抢占式轮转调度算法\n        * 非抢占式优先调度算法\n    * 抢占式调度算法\n        * 基于时钟中断的抢占式优先级调度算法\n        * 立即抢占的优先级调度算法\n* 最早截止时间优先EDF(Earliest Deadline First)算法\n    * 根据任务的开始截至时间来确定任务的优先级\n        * 截至时间越早，优先级越高\n    * 非抢占式调度方式用于非周期实时任务\n    * 抢占式调度方式用于周期实时任务\n* 最低松弛度优先LLF(Least Laxity First)算法\n    * 类似EDF\n    * 算法根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高， 以使之优先执行。\n    * 松弛度例子\n        * 例如，一个任务在200ms时必须完成，而它本身所需的运行时间就有100ms，因此，调度程序必须在100 ms之前调度执行，该任务的紧急程度(松弛程度)为100 ms\n* 优先级倒置(Priority inversion problem)\n    * 优先级倒置的形成\n        * 高优先级进程被低优先级进程延迟或阻塞。\n    * 优先级倒置的解决方法\n        * 简单的:假如进程P3在进入临界区后P3所占用的处理机就不允许被抢占\n        * 实用的:建立在动态优先级继承基础上的\n### 死锁概述\n* 资源问题\n    * 可重用性资源\n        * 计算机外设\n    * 消耗性资源\n        * 数据，消息\n    * 可抢占性资源\n        *  不引起死锁\n        * CPU，内存 \n    * 不可抢占性资源\n        * 光驱，打印机\n* 计算机系统中的死锁\n    * 竞争不可抢占性资源引起死锁\n    * 竞争可消耗资源引起死锁\n    * 进程推进顺序不当引起死锁\n* 死锁的定义，必要条件和处理方法\n    * 定义:如果一组进程中的每一个进程都在等待仅由该进程中的其他进程才能引发的事件，那么该组进程是死锁的\n    * 产生死锁的必要条件\n        * 互斥条件\n        * 请求和保存条件\n        * 不可抢占条件\n        * 循环等待条件\n            * 如果每个资源只有一个实例，则环路等待条件是死锁存在的充分必要条件\n    * 处理死锁的方法\n        * 预防死锁\n            * 静态方法，在进程执行前采取的措施，通过设置某些限制条件，去破坏产生死锁的四个条件之一，防止发生死锁。\n            * 预防死锁的策略\n                * 破坏\"请求和保存\"条件\n                    * 第一种协议\n                        * 所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源\n                        * 优点:简单，易行，安全\n                        * 缺点\n                            * 资源被严重浪费，严重地恶化了资源的利用率\n                            * 使进程经常会发生饥饿现象\n                    * 第二种协议\n                        * 它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的，且已用毕的全部资源，然后再请求新的所需资源\n                * 破坏\"不可抢占\"条件\n                    * 当一个已经保存了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请\n                * 破坏\"循环等待\"条件\n                    * 对系统所以资源类型进行线性排序，并赋予不同的序号\n                    * 例如令输入机的序号为1，打印机序号为2，磁盘机序号为3等。所有进程对资源的请求必须严格按资源序号递增的次序提出。\n        * 避免死锁\n            * 动态的方法，在进程执行过程中采取的措施，不需事先采取限制措施破坏产生死锁的必要条件，而是在进程申请资源时用某种方法去防止系统进入不安全状态，从而避免发生死锁。如银行家算法\n            * 避免死锁的策略\n                * 系统安全状态\n                    * 安全状态\n                        * 某时刻，对于并发执行的n个进程，若系统能够按照某种顺序如<p1,p2…pn>来为每个进程分配所需资源，直至最大需求，从而使每个进程都可顺利完成，则认为该时刻系统处于安全状态，这样的序列为安全序列\n                    * 安全状态之例\n                    * 由安全状态向不安全状态的转换\n                * 利用银行家算法避免死锁\n                    * 含义:每一个新进程在进入系统时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给它，否则让进程等待\n                    * 银行家算法中的数据结构\n                        * 可用资源向量 Available[m]：m为系统中资源种类数，Available[j]=k表示系统中第j类资源数为k个。\n                        * 最大需求矩阵 Max[n,m]：n为系统中进程数，Max[i,j]=k表示进程i对j类资源的最大需求数为中k。\n                        * 分配矩阵 Allocation[n，m]:它定义了系统中每一类资源当前已分配给每一进程资源数，   Allocation[i,j] = k表示进程i已分得j类资源的数目为k个。\n                        * 需求矩阵 Need[n,m]：它表示每个进程尚需的各类资源数，Need[i,j]=k 表示进程i   还需要j类资源k个。Need[i,j]=Max[i,j] - Allocation[i,j]\n                    * 银行家算法\n                    * 安全性算法\n                    * 银行家算法之例\n                    * 解题\n                        * 矩阵\n                        * 列表\n        * 检测死锁\n            * 死锁的检测与解除\n                * 死锁的检测\n                    * 资源分配图\n                        * 简化步骤\n                            * 选择一个没有阻塞的进程p\n                            * 将p移走，包括它的所有请求边和分配边\n                            * 重复步骤1，2，直至不能继续下去\n                    * 死锁定理\n                        * 若一系列简化以后不能使所有的进程节点都成为孤立节点\n                    * 检测时机\n                        *  当进程等待时检测死锁 （其缺点是系统的开销大）\n                        *  定时检测\n                        *  系统资源利用率下降时检测死锁\n                    * 死锁检测中的数据结构\n                * 死锁的解除\n                    * 抢占资源\n                    * 终止(或撤销)进程\n                    * 终止进程的方法\n                        * 终止所有死锁进程\n                        * 逐个终止进程\n                            * 代价最小\n                                * 进程的优先级的大小\n                                * 进程已执行了多少时间，还需时间\n                                * 进程在运行中已经使用资源的多少，还需多少资源\n                                * 进程的性质是交互式还是批处理的\n                    * 付出代价最小的死锁解除算法\n                        * 是使用一个有效的挂起和解除机构来挂起一些死锁的进程\n        * 解除死锁\n## 第四章:存储器管理\n### 存储器的层次结构\n* 多层结构的存储系统\n    * 存储器的多层结构\n        * CPU寄存器\n        * 主存\n        * 辅存\n    * 可执行存储器\n        * 寄存器和主存的总称\n        * 访问速度快，进程可以在很少的时钟周期内用一条load或store指令完成存取。\n* 主存储器与寄存器\n* 高速缓存和磁盘缓存\n### 程序的装入和链接\n* 步骤\n    * 编译\n        * 源程序 ->目标模块（Object modules）--------Compiler\n            * 由编译程序对用户源程序进行编译，形成若干个目标模块\n    * 链接\n        * 一组目标模块 ->装入模块 （Load Module）----------Linker\n            * 由链接程序将编译后形成的一组目标模板以及它们所需要的库函数链接在一起，形成一个完整的装入模块\n    * 装入\n        * 装入模块 ->内存  --------Loader\n            * 由装入程序将装入模块装入内存\n* 程序的装入\n    * 绝对装入方式\n        * 在编译时，如果知道程序将驻留在内存中指定的位置。编译程序将产生绝对地址的目标代码。\n    * 可重定位装入方式\n        * 在可执行文件中，列出各个需要重定位的地址单元和相对地址值。当用户程序被装入内存时，一次性实现逻辑地址到物理地址的转换，以后不再转换(一般在装入内存时由软件完成)。\n        * 优点：不需硬件支持，可以装入有限多道程序。\n        * 缺点：一个程序通常需要占用连续的内存空间，程序装入内存后不能移动。不易实现共享。\n    * 动态运行时的装入方式\n        * 动态运行时的装入程序在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换为物理地址，而是把这种地址转换推迟到程序真正要执行时才进行\n        * 优点：\n            * OS可以将一个程序分散存放于不连续的内存空间，可以移动程序，有利用实现共享。\n            * 能够支持程序执行中产生的地址引用，如指针变量（而不仅是生成可执行文件时的地址引用）。\n        * 缺点：需要硬件支持，OS实现较复杂。\n        * 它是虚拟存储的基础。\n* 程序的链接\n    * 静态链接方式(lib)\n    * 装入时动态链接\n    * 运行时动态链接(dll)\n### 连续分配存储管理方式\n* 连续分配\n    * 单一连续分配(DOS)\n    * 固定分区分配(浪费很多空间)\n    * 动态分区分配\n* 地址映射和存储保护措施\n    * 基址寄存器：程序的最小物理地址\n    * 界限寄存器：程序的逻辑地址范围\n    * 物理地址 = 逻辑地址 + 基址\n* 内碎片：占用分区之内未被利用的空间\n* 外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）\n* 把内存划分为若干个固定大小的连续分区。固定式分区又称为静态分区。\n    * 分区大小相等：只适合于多个相同程序的并发执行（处理多个类型相同的对象）。\n    * 分区大小不等：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。\n    * 优点：无外碎片、易实现、开销小。\n    * 缺点：\n        * 存在内碎片，造成浪费\n        * 分区总数固定，限制了并发执行的程序数目。\n        * 通用Os很少采用，部分控制系统中采用\n* 动态创建分区：指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。可变式分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。\n    * 基于顺序搜索的动态分区分配算法\n        * 首次适应算法（first fit,FF）\n            * 顺序找，找到一个满足的就分配，但是可能存在浪费\n            * 这种方法目的在于减少查找时间。\n            * 空闲分区表（空闲区链）中的空闲分区要按地址由低到高进行排序\n        * 循环首次适应算法（next fit，NF）\n            * 相对上面那种，不是顺序，类似哈希算法中左右交叉排序\n            * 空闲分区分布得更均匀，查找开销小\n            * 从上次找到的空闲区的下一个空闲区开始查找，直到找到第一个能满足要求的的空闲区为止，并从中划出一块与请求大小相等的内存空间分配给作业。\n        * 最佳适应算法（best fit，BF）\n            * 找到最合适的，但是大区域的访问次数减少\n            * 这种方法能使外碎片尽量小。\n            * 空闲分区表（空闲区链）中的空闲分区要按大小从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。\n        * 最坏适应算法（worst fit，WF）\n            * 相对于最好而言，找最大的区域下手，导致最大的区域可能很少，也造成许多碎片\n            * 空闲分区按大小由大到小排序\n    * 基于索引搜索的动态分区分配算法\n        * 快速适应算法（quick fit）\n        * 伙伴系统（buddy system）\n        * 哈希算法\n    * 动态可重定位分区分配\n        * 紧凑\n        * 动态重定位\n            * 动态运行时装入，地址转化在指令执行时进行，需获得硬件地址变换机制的支持\n            * 内存地址=相对地址+起始地址\n        * 动态重定位分区分配算法\n            * 1、在某个分区被释放后立即进行紧凑，系统总是只有一个连续的分区而无碎片，此法很花费机时。\n            * 2、当“请求分配模块”找不到足够大的自由分区分给用户时再进行紧凑，这样紧缩的次数比上种方法少得多，但管理复杂。采用此法的动态重定位分区分配算法框图如下：\n    * 优点：没有内碎片。\n    * 缺点：外碎片。\n### 对换（了解）\n* 系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。\n### 基本分页存储管理方式\n* 分页存储管理的基本方式\n    * 页面\n        * 将一个进程的逻辑地址空间分成若干个大小相等的片\n    * 页框（frame）\n        * 内存空间分成与页面相同大小的存储块\n    * 由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”\n    * 地址结构\n        * 页号P+位移量W(0-31)\n    * 页表\n        * 在分页系统中，允许将进程的各个页离散地存储在内存在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每一个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表\n        * 页表的作用是实现从页面号到物理块号的地址映射\n* 地址变换机构\n    * 基本的地址变换机构\n        * 要访问两次内存\n        * 页表大都驻留在内存中\n        * 为了实现地址变换功能，在系统中设置页表寄存器（PTR），用来存放页表的始址和页表的长度。\n        * 在进程未执行时，每个进程对应的页表的始址和长度存放在进程的PCB中，当该进程被调度时，就将它们装入页表寄存器。\n    * 具有快表的地址变换机构\n        * 提高了效率，此处会有计算题\n        * 如果页表存放在内存中，则每次访问内存时，都要先访问内存中的页表，然后根据所形成的物理地址再访问内存。这样CPU存一个数据必须访问两次内存，从而使计算机的处理速度降低了1/2。\n        * 为了提高地址变换的速度，在地址变换机构中增设了一个具有并行查询功能的特殊的高速缓冲存储器，称为“联想存储器”或“快表”，用以存放当前访问的那些页表项。\n        * 地址变换过程为：\n            * 1、CPU给出有效地址\n            * 2、地址变换机构自动地将页号送入高速缓存，确定所需要的页是否在快表中。\n            * 3、若是，则直接读出该页所对应的物理块号，送入物理地址寄存器；\n            * 4、若快表中未找到对应的页表项，则需再访问内存中的页表\n            * 5、找到后，把从页表中读出的页表项存入快表中的一个寄存器单元中，以取代一个旧的页表项。\n* 两级和多级页表\n    * 主要是有的时候页表太多了，要化简\n    * 格式：外层页号P1+外层页内地址P2+页内地址d\n    * 基本方法：将页表进行分页，每个页面的大小与内存物理块的大小相同，并为它们进行编号，可以离散地将各个页面分别存放在不同的物理块中。\n* 反置页表\n    * 反置页表为每一个物理块（页框）设置一个页表项，并按物理块排序，其内容则是页号和其所属进程的标识。\n* 优点：\n    * 没有外碎片，每个内碎片不超过页大小。\n    * 一个程序不必连续存放。\n    * 便于改变程序占用空间的大小。即随着程序运行而动态生成的数据增多，地址空间可相应增长。\n* 缺点：程序全部装入内存。\n### 分段存储管理方式\n* 引入\n    * 方便编程\n    * 信息共享\n    * 动态增长\n    * 动态链接\n* 在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。\n* 内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定\n* 分段系统的基本原理\n    * 分段\n        * 格式：段号+段内地址\n    * 段表\n        * 段表实现了从逻辑段到物理内存区的映射。\n    * 地址变换机构\n* 和分页的区别\n    * 页是信息的物理单位\n    * 页的大小固定且由系统固定\n    * 分页的用户程序地址空间是一维的\n    * 通常段比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。\n    * 分页是系统管理的需要，分段是用户应用的需要。一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。\n* 信息共享\n    * 这是分段最重要的优点\n* 段页式存储管理方式\n    * 基本原理\n        * 格式：段号（S）+段内页号（P）+页内地址（W）\n    * 地址变换过程\n        * 需要三次访问过程\n    * 在段页式系统中，为了获得一条指令或数据，需三次访问内存：第一次访问内存中的段表，从中取得页表始址；第二次访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正根据所得的物理地址取出指令或数据。\n## 第五章：虚拟存储器\n### 常规存储管理方式的特征\n* 一次性\n* 驻留性\n### 局部性原理\n* 程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域\n* 时间局限性\n    * 如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环操作\n* 空间局限性\n    * 一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。\n### 定义\n* 指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统\n### 优点\n* 大程序：可在较小的可用内存中执行较大的用户程序；\n* 大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存(real memory)\n* 并发：可在内存中容纳更多程序并发执行；\n* 易于开发：不必影响编程时的程序结构\n* 以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术\n### 特征\n* 离散性\n    * 指在内存分配时采用离散的分配方式，它是虚拟存储器的实现的基础\n* 多次性\n    * 指一个作业被分成多次调入内存运行，即在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可。多次性是虚拟存储器最重要的特征\n* 对换性\n    * 指允许在作业的运行过程中在内存和外存的对换区之间换进、换出。\n* 虚拟性\n    * 指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。\n### 虚拟存储器的实现方式\n* 请求分页存储管理方式\n    * 硬件\n        * 请求页表机制\n            * 格式：页号+物理块号+状态位P+访问字段A+修改位M+外存地址\n        * 缺页中断机构\n        * 地址变换机构（过程图很关键）\n    * 请求分页中的内存分配\n        * 最小物理块数\n            * 即能保证进程正常运行所需的最小物理块数\n        * 内存分配策略\n            * 固定分配局部置换（国王的大儿子）\n            * 可变分配全局置换（国王的二儿子）\n            * 可变分配局部置换（国王的小儿子）\n    * 物理块分配算法\n        * 平均分配算法\n        * 按比例分配算法\n        * 考虑优先权的分配算法\n    * 页面调入策略\n        * 系统应在何时调入所需页面\n            * 预调页策略（不能实现）\n            * 请求调页策略（需要才给）\n        * 系统应该从何处调入这些页面\n            * 对换区\n            * 文件区\n        * 页面调入过程\n        * 缺页率（出计算题）\n* 请求分段系统\n    * 硬件\n        * 请求分段的段表机构\n        * 缺段中断机构\n        * 地址变换机构\n### 页面置换算法\n* 抖动的概念\n    * 即刚被换出的页很快又要被访问，需要将它重新调入，此时又需要再选一页调出\n* 最佳置换算法(需要预知后面进程，所以不能实现)\n* 先进先出页面置换算法（FIFO）\n    * 选择在内存中驻留时间最久的页面予以淘汰\n* 最近最久未使用置换算法（LRU）Recently\n    * 寄存器支持\n    * 特殊的栈结构\n* 最少使用置换算法（LFU）Frequently\n* clock置换算法（对访问位A的判断）\n    * 改进型——增加对修改位M思维判断\n* 页面缓冲算法（PBA,page buffering algorithm）\n    * 空闲页面链表\n    * 修改页面链表\n## 第六章：输入输出系统\n### I/O系统的功能，模型和接口\n* I/O系统管理的对象是I/O设备和相应的设备控制器。\n* I/O系统的基本功能\n    * 隐藏物理设备的细节\n    * 与设备的无关性\n    * 提高处理机和I/O设备的利用率\n    * 对I/O设备进行控制\n    * 确保对设备的正确共享\n    * 错误处理\n* I/O软件的层次结构\n    * 用户层I/O软件\n    * 设备独立性软件\n    * 设备驱动程序（厂家开发）\n    * 中断处理程序\n    * 硬件\n* I/O系统的分层\n    * 中断处理程序\n    * 设备驱动程序\n    * 设备独立性软件\n* I/O系统接口\n    * 块设备接口\n        * 指以数据块为单位来组织和传送数据信息的设备\n        * 典型的块设备是磁盘、光盘\n        * 块设备的基本特征\n            * ①传输速率较高，通常每秒钟为几兆位；\n            * ②它是可寻址的，即可随机地读/写任意一块；\n            * ③磁盘设备的I/O采用DMA方式。\n    * 流设备接口\n        * 又称字符设备指以单个字符为单位来传送数据信息的设备\n        * 这类设备一般用于数据的输入和输出，有交互式终端、打印机\n        * 字符设备的基本特征\n            * ①传输速率较低；\n            * ②不可寻址，即不能指定输入时的源地址或输出时的目标地址；\n            * ③字符设备的I/O常采用中断驱动方式。\n    * 网络通信接口\n        * 提供网络接入功能，使计算机能通过网络与其他计算机进行通信或上网浏览。\n### I/O设备和设备控制器\n* 分类\n    * 使用特性分\n        * 存储设备\n        * I/O设备\n    * 传输速率分\n        * 低速设备（几字节——几百字节）\n            * 典型的设备有键盘、鼠标、语音的输入\n        * 中速设备（数千——数万字节）\n            * 典型的设备有行式打印机、激光打印机\n        * 高速设备（数十万——千兆字节）\n            * 典型的设备有磁带机、磁盘机、光盘机\n* 设备并不是直接与CPU进行通信，而是与设备控制器通信。在设备与设备控制器之间应该有一个接口。\n    * 数据信号：控制器 ←  设备 ←  控制器\n        * 传送数据信号，输入、输出bit\n    * 控制信号: 控制器  →  设备\n        * 执行读、写操作的信号\n    * 状态信号：设备当前使用状态\n* 设备控制器\n    * 主要功能：控制一个或多个I/O设备，以实现I/O设备和计算机之间的数据交换\n    * 基本功能\n        * 接收和识别命令\n            * 控制寄存器、命令译码器\n        * 数据交换\n            * 实现CPU与控制器，控制器与设备间的数据交换\n        * 标识和报告设备的状态\n        * 地址识别\n            * 配置地址译码器，识别不同的设备\n        * 数据缓冲区\n        * 差错控制\n    * 设备控制器的组成\n        * 设备控制器与处理机（CPU）的接口\n            * 实现CPU与设备控制器之间的通信\n        * 设备控制器与设备的接口\n            * 控制器可连接多个设备\n        * I/O逻辑\n            * 实现对设备的控制\n            * CPU利用该逻辑向控制器发送I/O命令\n            * 命令、地址译码\n* 内存映像I/O\n    * 驱动程序将抽象I/O命令转换出的一系列具体的命令，参数等数据装入设备控制器的相应寄存器，由控制器来执行这些命令，具体实施对I/O设备的操作\n* I/O通道\n    * 目的：建立独立的I/O操作(组织, 管理和结束)，使由CPU处理的I/O工作转由通道完成（解放CPU，实现并行）\n\n    * 什么是I/O通道？\n        *  是一种特殊的处理机，具有通过执行通道程序完成I/O操作的指令\n        *  特点：指令单一(局限于与I/O操作相关的指令)，与CPU共享内存\n    * 基本过程：\n        * CPU向通道发出I/O指令->通道接收指令->从内存取出通道程序处理I/O->向CPU发出中断\n    * 通道类型\n        * 字节多路通道\n            * 低中速连接子通道时间片轮转方式共享主通道\n            * 字节多路通道不适于连接高速设备，这推动了按数组方式进行数据传送的数组选择通道的形成。\n        * 数组选择通道\n            * 这种通道可以连接多台高速设备，但只含有一个分配型子通道，在一段时间内只能执行一道通道程序， 控制一台设备进行数据传送， 直至该设备传送完毕释放该通道。这种通道的利用率很低。\n        * 数组多路通道\n            * 含有多个非分配型子通道，前两种通道的组合，通道利用率较好\n    * 瓶颈问题\n        * 原因;通道不足\n        * 解决办法：增加设备到主机间的通路，而不增加通道（结果类似RS触发器）\n### 中断机构和中断处理程序\n* 中断\n    * 分类\n        * 中断（外部触发）\n            * 对外部I/O设备发出的中断信号的响应\n        * 陷入（内部原因：除0）\n            * 由CPU内部事件引起的中断\n    * 中断向量表（类比51单片机）\n        * 中断程序的入口地址表\n    * 中断优先级\n        * 对紧急程度不同的中断处理方式\n    * 对多中断源的处理方式\n        * 屏蔽中断\n        * 嵌套中断\n* 中断处理程序\n    * 测定是否有未响应的中断信号\n    * 保护被中断进程的CPU环境\n    * 转入相应的设备处理程序\n    * 中断处理\n    * 恢复CPU 的现场并退出中断\n### 设备驱动程序\n* 是I/O进程与设备控制器之间的通信程序，又由于它常以进程的形式存在，故以后就简称为设备驱动进程\n* 主要任务是接受来自它上一层的与设备无关软件的抽象请求，并执行这个请求。\n* 功能\n    * 1) 接收由I/O进程发来的命令和参数， 并将命令中的抽象要求转换为具体要求。例如，将磁盘块号转换为磁盘的盘面、 磁道号及扇区号。\n    * 2) 检查用户I/O请求的合法性，了解I/O设备的状态，传递有关参数，设置设备的工作方式。 \n    * 3) 发出I/O命令，如果设备空闲，便立即启动I/O设备去完成指定的I/O操作；如果设备处于忙碌状态，则将请求者的请求块挂在设备队列上等待。\n    * 4) 及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。\n    * 5) 对于设置有通道的计算机系统，驱动程序还应能够根据用户的I/O请求，自动地构成通道程序。 \n* 设备驱动程序的处理过程\n    * 将用户和上层软件对设备控制的抽象要求转换成对设备的具体要求，如对抽象要求的盘块号转换为磁盘的盘面、磁道及扇区。\n    * 检查I/O请求的合理性。\n    * 读出和检查设备的状态，确保设备处于就绪态。\n    * 传送必要的参数，如传送的字节数，数据在主存的首址等。\n    * 工作方式的设置。\n    * 启动I/O设备，并检查启动是否成功，如成功则将控制返回给I/O控制系统，在I/O设备忙于传送数据时，该用户进程把自己阻塞，直至中断到来才将它唤醒，而CPU可干别的事。\n* 对I/O设备的控制方式\n    * I/O控制的宗旨\n        * 减少CPU对I/O控制的干预\n        * 充分利用CPU完成数据处理工作\n    * I/O 控制方式\n        * 轮询的可编程I/O方式\n        * 中断驱动I/O方式\n        * DMA控制方式\n        * I/O通道控制方式\n* DMA控制器组成\n    * 主机与DMA控制器的接口\n    * DMA控制器与块设备的接口\n    * I/O控制逻辑\n### 与设备无关的I/O软件\n* 基本概念\n    * 含义： 应用程序独立于具体使用的物理设备。\n    * 驱动程序是一个与硬件(或设备)紧密相关的软件。为实现设备独立性，须在驱动程序上设置一层软件，称为设备独立性软件。\n    * 设备独立性(Device Independence)的优点\n        * 以物理设备名使用设备\n        * 引入了逻辑设备名\n        * 逻辑设备名称到物理设备名称的转换（易于实现I/O重定向）\n* 与设备无关的软件\n    * 设备驱动程序的统一接口\n    * 缓存管理\n    * 差错控制\n    * 对独立设备的分配与回收\n    * 独立于设备的逻辑数据块\n* 设备分配中的数据结构\n    * 设备控制表DCT\n    * 控制器控制表COCT\n    * 通道控制表CHCT\n    * 显然，在有通道的系统中，一个进程只有获得了通道，控制器和所需设备三者之后，才具备了进行I/O操作的物理条件\n    * 系统设备表SDT\n    * 逻辑设备表LUT\n    * 分配的流程，从资源多的到资源紧张的:LUT->SDT->DCT->COCT->CHCT\n    * 在申请设备的过程中，根据用户请求的I/O设备的逻辑名，查找逻辑设备和物理设备的映射表；以物理设备为索引，查找SDT，找到该设备所连接的DCT；继续查找与该设备连接的COCT和CHCT，就找到了一条通路。\n### 用户层的I/O软件\n* 系统调用与库函数\n    * OS向用户提供的所有功能，用户进程都必须通过系统调用来获取\n    * 在C语言以及UNIX系统中，系统调用（如read）与各系统调用所使用的库函数（如read）之间几乎是一一对应的。而微软的叫Win32API\n* 假脱机系统（spooling）\n    * spooling技术是对脱机输入/输出系统的模拟\n    * 主要组成\n        * 输入/输出井\n        * 输入/输出缓冲区\n        * 输入/输出进程\n        * 井管理程序\n    * 特点（体现操作系统的虚拟性）\n        * 提高了I/O的速度\n            * 对数据所进行的I/O操作，已从对低速设备演变为对输入井或输出井中的数据存取。\n        * 将独占设备改造为共享设备\n            * 实际分给用户进程的不是打印设备，而是共享输出井中的存储区域 \n        * 实现了虚拟设备功能\n            * 将独占设备变成多台独占的虚拟设备。\n### 缓冲区管理\n* 缓冲的引入（原因）\n    * 缓和CPU与I/O设备间速度不匹配的矛盾\n    * 减少对CPU的中断频率，放宽对CPU中断响应时间的限制\n    * 提高CPU和I/O设备之间的并行性\n    * 解决数据粒度不匹配的问题\n* 单缓冲区\n    * 即在CPU计算的时候，将数据数据输入到缓冲区(大小取决与T和C的大小)\n* 双缓冲区\n    * 即允许CPU连续工作（T不断）\n* 环形缓冲区（专为生产者和消费者打造）\n    * 组成\n        * 多个缓冲区\n        * 多个指针\n    * 使用\n        * Getbuf过程\n        * Releasebuf过程\n    * 同步问题\n* 缓冲池(理解为更大的缓冲区)\n    * 组成\n        * 空白缓冲队列（emq）\n            * 由空缓冲区链接而成F(emq)，L(emq)分别指向该队列首尾缓冲区\n        * 输入队列（inq）\n            * 由装满输入数据的缓冲区链接而成F(inq)，L(inq)分别指向该队列首尾缓冲区\n        * 输出队列（outq）\n            * 由装满输出数据的缓冲区链接而成F(outq)， L(outq)分别指向该队列首尾缓冲\n    * Getbuf和Putbuf过程\n        * 收容：缓冲池接收外界数据\n        * 提取：外界从缓冲池获得数据\n    * 缓冲区工作方式（从缓冲区的角度来看）\n        * 收容输入\n        * 提取输入\n        * 收容输出\n        * 提取输出\n### 磁盘存储器的性能和调度\n* 数据的组织和格式\n* 磁盘的类型\n    * 固定头磁盘（贵）\n    * 移动头磁盘\n* 磁盘访问的时间（关键）\n    * 寻道时间Ts=m*n+s\n    * 旋转延迟时间Tr\n    * 传输时间Tt=b/rN\n    * 总时间Ta=Ts+1/2r+b/rN\n* 磁盘的调度算法（掌握图表）\n    * 先来先服务（FCFS）\n        * 优点：公平，简单\n        * 缺点：可能导致某些进程的请求长期得不到满足\n    * 最短寻道时间优先（SSTF）\n        * 说明：要求访问的磁道和当前磁头所在的磁道距离最近，以使每次的寻道时间最短\n    * 扫描算法（SCAN）\n        * 扫描算法不仅考虑到欲访问的磁道与当前磁道间的距离，更优先考虑的是磁道当前的移动方向\n        * 联想电梯的运行\n        * 可防止低优先级进程出现“饥饿”的现象\n    * 循环扫描算法（CSCAN）\n        * 算法规定磁头单向移动，例如，只是自里向外移动，当磁头移到最外的磁道并访问后，磁头立即返回到最里的欲访问磁道，亦即将最小磁道号紧接着最大磁道号构成循环，进行循环扫描\n    * NStepScan算法\n        * N步SCAN算法是将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次这些子队列。\n    * FSCAN算法\n        * 是Nstepscan算法的简化，将磁盘请求队列分成两个子队列\n## 第七章：文件管理\n### 数据项\n* 基本数据项\n* 组合数据项\n### 记录\n* 记录是一组相关数据项的集合，用于描述一个对象在某个方面的属性\n### 文件\n* 文件类型\n* 文件长度\n* 文件的物理位置\n* 文件的建立时间\n### 文件操作\n* 创建文件\n* 删除文件\n* 读文件\n* 写文件\n* 设置文件读写的位置\n### 文件的逻辑结构\n* 顺序文件\n* 记录寻址\n* 索引文件\n* 索引顺序文件\n* 直接文件和哈希文件\n### 文件目录\n* 文件控制块（FCB）\n    * 文件名+inode(属性)\n* 简单的文件目录\n    * 单级文件目录\n        * 查找慢\n        * 不允许重名\n        * 不便于实现文件共享\n    * 两级文件目录\n        * 提高检索速度，从M*N到M+N\n* 树形结构目录\n    * 路径名\n        * “..”是父目录\n        * “/”是根目录\n        * 区别绝对路径和相对路径（../.../.../1/2/3/）\n### 文件共享\n* 有向无循环图（DAG）\n* 利用符号链接实现文件共享\n    * 实际上就是“快捷方式”\n### 文件保护\n\n![picture](https://github.com/SSHeRun/CS-Xmind-Note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png)\n","source":"_posts/2023-06-14-0-计算机操作系统.md","raw":"# 计算机操作系统\n\n## 目录\n\n## 一.操作系统引论\n### 1.操作系统的目标和功能\n* 目标\n    * 方便性\n    * 有效性\n        * 提高系统资源利用率\n        * 提高系统吞吐量\n    * 可扩充性\n    * 开放性\n* 作用\n    * OS作为用户与计算机硬件系统之间的接口\n        * 命令方式\n        * 系统调用方式\n        * 图标–窗口方式\n    * OS实现了对计算机资源的抽象\n### 2.操作系统的发展过程\n* 未配置操作系统的计算机系统\n    * 人工操作方式\n     * > 用户独占全机 CPU等待人工操作 严重降低了计算机资源的利用率\n\n    * 脱机输入/输出(Off–Line I/O)方式\n     * > 减少了CPU的空闲时间 提高了I/O速度 效率仍然不理想\n\n* 单道批处理系统\n* 多道批处理系统\n* > 1.资源利用率高\n* > 2.系统吞吐量大\n* > 3.平均周转时间长\n* > 4.无交互能力\n\n    * (宏观并行，微观串行)\n* 分时系统\n* > 特征:\n* > 1.多路性\n* > 2.独立性\n* > 3.及时性\n* > 4.交互性\n\n* 实时系统\n* 集群系统–超算~云计算\n* 微机操作系统的发展\n### 3.操作系统的基本特征\n* 1.并发concurrence\n    * 区别并行和并发\n     * > 并行性是指两个或多个事件在同一时刻发生→宏观并行，微观并行\n     * > 并发性是指两个或多个事件在同一时间间隔内发生→宏观并行，微观串行\n\n        * 并发是进程宏观一起运行，微观上交替运行，而并行是指同时运行\n    * 引入进程\n     * > 进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令，数据和堆栈等组成的，是一个能独立运行的活动实体\n\n* 2.共享sharing\n    * 1.互斥共享方式\n    * 2.同时访问方式\n    * 并发和共享是多用户(多任务)OS的两个最基本的特征。它们又是互为存在的条件\n* 3.虚拟virtual\n    * 时分复用技术\n    * 空分复用技术\n* 4.异步asynchronism\n### 4.操作系统的主要功能\n* 1.处理机管理功能\n    * 进程控制\n    * 进程同步\n        * 进程互斥方式\n        * 进程同步方式(协同)\n    * 进程通信\n    * 调度\n        * 作业调度\n        * 进程调度\n* 2.存储器管理功能\n    * 内存分配\n        * 静态分配\n        * 动态分配\n    * 内存保护\n    * 地址映射\n    * 内存扩充\n* 3.设备管理功能\n    * 缓冲管理\n    * 设备分配\n    * 设备处理\n        * 设备处理程序又称设备驱动程序\n* 4.文件管理功能\n    * 文件存储空间的管理\n    * 目录管理\n    * 文件的读写管理和保护\n* 5.操作系统与用户之间的接口\n    * 用户接口\n    * 程序接口\n* 6.现代操作系统的新功能\n    * 系统安全\n    * 网络的功能和服务\n    * 支持多媒体\n### 5.OS结构设计\n* 传统操作系统结构\n    * 无结构操作系统\n    * 模块化OS\n    * 分层式结构OS\n* 微内核os结构\n    * 客户/服务器模式\n    * 面对对象的程序设计\n## 第二章进程的描述与控制\n### 前驱图和程序执行\n### 程序并发执行\n* 程序的并发执行\n* 程序并发执行时的特征\n    * 间断性\n    * 失去封闭性\n    * 不可再现性\n### 进程的描述\n* 进程的定义\n    * 进程是程序的一次执行\n    * 进程是一个程序及其数据在处理机上顺序执行时所发生的活动\n    * 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位\n* 进程的特征\n    * 动态性\n    * 并发性\n    * 独立性\n    * 异步性\n* 从操作系统角度分类\n    * 系统进程\n    * 用户进程\n* 进程和程序的区别\n    * 进程是动态概念，而程序则是静态概念\n    * 程序是指令的有序集合，永远存在；进程强调是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；\n    * 进程具有并发性，而程序没有\n    * 进程可创建其他进程，而程序并不能形成新的程序\n    * 进程是竞争计算机资源的基本单位，程序不是\n* 进程和程序的联系\n    * 进程是程序在数据集上的一次执行\n    * 程序是构成进程的组成部分，一个程序可对应多个进程，一个进程可包括多个程序\n    * 进程的运行目标是执行所对应的程序\n    * 从静态看，进程由程序、数据和进程控制块（PCB）组成\n* 进程的基本状态及转换\n    * 进程的三种基本状态\n        * 就绪状态ready\n        * 执行状态running\n        * 阻塞状态block\n    * 三种基本状态的转换\n    * 创建状态和终止状态\n        * 五状态进程模型\n    * 注意\n        * 阻塞态->运行态和就绪态->阻塞态这二种状态转换不可能发生\n* 挂起操作和进程状态的转换\n    * 挂起和阻塞的区别\n    * 挂起操作的目的\n        * 终端用户的需要: 修改、检查进程\n        * 父进程的需要：修改、协调子进程\n        * 对换的需要：缓和内存\n        * 负荷调节的需要：保证实时任务的执行\n    * 关键图\n* 进程管理中的数据结构\n    * 进程控制块PCB的作用\n        * 作为独立运行基本单位的标志\n        * 能实现间断性运行方式\n        * 提供进程管理所需要的信息\n        * 提供进程调度所需要的信息\n        * 实现与其他进程的同步与通信\n    * 进程控制块的信息\n        * 进程标识符\n            * 外部标识符PID\n            * 内部标识符(端口)\n        * 处理机状态\n            * 通用寄存器\n            * 指令计数器\n            * 程序状态字PSW\n            * 用户栈指针\n        * 进程调度信息\n            * 进程状态\n            * 进程优先级\n            * 进程调度所需的其他信息\n            * 事件\n        * 进程控制信息\n            * 程序和数据的地址\n            * 进程同步和通信机制\n            * 资源清单\n            * 链接指针\n        * 进程控制块的组织方式\n            * 线性方式\n            * 链接方式\n            * 索引方式\n### 进程控制\n* 操作系统内核\n    * 两大功能\n        * 支撑功能\n            * 中断管理\n            * 时钟管理\n            * 原语操作\n                * 进程的管理，由若干原语（primitive）来执行\n        * 资源管理功能\n            * 进程管理\n            * 存储器管理\n            * 设备管理\n    * 状态\n        * 系统态，管态，内核态\n        * 用户态，目态\n* 进程的创建\n    * 进程的层次结构\n        * 父进程\n        * 子进程\n    * 引起创建进程的事件\n        * 用户登录\n        * 作业调度\n        * 提供服务\n        * 应用请求\n    * 进程的创建过程\n        * 1.申请空白PCB\n        * 2.为新进程分配其运行所需的资源\n        * 3.初始化进程块PCB\n        * 4.如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列\n    * 进程的终止\n        * 引起进程终止的事件\n            * 1.正常结束\n            * 2.异常结束\n            * 3.外界干预\n        * 进程的终止过程\n            * 1.根据被终止进程的标识符\n    * 进程的阻塞与唤醒\n        * 引起进程阻塞和唤醒的事件\n            * 请求系统服务而未满足\n            * 启动某种操作而阻塞当前进程\n            * 新数据尚未到达\n            * 无新工作可做：系统进程\n        * 进程阻塞过程(自己阻塞自己)\n        * 进程唤醒过程(系统或其他进程唤醒自己)\n    * 进程的挂起与激活\n        * suspend\n        * active\n* 进程同步\n    * 基本概念\n        * 两种形式的制约关系\n            * 间接相互制约关系\n                * 互斥——竞争\n            * 直接相互制约关系\n                * 同步——协作\n        * 临界资源\n        * 分区\n            * 进入区enter section\n            * 临界区critical section\n            * 退出区exit section\n            * 剩余区remainder section\n        * 同步机制应遵循的规则\n            * 1.空闲让进\n            * 2.忙则等待\n            * 3.有限等待\n            * 4.让权等待\n    * 进程同步机制\n        * 软件同步机制:都没有解决让权等待，而且部分方法还会产生死锁的情况\n        * 硬件同步机制\n            * 关中断\n            * 利用Test-and-Set指令实现互斥\n            * 利用swap指令实现进程互斥\n        * 信号量机制\n            * 整型信号量\n            * 记录型信号量\n                * 由于整型信号量没有遵循让权等待原则，记录型允许负数，即阻塞链表\n            * AND型信号量\n            * 信号量集\n                * 理解:AND型号量的wait和signal仅能对信号施以加1或减1操作，意味着每次只能对某类临界资源进行一个单位的申请或释放。当一次需要N个单位时，便要进行N次wait操作，这显然是低效的，甚至会增加死锁的概率。此外，在有些情况下，为确保系统的安全性，当所申请的资源数量低于某一下限值时，还必须进行管制，不予以分配。因此，当进程申请某类临界资源时，在每次分配前，都必须测试资源数量，判断是否大于可分配的下限值，决定是否予以分配\n                * 操作\n                    * Swait(S1，t1，d1…Sn，tn，dn)\n                    * Ssignal(S1，d1…Sn，dn)\n                * 特殊情况\n    * 经典进程的同步问题\n        * 生产者–消费者问题\n        * 哲学家进餐问题\n        * 读者–写者问题\n### 进程通信\n* 进程通信是指进程之间的信息交换，又称低级进程通信\n* 进程通信的类型\n    * 共享存储器系统\n        * 基于共享数据结构的通信方式\n            * 生产者和消费者\n        * 基于共享存储区的通信方式\n            * 高级通信\n    * 管道通信系统(pipe)\n        * 高级通信\n    * 消息传递系统\n        * 高级通信\n        * 方式分类\n            * 直接通信\n            * 间接通信\n    * 客服机–服务器系统\n* 消息传递通信的实现方式\n    * 直接消息传递系统\n    * 信箱通信\n### 线程的基本概念\n* 线程的引入\n    * 线程的引入正是为了简化线程间的通信，以小的开销来提高进程内的并发程度\n    * 多线程并发的不足\n        * 进程的两个基本属性\n            * 一个拥有资源的独立单位，可独立分配系统资源\n            * 一个可独立调度和分派的基本单位，PCB\n        * 程序并发执行所需付出的时空开销\n            * 创建进程\n            * 撤销进程\n            * 进程切换\n        * 进程间通信效率低\n        * 将分配资源和调度两个属性分开\n    * 线程——作为调度和分派的基本单位\n        * 进程是系统资源分配的单位，线程是处理器调度的单位\n        * 线程表示进程的一个控制点，可以执行一系列的指令。通常，和应用程序的一个函数相对应\n        * 进程分解为线程还可以有效利用多处理器和多核计算机\n* 线程与进程的比较\n    * 不同点\n        * 调度的基本单位\n        * 并发性\n    * 相似点\n        * 状态：运行、阻塞、就绪\n        * 线程具有一定的生命期\n        * 进程可创建线程，一个线程可创建另一个子线程\n        * 多个线程并发执行时仍然存在互斥与同步\n* 线程的实现\n    * 线程的实现方式\n        * 内核支持线程KST\n        * 用户级线程ULT\n        * 组合方式\n    * 多线程OS中的进程属性\n        * 进程是一个可拥有资源的基本单位\n        * 多个线程可并发执行\n        * 进程已不是可执行的实体\n    * 线程的状态和线程控制块\n        * 线程运行的三个状态\n            * 执行状态\n            * 就绪状态\n            * 阻塞状态\n        * 线程控制块TCB\n## 第三章:处理机调度与死锁\n### 处理机调度算法的目标\n* 处理机调度算法的共同目标\n    * 资源利用率:CPU的利用率=CPU有效工作时间/(CPU有效工作时间+CPU空闲等待时间)\n    * 公平性\n    * 平衡性\n    * 策略强制执行\n* 批处理系统的目标\n    * 平均周转时间短\n    * 系统吞吐量高\n    * 处理机利用率高\n* 分时系统的目标\n    * 响应时间快\n    * 均衡性\n* 实时系统目标\n    * 截止时间的保证\n    * 可预测性\n* 处理机调度的层次\n    * 高级调度（作业调度）\n        * 分时系统无需作业调度，因为需要交互\n        * 批处理系统需要作业调度\n    * 中级调度（和挂起有关）\n    * 低级调度（进程调度）\n        * 进程调度是最基本的调度，任何操作系统都有进程调度。\n        * 低级调度的三个基本机制\n            * 排队器\n            * 分派器\n            * 上下文切换\n        * 进程调度方式\n            * 非抢占方式\n            * 抢占方式\n                * 优先权原则\n                * 短进程优先原则\n                * 时间片原则\n        * 进程调度的任务\n            * 保存处理机的现场信息\n            * 按某种算法选取进程\n            * 把处理器分配给进程\n        * 进程调度的算法\n            * 优先级调度算法\n                * 优先级调度算法的类型\n                    * 非抢占式优先级调度算法\n                        * 等当前进程执行完以后，再执行另一个优先权最高的进程\n                        * 这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。 \n                    * 抢占式优先级调度算法\n                        * 不等当前进程结束，直接抢处理机\n                        * 常用于要求比较严格的实时系统中， 以及对性能要求较高的批处理和分时系统中。\n                * 优先级的类型\n                    * 静态优先级\n                        * 优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，例如，0~7或0~255中的某一整数， 又把该整数称为优先数。\n                        * 可以参考BIOS系统中设置boot的优先级\n                    * 动态优先级\n                        * 在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。\n            * 轮转调度算法\n                * 基本原理:在轮转(RR)法中，系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并可设置每隔一定时间间隔(如30ms)即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其执行\n                * 进程切换时机\n                    * 时间片未用完，进程完成\n                    * 时间片到，进程未完成\n                * 时间片大小的确定\n                    * 太小利于短作业，增加系统切换开销\n                    * 太长就退化为FCFS算法\n                    * 一般选择: q略大于一次交互所需要的时间，使大多数进程在一个时间片内完成\n                * 一般来说，平均周转时间将比SJF长，但是有较好的响应时间\n            * 多队列调度算法\n            * 多级反馈队列调度算法\n                * 调度机制\n                    * 设置多个就绪队列\n                    * 每个队列都采用FCFS算法\n                    * 按照队列优先级调度，在第n队列中采取按时间片轮转的方式运行\n                * 调度算法的性能\n                    * 对于终端型用户，由于作业小，感觉满意\n                    * 对于短批处理作业用户，周转时间也较小\n                    * 长批处理作业用户，也能够得到执行\n            * 基于公平原则的调度算法\n                * 保证调度算法\n                * 公平分享调度算法\n### 作业与作业调度\n* 作业\n    * 作业不仅包含程序和数据，还配有一份作业说明书，系统根据说明书对程序的运行进行控制。批处理系统是以作业为单位从外存掉入内存的。\n* 作业控制块JCB\n    * 为每个作业设置一个JCB，保存了对作业管理调度的全部信息。是作业存在的标志。\n* 作业步\n    * 作业步，每个作业都必须经过若干相对独立，有相互关联的顺序步骤才能得到结果。每一个步骤就是一个作业步。\n* 作业运行的三个阶段\n    * 收容阶段\n    * 运行阶段\n    * 完成阶段\n* 作业运行的三个状态\n    * 后备状态\n    * 运行状态\n    * 完成状态\n* 作业调度的主要任务\n    * 接纳多少个作业\n    * 接纳哪些作业\n* 先来先服务(first–come first–served，FCFS)调度算法\n    * 比较有利于长作业，而不利于短作业。\n    * 有利于CPU繁忙的作业，而不利于I/O繁忙的作业。\n* 短作业优先(short job first，SJF)的调度算法\n    * 优点\n        * 比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；\n        * 提高系统的吞吐量；\n    * 缺点\n        * 必须预知作业的运行时间\n        * 对长作业非常不利，长作业的周转时间会明显地增长\n        * 在采用SJF算法时，人–机无法实现交互\n        * 该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理\n* 优先级调度算法(priority–scheduling algorithm，PSA)\n* 高响应比优先调度算法(Highest Response Ratio Next,HRRN)\n    * 原理\n        * 在每次选择作业投入运行时，先计算此时后备作业队列中每个作业的响应比RP然后选择其值最大的作业投入运行\n        * 优先权=(等待时间+要求服务时间)/要求服务时间=响应时间/要求服务时间=1+等待时间/要求服务时间\n    * 特点\n        * 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而类似于SJF算法，有利于短作业\n        * 当要求服务的时间相同时，作业的优先权又决定于其等待时间，因而该算法又类似于FCFS算法\n        * 对于长时间的优先级，可以为随等待时间的增加而提高，当等待时间足够长时，也可获得处理机\n### 实时调度(HRT和SRT任务)\n* 实现实时调度的基本条件\n    * 提供必要信息\n        * 就绪时间\n        * 开始截止时间和完成截止时间\n        * 处理时间\n        * 资源要求\n        * 优先级\n    * 系统处理能力强\n        * ∑(Ci/Pi)≤1\n        * N个处理机:∑(Ci/Pi)≤N\n    * 采用抢占式调度机制\n    * 具有快速切换机制\n        * 对中断的快速响应能力\n        * 快速的任务分派能力\n* 实时调度算法的分类\n    * 非抢占式调度算法\n        * 非抢占式轮转调度算法\n        * 非抢占式优先调度算法\n    * 抢占式调度算法\n        * 基于时钟中断的抢占式优先级调度算法\n        * 立即抢占的优先级调度算法\n* 最早截止时间优先EDF(Earliest Deadline First)算法\n    * 根据任务的开始截至时间来确定任务的优先级\n        * 截至时间越早，优先级越高\n    * 非抢占式调度方式用于非周期实时任务\n    * 抢占式调度方式用于周期实时任务\n* 最低松弛度优先LLF(Least Laxity First)算法\n    * 类似EDF\n    * 算法根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高， 以使之优先执行。\n    * 松弛度例子\n        * 例如，一个任务在200ms时必须完成，而它本身所需的运行时间就有100ms，因此，调度程序必须在100 ms之前调度执行，该任务的紧急程度(松弛程度)为100 ms\n* 优先级倒置(Priority inversion problem)\n    * 优先级倒置的形成\n        * 高优先级进程被低优先级进程延迟或阻塞。\n    * 优先级倒置的解决方法\n        * 简单的:假如进程P3在进入临界区后P3所占用的处理机就不允许被抢占\n        * 实用的:建立在动态优先级继承基础上的\n### 死锁概述\n* 资源问题\n    * 可重用性资源\n        * 计算机外设\n    * 消耗性资源\n        * 数据，消息\n    * 可抢占性资源\n        *  不引起死锁\n        * CPU，内存 \n    * 不可抢占性资源\n        * 光驱，打印机\n* 计算机系统中的死锁\n    * 竞争不可抢占性资源引起死锁\n    * 竞争可消耗资源引起死锁\n    * 进程推进顺序不当引起死锁\n* 死锁的定义，必要条件和处理方法\n    * 定义:如果一组进程中的每一个进程都在等待仅由该进程中的其他进程才能引发的事件，那么该组进程是死锁的\n    * 产生死锁的必要条件\n        * 互斥条件\n        * 请求和保存条件\n        * 不可抢占条件\n        * 循环等待条件\n            * 如果每个资源只有一个实例，则环路等待条件是死锁存在的充分必要条件\n    * 处理死锁的方法\n        * 预防死锁\n            * 静态方法，在进程执行前采取的措施，通过设置某些限制条件，去破坏产生死锁的四个条件之一，防止发生死锁。\n            * 预防死锁的策略\n                * 破坏\"请求和保存\"条件\n                    * 第一种协议\n                        * 所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源\n                        * 优点:简单，易行，安全\n                        * 缺点\n                            * 资源被严重浪费，严重地恶化了资源的利用率\n                            * 使进程经常会发生饥饿现象\n                    * 第二种协议\n                        * 它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的，且已用毕的全部资源，然后再请求新的所需资源\n                * 破坏\"不可抢占\"条件\n                    * 当一个已经保存了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请\n                * 破坏\"循环等待\"条件\n                    * 对系统所以资源类型进行线性排序，并赋予不同的序号\n                    * 例如令输入机的序号为1，打印机序号为2，磁盘机序号为3等。所有进程对资源的请求必须严格按资源序号递增的次序提出。\n        * 避免死锁\n            * 动态的方法，在进程执行过程中采取的措施，不需事先采取限制措施破坏产生死锁的必要条件，而是在进程申请资源时用某种方法去防止系统进入不安全状态，从而避免发生死锁。如银行家算法\n            * 避免死锁的策略\n                * 系统安全状态\n                    * 安全状态\n                        * 某时刻，对于并发执行的n个进程，若系统能够按照某种顺序如<p1,p2…pn>来为每个进程分配所需资源，直至最大需求，从而使每个进程都可顺利完成，则认为该时刻系统处于安全状态，这样的序列为安全序列\n                    * 安全状态之例\n                    * 由安全状态向不安全状态的转换\n                * 利用银行家算法避免死锁\n                    * 含义:每一个新进程在进入系统时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给它，否则让进程等待\n                    * 银行家算法中的数据结构\n                        * 可用资源向量 Available[m]：m为系统中资源种类数，Available[j]=k表示系统中第j类资源数为k个。\n                        * 最大需求矩阵 Max[n,m]：n为系统中进程数，Max[i,j]=k表示进程i对j类资源的最大需求数为中k。\n                        * 分配矩阵 Allocation[n，m]:它定义了系统中每一类资源当前已分配给每一进程资源数，   Allocation[i,j] = k表示进程i已分得j类资源的数目为k个。\n                        * 需求矩阵 Need[n,m]：它表示每个进程尚需的各类资源数，Need[i,j]=k 表示进程i   还需要j类资源k个。Need[i,j]=Max[i,j] - Allocation[i,j]\n                    * 银行家算法\n                    * 安全性算法\n                    * 银行家算法之例\n                    * 解题\n                        * 矩阵\n                        * 列表\n        * 检测死锁\n            * 死锁的检测与解除\n                * 死锁的检测\n                    * 资源分配图\n                        * 简化步骤\n                            * 选择一个没有阻塞的进程p\n                            * 将p移走，包括它的所有请求边和分配边\n                            * 重复步骤1，2，直至不能继续下去\n                    * 死锁定理\n                        * 若一系列简化以后不能使所有的进程节点都成为孤立节点\n                    * 检测时机\n                        *  当进程等待时检测死锁 （其缺点是系统的开销大）\n                        *  定时检测\n                        *  系统资源利用率下降时检测死锁\n                    * 死锁检测中的数据结构\n                * 死锁的解除\n                    * 抢占资源\n                    * 终止(或撤销)进程\n                    * 终止进程的方法\n                        * 终止所有死锁进程\n                        * 逐个终止进程\n                            * 代价最小\n                                * 进程的优先级的大小\n                                * 进程已执行了多少时间，还需时间\n                                * 进程在运行中已经使用资源的多少，还需多少资源\n                                * 进程的性质是交互式还是批处理的\n                    * 付出代价最小的死锁解除算法\n                        * 是使用一个有效的挂起和解除机构来挂起一些死锁的进程\n        * 解除死锁\n## 第四章:存储器管理\n### 存储器的层次结构\n* 多层结构的存储系统\n    * 存储器的多层结构\n        * CPU寄存器\n        * 主存\n        * 辅存\n    * 可执行存储器\n        * 寄存器和主存的总称\n        * 访问速度快，进程可以在很少的时钟周期内用一条load或store指令完成存取。\n* 主存储器与寄存器\n* 高速缓存和磁盘缓存\n### 程序的装入和链接\n* 步骤\n    * 编译\n        * 源程序 ->目标模块（Object modules）--------Compiler\n            * 由编译程序对用户源程序进行编译，形成若干个目标模块\n    * 链接\n        * 一组目标模块 ->装入模块 （Load Module）----------Linker\n            * 由链接程序将编译后形成的一组目标模板以及它们所需要的库函数链接在一起，形成一个完整的装入模块\n    * 装入\n        * 装入模块 ->内存  --------Loader\n            * 由装入程序将装入模块装入内存\n* 程序的装入\n    * 绝对装入方式\n        * 在编译时，如果知道程序将驻留在内存中指定的位置。编译程序将产生绝对地址的目标代码。\n    * 可重定位装入方式\n        * 在可执行文件中，列出各个需要重定位的地址单元和相对地址值。当用户程序被装入内存时，一次性实现逻辑地址到物理地址的转换，以后不再转换(一般在装入内存时由软件完成)。\n        * 优点：不需硬件支持，可以装入有限多道程序。\n        * 缺点：一个程序通常需要占用连续的内存空间，程序装入内存后不能移动。不易实现共享。\n    * 动态运行时的装入方式\n        * 动态运行时的装入程序在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换为物理地址，而是把这种地址转换推迟到程序真正要执行时才进行\n        * 优点：\n            * OS可以将一个程序分散存放于不连续的内存空间，可以移动程序，有利用实现共享。\n            * 能够支持程序执行中产生的地址引用，如指针变量（而不仅是生成可执行文件时的地址引用）。\n        * 缺点：需要硬件支持，OS实现较复杂。\n        * 它是虚拟存储的基础。\n* 程序的链接\n    * 静态链接方式(lib)\n    * 装入时动态链接\n    * 运行时动态链接(dll)\n### 连续分配存储管理方式\n* 连续分配\n    * 单一连续分配(DOS)\n    * 固定分区分配(浪费很多空间)\n    * 动态分区分配\n* 地址映射和存储保护措施\n    * 基址寄存器：程序的最小物理地址\n    * 界限寄存器：程序的逻辑地址范围\n    * 物理地址 = 逻辑地址 + 基址\n* 内碎片：占用分区之内未被利用的空间\n* 外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）\n* 把内存划分为若干个固定大小的连续分区。固定式分区又称为静态分区。\n    * 分区大小相等：只适合于多个相同程序的并发执行（处理多个类型相同的对象）。\n    * 分区大小不等：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。\n    * 优点：无外碎片、易实现、开销小。\n    * 缺点：\n        * 存在内碎片，造成浪费\n        * 分区总数固定，限制了并发执行的程序数目。\n        * 通用Os很少采用，部分控制系统中采用\n* 动态创建分区：指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。可变式分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。\n    * 基于顺序搜索的动态分区分配算法\n        * 首次适应算法（first fit,FF）\n            * 顺序找，找到一个满足的就分配，但是可能存在浪费\n            * 这种方法目的在于减少查找时间。\n            * 空闲分区表（空闲区链）中的空闲分区要按地址由低到高进行排序\n        * 循环首次适应算法（next fit，NF）\n            * 相对上面那种，不是顺序，类似哈希算法中左右交叉排序\n            * 空闲分区分布得更均匀，查找开销小\n            * 从上次找到的空闲区的下一个空闲区开始查找，直到找到第一个能满足要求的的空闲区为止，并从中划出一块与请求大小相等的内存空间分配给作业。\n        * 最佳适应算法（best fit，BF）\n            * 找到最合适的，但是大区域的访问次数减少\n            * 这种方法能使外碎片尽量小。\n            * 空闲分区表（空闲区链）中的空闲分区要按大小从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。\n        * 最坏适应算法（worst fit，WF）\n            * 相对于最好而言，找最大的区域下手，导致最大的区域可能很少，也造成许多碎片\n            * 空闲分区按大小由大到小排序\n    * 基于索引搜索的动态分区分配算法\n        * 快速适应算法（quick fit）\n        * 伙伴系统（buddy system）\n        * 哈希算法\n    * 动态可重定位分区分配\n        * 紧凑\n        * 动态重定位\n            * 动态运行时装入，地址转化在指令执行时进行，需获得硬件地址变换机制的支持\n            * 内存地址=相对地址+起始地址\n        * 动态重定位分区分配算法\n            * 1、在某个分区被释放后立即进行紧凑，系统总是只有一个连续的分区而无碎片，此法很花费机时。\n            * 2、当“请求分配模块”找不到足够大的自由分区分给用户时再进行紧凑，这样紧缩的次数比上种方法少得多，但管理复杂。采用此法的动态重定位分区分配算法框图如下：\n    * 优点：没有内碎片。\n    * 缺点：外碎片。\n### 对换（了解）\n* 系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。\n### 基本分页存储管理方式\n* 分页存储管理的基本方式\n    * 页面\n        * 将一个进程的逻辑地址空间分成若干个大小相等的片\n    * 页框（frame）\n        * 内存空间分成与页面相同大小的存储块\n    * 由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”\n    * 地址结构\n        * 页号P+位移量W(0-31)\n    * 页表\n        * 在分页系统中，允许将进程的各个页离散地存储在内存在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每一个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表\n        * 页表的作用是实现从页面号到物理块号的地址映射\n* 地址变换机构\n    * 基本的地址变换机构\n        * 要访问两次内存\n        * 页表大都驻留在内存中\n        * 为了实现地址变换功能，在系统中设置页表寄存器（PTR），用来存放页表的始址和页表的长度。\n        * 在进程未执行时，每个进程对应的页表的始址和长度存放在进程的PCB中，当该进程被调度时，就将它们装入页表寄存器。\n    * 具有快表的地址变换机构\n        * 提高了效率，此处会有计算题\n        * 如果页表存放在内存中，则每次访问内存时，都要先访问内存中的页表，然后根据所形成的物理地址再访问内存。这样CPU存一个数据必须访问两次内存，从而使计算机的处理速度降低了1/2。\n        * 为了提高地址变换的速度，在地址变换机构中增设了一个具有并行查询功能的特殊的高速缓冲存储器，称为“联想存储器”或“快表”，用以存放当前访问的那些页表项。\n        * 地址变换过程为：\n            * 1、CPU给出有效地址\n            * 2、地址变换机构自动地将页号送入高速缓存，确定所需要的页是否在快表中。\n            * 3、若是，则直接读出该页所对应的物理块号，送入物理地址寄存器；\n            * 4、若快表中未找到对应的页表项，则需再访问内存中的页表\n            * 5、找到后，把从页表中读出的页表项存入快表中的一个寄存器单元中，以取代一个旧的页表项。\n* 两级和多级页表\n    * 主要是有的时候页表太多了，要化简\n    * 格式：外层页号P1+外层页内地址P2+页内地址d\n    * 基本方法：将页表进行分页，每个页面的大小与内存物理块的大小相同，并为它们进行编号，可以离散地将各个页面分别存放在不同的物理块中。\n* 反置页表\n    * 反置页表为每一个物理块（页框）设置一个页表项，并按物理块排序，其内容则是页号和其所属进程的标识。\n* 优点：\n    * 没有外碎片，每个内碎片不超过页大小。\n    * 一个程序不必连续存放。\n    * 便于改变程序占用空间的大小。即随着程序运行而动态生成的数据增多，地址空间可相应增长。\n* 缺点：程序全部装入内存。\n### 分段存储管理方式\n* 引入\n    * 方便编程\n    * 信息共享\n    * 动态增长\n    * 动态链接\n* 在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。\n* 内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定\n* 分段系统的基本原理\n    * 分段\n        * 格式：段号+段内地址\n    * 段表\n        * 段表实现了从逻辑段到物理内存区的映射。\n    * 地址变换机构\n* 和分页的区别\n    * 页是信息的物理单位\n    * 页的大小固定且由系统固定\n    * 分页的用户程序地址空间是一维的\n    * 通常段比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。\n    * 分页是系统管理的需要，分段是用户应用的需要。一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。\n* 信息共享\n    * 这是分段最重要的优点\n* 段页式存储管理方式\n    * 基本原理\n        * 格式：段号（S）+段内页号（P）+页内地址（W）\n    * 地址变换过程\n        * 需要三次访问过程\n    * 在段页式系统中，为了获得一条指令或数据，需三次访问内存：第一次访问内存中的段表，从中取得页表始址；第二次访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正根据所得的物理地址取出指令或数据。\n## 第五章：虚拟存储器\n### 常规存储管理方式的特征\n* 一次性\n* 驻留性\n### 局部性原理\n* 程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域\n* 时间局限性\n    * 如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环操作\n* 空间局限性\n    * 一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。\n### 定义\n* 指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统\n### 优点\n* 大程序：可在较小的可用内存中执行较大的用户程序；\n* 大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存(real memory)\n* 并发：可在内存中容纳更多程序并发执行；\n* 易于开发：不必影响编程时的程序结构\n* 以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术\n### 特征\n* 离散性\n    * 指在内存分配时采用离散的分配方式，它是虚拟存储器的实现的基础\n* 多次性\n    * 指一个作业被分成多次调入内存运行，即在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可。多次性是虚拟存储器最重要的特征\n* 对换性\n    * 指允许在作业的运行过程中在内存和外存的对换区之间换进、换出。\n* 虚拟性\n    * 指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。\n### 虚拟存储器的实现方式\n* 请求分页存储管理方式\n    * 硬件\n        * 请求页表机制\n            * 格式：页号+物理块号+状态位P+访问字段A+修改位M+外存地址\n        * 缺页中断机构\n        * 地址变换机构（过程图很关键）\n    * 请求分页中的内存分配\n        * 最小物理块数\n            * 即能保证进程正常运行所需的最小物理块数\n        * 内存分配策略\n            * 固定分配局部置换（国王的大儿子）\n            * 可变分配全局置换（国王的二儿子）\n            * 可变分配局部置换（国王的小儿子）\n    * 物理块分配算法\n        * 平均分配算法\n        * 按比例分配算法\n        * 考虑优先权的分配算法\n    * 页面调入策略\n        * 系统应在何时调入所需页面\n            * 预调页策略（不能实现）\n            * 请求调页策略（需要才给）\n        * 系统应该从何处调入这些页面\n            * 对换区\n            * 文件区\n        * 页面调入过程\n        * 缺页率（出计算题）\n* 请求分段系统\n    * 硬件\n        * 请求分段的段表机构\n        * 缺段中断机构\n        * 地址变换机构\n### 页面置换算法\n* 抖动的概念\n    * 即刚被换出的页很快又要被访问，需要将它重新调入，此时又需要再选一页调出\n* 最佳置换算法(需要预知后面进程，所以不能实现)\n* 先进先出页面置换算法（FIFO）\n    * 选择在内存中驻留时间最久的页面予以淘汰\n* 最近最久未使用置换算法（LRU）Recently\n    * 寄存器支持\n    * 特殊的栈结构\n* 最少使用置换算法（LFU）Frequently\n* clock置换算法（对访问位A的判断）\n    * 改进型——增加对修改位M思维判断\n* 页面缓冲算法（PBA,page buffering algorithm）\n    * 空闲页面链表\n    * 修改页面链表\n## 第六章：输入输出系统\n### I/O系统的功能，模型和接口\n* I/O系统管理的对象是I/O设备和相应的设备控制器。\n* I/O系统的基本功能\n    * 隐藏物理设备的细节\n    * 与设备的无关性\n    * 提高处理机和I/O设备的利用率\n    * 对I/O设备进行控制\n    * 确保对设备的正确共享\n    * 错误处理\n* I/O软件的层次结构\n    * 用户层I/O软件\n    * 设备独立性软件\n    * 设备驱动程序（厂家开发）\n    * 中断处理程序\n    * 硬件\n* I/O系统的分层\n    * 中断处理程序\n    * 设备驱动程序\n    * 设备独立性软件\n* I/O系统接口\n    * 块设备接口\n        * 指以数据块为单位来组织和传送数据信息的设备\n        * 典型的块设备是磁盘、光盘\n        * 块设备的基本特征\n            * ①传输速率较高，通常每秒钟为几兆位；\n            * ②它是可寻址的，即可随机地读/写任意一块；\n            * ③磁盘设备的I/O采用DMA方式。\n    * 流设备接口\n        * 又称字符设备指以单个字符为单位来传送数据信息的设备\n        * 这类设备一般用于数据的输入和输出，有交互式终端、打印机\n        * 字符设备的基本特征\n            * ①传输速率较低；\n            * ②不可寻址，即不能指定输入时的源地址或输出时的目标地址；\n            * ③字符设备的I/O常采用中断驱动方式。\n    * 网络通信接口\n        * 提供网络接入功能，使计算机能通过网络与其他计算机进行通信或上网浏览。\n### I/O设备和设备控制器\n* 分类\n    * 使用特性分\n        * 存储设备\n        * I/O设备\n    * 传输速率分\n        * 低速设备（几字节——几百字节）\n            * 典型的设备有键盘、鼠标、语音的输入\n        * 中速设备（数千——数万字节）\n            * 典型的设备有行式打印机、激光打印机\n        * 高速设备（数十万——千兆字节）\n            * 典型的设备有磁带机、磁盘机、光盘机\n* 设备并不是直接与CPU进行通信，而是与设备控制器通信。在设备与设备控制器之间应该有一个接口。\n    * 数据信号：控制器 ←  设备 ←  控制器\n        * 传送数据信号，输入、输出bit\n    * 控制信号: 控制器  →  设备\n        * 执行读、写操作的信号\n    * 状态信号：设备当前使用状态\n* 设备控制器\n    * 主要功能：控制一个或多个I/O设备，以实现I/O设备和计算机之间的数据交换\n    * 基本功能\n        * 接收和识别命令\n            * 控制寄存器、命令译码器\n        * 数据交换\n            * 实现CPU与控制器，控制器与设备间的数据交换\n        * 标识和报告设备的状态\n        * 地址识别\n            * 配置地址译码器，识别不同的设备\n        * 数据缓冲区\n        * 差错控制\n    * 设备控制器的组成\n        * 设备控制器与处理机（CPU）的接口\n            * 实现CPU与设备控制器之间的通信\n        * 设备控制器与设备的接口\n            * 控制器可连接多个设备\n        * I/O逻辑\n            * 实现对设备的控制\n            * CPU利用该逻辑向控制器发送I/O命令\n            * 命令、地址译码\n* 内存映像I/O\n    * 驱动程序将抽象I/O命令转换出的一系列具体的命令，参数等数据装入设备控制器的相应寄存器，由控制器来执行这些命令，具体实施对I/O设备的操作\n* I/O通道\n    * 目的：建立独立的I/O操作(组织, 管理和结束)，使由CPU处理的I/O工作转由通道完成（解放CPU，实现并行）\n\n    * 什么是I/O通道？\n        *  是一种特殊的处理机，具有通过执行通道程序完成I/O操作的指令\n        *  特点：指令单一(局限于与I/O操作相关的指令)，与CPU共享内存\n    * 基本过程：\n        * CPU向通道发出I/O指令->通道接收指令->从内存取出通道程序处理I/O->向CPU发出中断\n    * 通道类型\n        * 字节多路通道\n            * 低中速连接子通道时间片轮转方式共享主通道\n            * 字节多路通道不适于连接高速设备，这推动了按数组方式进行数据传送的数组选择通道的形成。\n        * 数组选择通道\n            * 这种通道可以连接多台高速设备，但只含有一个分配型子通道，在一段时间内只能执行一道通道程序， 控制一台设备进行数据传送， 直至该设备传送完毕释放该通道。这种通道的利用率很低。\n        * 数组多路通道\n            * 含有多个非分配型子通道，前两种通道的组合，通道利用率较好\n    * 瓶颈问题\n        * 原因;通道不足\n        * 解决办法：增加设备到主机间的通路，而不增加通道（结果类似RS触发器）\n### 中断机构和中断处理程序\n* 中断\n    * 分类\n        * 中断（外部触发）\n            * 对外部I/O设备发出的中断信号的响应\n        * 陷入（内部原因：除0）\n            * 由CPU内部事件引起的中断\n    * 中断向量表（类比51单片机）\n        * 中断程序的入口地址表\n    * 中断优先级\n        * 对紧急程度不同的中断处理方式\n    * 对多中断源的处理方式\n        * 屏蔽中断\n        * 嵌套中断\n* 中断处理程序\n    * 测定是否有未响应的中断信号\n    * 保护被中断进程的CPU环境\n    * 转入相应的设备处理程序\n    * 中断处理\n    * 恢复CPU 的现场并退出中断\n### 设备驱动程序\n* 是I/O进程与设备控制器之间的通信程序，又由于它常以进程的形式存在，故以后就简称为设备驱动进程\n* 主要任务是接受来自它上一层的与设备无关软件的抽象请求，并执行这个请求。\n* 功能\n    * 1) 接收由I/O进程发来的命令和参数， 并将命令中的抽象要求转换为具体要求。例如，将磁盘块号转换为磁盘的盘面、 磁道号及扇区号。\n    * 2) 检查用户I/O请求的合法性，了解I/O设备的状态，传递有关参数，设置设备的工作方式。 \n    * 3) 发出I/O命令，如果设备空闲，便立即启动I/O设备去完成指定的I/O操作；如果设备处于忙碌状态，则将请求者的请求块挂在设备队列上等待。\n    * 4) 及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。\n    * 5) 对于设置有通道的计算机系统，驱动程序还应能够根据用户的I/O请求，自动地构成通道程序。 \n* 设备驱动程序的处理过程\n    * 将用户和上层软件对设备控制的抽象要求转换成对设备的具体要求，如对抽象要求的盘块号转换为磁盘的盘面、磁道及扇区。\n    * 检查I/O请求的合理性。\n    * 读出和检查设备的状态，确保设备处于就绪态。\n    * 传送必要的参数，如传送的字节数，数据在主存的首址等。\n    * 工作方式的设置。\n    * 启动I/O设备，并检查启动是否成功，如成功则将控制返回给I/O控制系统，在I/O设备忙于传送数据时，该用户进程把自己阻塞，直至中断到来才将它唤醒，而CPU可干别的事。\n* 对I/O设备的控制方式\n    * I/O控制的宗旨\n        * 减少CPU对I/O控制的干预\n        * 充分利用CPU完成数据处理工作\n    * I/O 控制方式\n        * 轮询的可编程I/O方式\n        * 中断驱动I/O方式\n        * DMA控制方式\n        * I/O通道控制方式\n* DMA控制器组成\n    * 主机与DMA控制器的接口\n    * DMA控制器与块设备的接口\n    * I/O控制逻辑\n### 与设备无关的I/O软件\n* 基本概念\n    * 含义： 应用程序独立于具体使用的物理设备。\n    * 驱动程序是一个与硬件(或设备)紧密相关的软件。为实现设备独立性，须在驱动程序上设置一层软件，称为设备独立性软件。\n    * 设备独立性(Device Independence)的优点\n        * 以物理设备名使用设备\n        * 引入了逻辑设备名\n        * 逻辑设备名称到物理设备名称的转换（易于实现I/O重定向）\n* 与设备无关的软件\n    * 设备驱动程序的统一接口\n    * 缓存管理\n    * 差错控制\n    * 对独立设备的分配与回收\n    * 独立于设备的逻辑数据块\n* 设备分配中的数据结构\n    * 设备控制表DCT\n    * 控制器控制表COCT\n    * 通道控制表CHCT\n    * 显然，在有通道的系统中，一个进程只有获得了通道，控制器和所需设备三者之后，才具备了进行I/O操作的物理条件\n    * 系统设备表SDT\n    * 逻辑设备表LUT\n    * 分配的流程，从资源多的到资源紧张的:LUT->SDT->DCT->COCT->CHCT\n    * 在申请设备的过程中，根据用户请求的I/O设备的逻辑名，查找逻辑设备和物理设备的映射表；以物理设备为索引，查找SDT，找到该设备所连接的DCT；继续查找与该设备连接的COCT和CHCT，就找到了一条通路。\n### 用户层的I/O软件\n* 系统调用与库函数\n    * OS向用户提供的所有功能，用户进程都必须通过系统调用来获取\n    * 在C语言以及UNIX系统中，系统调用（如read）与各系统调用所使用的库函数（如read）之间几乎是一一对应的。而微软的叫Win32API\n* 假脱机系统（spooling）\n    * spooling技术是对脱机输入/输出系统的模拟\n    * 主要组成\n        * 输入/输出井\n        * 输入/输出缓冲区\n        * 输入/输出进程\n        * 井管理程序\n    * 特点（体现操作系统的虚拟性）\n        * 提高了I/O的速度\n            * 对数据所进行的I/O操作，已从对低速设备演变为对输入井或输出井中的数据存取。\n        * 将独占设备改造为共享设备\n            * 实际分给用户进程的不是打印设备，而是共享输出井中的存储区域 \n        * 实现了虚拟设备功能\n            * 将独占设备变成多台独占的虚拟设备。\n### 缓冲区管理\n* 缓冲的引入（原因）\n    * 缓和CPU与I/O设备间速度不匹配的矛盾\n    * 减少对CPU的中断频率，放宽对CPU中断响应时间的限制\n    * 提高CPU和I/O设备之间的并行性\n    * 解决数据粒度不匹配的问题\n* 单缓冲区\n    * 即在CPU计算的时候，将数据数据输入到缓冲区(大小取决与T和C的大小)\n* 双缓冲区\n    * 即允许CPU连续工作（T不断）\n* 环形缓冲区（专为生产者和消费者打造）\n    * 组成\n        * 多个缓冲区\n        * 多个指针\n    * 使用\n        * Getbuf过程\n        * Releasebuf过程\n    * 同步问题\n* 缓冲池(理解为更大的缓冲区)\n    * 组成\n        * 空白缓冲队列（emq）\n            * 由空缓冲区链接而成F(emq)，L(emq)分别指向该队列首尾缓冲区\n        * 输入队列（inq）\n            * 由装满输入数据的缓冲区链接而成F(inq)，L(inq)分别指向该队列首尾缓冲区\n        * 输出队列（outq）\n            * 由装满输出数据的缓冲区链接而成F(outq)， L(outq)分别指向该队列首尾缓冲\n    * Getbuf和Putbuf过程\n        * 收容：缓冲池接收外界数据\n        * 提取：外界从缓冲池获得数据\n    * 缓冲区工作方式（从缓冲区的角度来看）\n        * 收容输入\n        * 提取输入\n        * 收容输出\n        * 提取输出\n### 磁盘存储器的性能和调度\n* 数据的组织和格式\n* 磁盘的类型\n    * 固定头磁盘（贵）\n    * 移动头磁盘\n* 磁盘访问的时间（关键）\n    * 寻道时间Ts=m*n+s\n    * 旋转延迟时间Tr\n    * 传输时间Tt=b/rN\n    * 总时间Ta=Ts+1/2r+b/rN\n* 磁盘的调度算法（掌握图表）\n    * 先来先服务（FCFS）\n        * 优点：公平，简单\n        * 缺点：可能导致某些进程的请求长期得不到满足\n    * 最短寻道时间优先（SSTF）\n        * 说明：要求访问的磁道和当前磁头所在的磁道距离最近，以使每次的寻道时间最短\n    * 扫描算法（SCAN）\n        * 扫描算法不仅考虑到欲访问的磁道与当前磁道间的距离，更优先考虑的是磁道当前的移动方向\n        * 联想电梯的运行\n        * 可防止低优先级进程出现“饥饿”的现象\n    * 循环扫描算法（CSCAN）\n        * 算法规定磁头单向移动，例如，只是自里向外移动，当磁头移到最外的磁道并访问后，磁头立即返回到最里的欲访问磁道，亦即将最小磁道号紧接着最大磁道号构成循环，进行循环扫描\n    * NStepScan算法\n        * N步SCAN算法是将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次这些子队列。\n    * FSCAN算法\n        * 是Nstepscan算法的简化，将磁盘请求队列分成两个子队列\n## 第七章：文件管理\n### 数据项\n* 基本数据项\n* 组合数据项\n### 记录\n* 记录是一组相关数据项的集合，用于描述一个对象在某个方面的属性\n### 文件\n* 文件类型\n* 文件长度\n* 文件的物理位置\n* 文件的建立时间\n### 文件操作\n* 创建文件\n* 删除文件\n* 读文件\n* 写文件\n* 设置文件读写的位置\n### 文件的逻辑结构\n* 顺序文件\n* 记录寻址\n* 索引文件\n* 索引顺序文件\n* 直接文件和哈希文件\n### 文件目录\n* 文件控制块（FCB）\n    * 文件名+inode(属性)\n* 简单的文件目录\n    * 单级文件目录\n        * 查找慢\n        * 不允许重名\n        * 不便于实现文件共享\n    * 两级文件目录\n        * 提高检索速度，从M*N到M+N\n* 树形结构目录\n    * 路径名\n        * “..”是父目录\n        * “/”是根目录\n        * 区别绝对路径和相对路径（../.../.../1/2/3/）\n### 文件共享\n* 有向无循环图（DAG）\n* 利用符号链接实现文件共享\n    * 实际上就是“快捷方式”\n### 文件保护\n\n![picture](https://github.com/SSHeRun/CS-Xmind-Note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png)\n","slug":"2023-06-14-0-计算机操作系统","published":1,"date":"2023-12-15T02:31:41.815Z","updated":"2023-12-15T02:31:41.955Z","_id":"clq60joni00004zgs7yrv94pb","title":"","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"计算机操作系统\"><a href=\"#计算机操作系统\" class=\"headerlink\" title=\"计算机操作系统\"></a>计算机操作系统</h1><h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><h2 id=\"一-操作系统引论\"><a href=\"#一-操作系统引论\" class=\"headerlink\" title=\"一.操作系统引论\"></a>一.操作系统引论</h2><h3 id=\"1-操作系统的目标和功能\"><a href=\"#1-操作系统的目标和功能\" class=\"headerlink\" title=\"1.操作系统的目标和功能\"></a>1.操作系统的目标和功能</h3><ul>\n<li>目标<ul>\n<li>方便性</li>\n<li>有效性<ul>\n<li>提高系统资源利用率</li>\n<li>提高系统吞吐量</li>\n</ul>\n</li>\n<li>可扩充性</li>\n<li>开放性</li>\n</ul>\n</li>\n<li>作用<ul>\n<li>OS作为用户与计算机硬件系统之间的接口<ul>\n<li>命令方式</li>\n<li>系统调用方式</li>\n<li>图标–窗口方式</li>\n</ul>\n</li>\n<li>OS实现了对计算机资源的抽象</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-操作系统的发展过程\"><a href=\"#2-操作系统的发展过程\" class=\"headerlink\" title=\"2.操作系统的发展过程\"></a>2.操作系统的发展过程</h3><ul>\n<li><p>未配置操作系统的计算机系统</p>\n<ul>\n<li><p>人工操作方式</p>\n</li>\n<li><blockquote>\n<p>用户独占全机 CPU等待人工操作 严重降低了计算机资源的利用率</p>\n</blockquote>\n</li>\n<li><p>脱机输入&#x2F;输出(Off–Line I&#x2F;O)方式</p>\n</li>\n<li><blockquote>\n<p>减少了CPU的空闲时间 提高了I&#x2F;O速度 效率仍然不理想</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>单道批处理系统</p>\n</li>\n<li><p>多道批处理系统</p>\n</li>\n<li><blockquote>\n<p>1.资源利用率高</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>2.系统吞吐量大</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>3.平均周转时间长</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>4.无交互能力</p>\n</blockquote>\n<ul>\n<li>(宏观并行，微观串行)</li>\n</ul>\n</li>\n<li><p>分时系统</p>\n</li>\n<li><blockquote>\n<p>特征:</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>1.多路性</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>2.独立性</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>3.及时性</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>4.交互性</p>\n</blockquote>\n</li>\n<li><p>实时系统</p>\n</li>\n<li><p>集群系统–超算~云计算</p>\n</li>\n<li><p>微机操作系统的发展</p>\n</li>\n</ul>\n<h3 id=\"3-操作系统的基本特征\"><a href=\"#3-操作系统的基本特征\" class=\"headerlink\" title=\"3.操作系统的基本特征\"></a>3.操作系统的基本特征</h3><ul>\n<li><p>1.并发concurrence</p>\n<ul>\n<li>区别并行和并发</li>\n<li><blockquote>\n<p>并行性是指两个或多个事件在同一时刻发生→宏观并行，微观并行</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>并发性是指两个或多个事件在同一时间间隔内发生→宏观并行，微观串行</p>\n</blockquote>\n<ul>\n<li>并发是进程宏观一起运行，微观上交替运行，而并行是指同时运行</li>\n</ul>\n</li>\n<li>引入进程</li>\n<li><blockquote>\n<p>进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令，数据和堆栈等组成的，是一个能独立运行的活动实体</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>2.共享sharing</p>\n<ul>\n<li>1.互斥共享方式</li>\n<li>2.同时访问方式</li>\n<li>并发和共享是多用户(多任务)OS的两个最基本的特征。它们又是互为存在的条件</li>\n</ul>\n</li>\n<li><p>3.虚拟virtual</p>\n<ul>\n<li>时分复用技术</li>\n<li>空分复用技术</li>\n</ul>\n</li>\n<li><p>4.异步asynchronism</p>\n</li>\n</ul>\n<h3 id=\"4-操作系统的主要功能\"><a href=\"#4-操作系统的主要功能\" class=\"headerlink\" title=\"4.操作系统的主要功能\"></a>4.操作系统的主要功能</h3><ul>\n<li>1.处理机管理功能<ul>\n<li>进程控制</li>\n<li>进程同步<ul>\n<li>进程互斥方式</li>\n<li>进程同步方式(协同)</li>\n</ul>\n</li>\n<li>进程通信</li>\n<li>调度<ul>\n<li>作业调度</li>\n<li>进程调度</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>2.存储器管理功能<ul>\n<li>内存分配<ul>\n<li>静态分配</li>\n<li>动态分配</li>\n</ul>\n</li>\n<li>内存保护</li>\n<li>地址映射</li>\n<li>内存扩充</li>\n</ul>\n</li>\n<li>3.设备管理功能<ul>\n<li>缓冲管理</li>\n<li>设备分配</li>\n<li>设备处理<ul>\n<li>设备处理程序又称设备驱动程序</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>4.文件管理功能<ul>\n<li>文件存储空间的管理</li>\n<li>目录管理</li>\n<li>文件的读写管理和保护</li>\n</ul>\n</li>\n<li>5.操作系统与用户之间的接口<ul>\n<li>用户接口</li>\n<li>程序接口</li>\n</ul>\n</li>\n<li>6.现代操作系统的新功能<ul>\n<li>系统安全</li>\n<li>网络的功能和服务</li>\n<li>支持多媒体</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-OS结构设计\"><a href=\"#5-OS结构设计\" class=\"headerlink\" title=\"5.OS结构设计\"></a>5.OS结构设计</h3><ul>\n<li>传统操作系统结构<ul>\n<li>无结构操作系统</li>\n<li>模块化OS</li>\n<li>分层式结构OS</li>\n</ul>\n</li>\n<li>微内核os结构<ul>\n<li>客户&#x2F;服务器模式</li>\n<li>面对对象的程序设计</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二章进程的描述与控制\"><a href=\"#第二章进程的描述与控制\" class=\"headerlink\" title=\"第二章进程的描述与控制\"></a>第二章进程的描述与控制</h2><h3 id=\"前驱图和程序执行\"><a href=\"#前驱图和程序执行\" class=\"headerlink\" title=\"前驱图和程序执行\"></a>前驱图和程序执行</h3><h3 id=\"程序并发执行\"><a href=\"#程序并发执行\" class=\"headerlink\" title=\"程序并发执行\"></a>程序并发执行</h3><ul>\n<li>程序的并发执行</li>\n<li>程序并发执行时的特征<ul>\n<li>间断性</li>\n<li>失去封闭性</li>\n<li>不可再现性</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进程的描述\"><a href=\"#进程的描述\" class=\"headerlink\" title=\"进程的描述\"></a>进程的描述</h3><ul>\n<li>进程的定义<ul>\n<li>进程是程序的一次执行</li>\n<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li>\n<li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li>\n</ul>\n</li>\n<li>进程的特征<ul>\n<li>动态性</li>\n<li>并发性</li>\n<li>独立性</li>\n<li>异步性</li>\n</ul>\n</li>\n<li>从操作系统角度分类<ul>\n<li>系统进程</li>\n<li>用户进程</li>\n</ul>\n</li>\n<li>进程和程序的区别<ul>\n<li>进程是动态概念，而程序则是静态概念</li>\n<li>程序是指令的有序集合，永远存在；进程强调是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；</li>\n<li>进程具有并发性，而程序没有</li>\n<li>进程可创建其他进程，而程序并不能形成新的程序</li>\n<li>进程是竞争计算机资源的基本单位，程序不是</li>\n</ul>\n</li>\n<li>进程和程序的联系<ul>\n<li>进程是程序在数据集上的一次执行</li>\n<li>程序是构成进程的组成部分，一个程序可对应多个进程，一个进程可包括多个程序</li>\n<li>进程的运行目标是执行所对应的程序</li>\n<li>从静态看，进程由程序、数据和进程控制块（PCB）组成</li>\n</ul>\n</li>\n<li>进程的基本状态及转换<ul>\n<li>进程的三种基本状态<ul>\n<li>就绪状态ready</li>\n<li>执行状态running</li>\n<li>阻塞状态block</li>\n</ul>\n</li>\n<li>三种基本状态的转换</li>\n<li>创建状态和终止状态<ul>\n<li>五状态进程模型</li>\n</ul>\n</li>\n<li>注意<ul>\n<li>阻塞态-&gt;运行态和就绪态-&gt;阻塞态这二种状态转换不可能发生</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>挂起操作和进程状态的转换<ul>\n<li>挂起和阻塞的区别</li>\n<li>挂起操作的目的<ul>\n<li>终端用户的需要: 修改、检查进程</li>\n<li>父进程的需要：修改、协调子进程</li>\n<li>对换的需要：缓和内存</li>\n<li>负荷调节的需要：保证实时任务的执行</li>\n</ul>\n</li>\n<li>关键图</li>\n</ul>\n</li>\n<li>进程管理中的数据结构<ul>\n<li>进程控制块PCB的作用<ul>\n<li>作为独立运行基本单位的标志</li>\n<li>能实现间断性运行方式</li>\n<li>提供进程管理所需要的信息</li>\n<li>提供进程调度所需要的信息</li>\n<li>实现与其他进程的同步与通信</li>\n</ul>\n</li>\n<li>进程控制块的信息<ul>\n<li>进程标识符<ul>\n<li>外部标识符PID</li>\n<li>内部标识符(端口)</li>\n</ul>\n</li>\n<li>处理机状态<ul>\n<li>通用寄存器</li>\n<li>指令计数器</li>\n<li>程序状态字PSW</li>\n<li>用户栈指针</li>\n</ul>\n</li>\n<li>进程调度信息<ul>\n<li>进程状态</li>\n<li>进程优先级</li>\n<li>进程调度所需的其他信息</li>\n<li>事件</li>\n</ul>\n</li>\n<li>进程控制信息<ul>\n<li>程序和数据的地址</li>\n<li>进程同步和通信机制</li>\n<li>资源清单</li>\n<li>链接指针</li>\n</ul>\n</li>\n<li>进程控制块的组织方式<ul>\n<li>线性方式</li>\n<li>链接方式</li>\n<li>索引方式</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h3><ul>\n<li>操作系统内核<ul>\n<li>两大功能<ul>\n<li>支撑功能<ul>\n<li>中断管理</li>\n<li>时钟管理</li>\n<li>原语操作<ul>\n<li>进程的管理，由若干原语（primitive）来执行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>资源管理功能<ul>\n<li>进程管理</li>\n<li>存储器管理</li>\n<li>设备管理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>状态<ul>\n<li>系统态，管态，内核态</li>\n<li>用户态，目态</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>进程的创建<ul>\n<li>进程的层次结构<ul>\n<li>父进程</li>\n<li>子进程</li>\n</ul>\n</li>\n<li>引起创建进程的事件<ul>\n<li>用户登录</li>\n<li>作业调度</li>\n<li>提供服务</li>\n<li>应用请求</li>\n</ul>\n</li>\n<li>进程的创建过程<ul>\n<li>1.申请空白PCB</li>\n<li>2.为新进程分配其运行所需的资源</li>\n<li>3.初始化进程块PCB</li>\n<li>4.如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列</li>\n</ul>\n</li>\n<li>进程的终止<ul>\n<li>引起进程终止的事件<ul>\n<li>1.正常结束</li>\n<li>2.异常结束</li>\n<li>3.外界干预</li>\n</ul>\n</li>\n<li>进程的终止过程<ul>\n<li>1.根据被终止进程的标识符</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>进程的阻塞与唤醒<ul>\n<li>引起进程阻塞和唤醒的事件<ul>\n<li>请求系统服务而未满足</li>\n<li>启动某种操作而阻塞当前进程</li>\n<li>新数据尚未到达</li>\n<li>无新工作可做：系统进程</li>\n</ul>\n</li>\n<li>进程阻塞过程(自己阻塞自己)</li>\n<li>进程唤醒过程(系统或其他进程唤醒自己)</li>\n</ul>\n</li>\n<li>进程的挂起与激活<ul>\n<li>suspend</li>\n<li>active</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>进程同步<ul>\n<li>基本概念<ul>\n<li>两种形式的制约关系<ul>\n<li>间接相互制约关系<ul>\n<li>互斥——竞争</li>\n</ul>\n</li>\n<li>直接相互制约关系<ul>\n<li>同步——协作</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>临界资源</li>\n<li>分区<ul>\n<li>进入区enter section</li>\n<li>临界区critical section</li>\n<li>退出区exit section</li>\n<li>剩余区remainder section</li>\n</ul>\n</li>\n<li>同步机制应遵循的规则<ul>\n<li>1.空闲让进</li>\n<li>2.忙则等待</li>\n<li>3.有限等待</li>\n<li>4.让权等待</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>进程同步机制<ul>\n<li>软件同步机制:都没有解决让权等待，而且部分方法还会产生死锁的情况</li>\n<li>硬件同步机制<ul>\n<li>关中断</li>\n<li>利用Test-and-Set指令实现互斥</li>\n<li>利用swap指令实现进程互斥</li>\n</ul>\n</li>\n<li>信号量机制<ul>\n<li>整型信号量</li>\n<li>记录型信号量<ul>\n<li>由于整型信号量没有遵循让权等待原则，记录型允许负数，即阻塞链表</li>\n</ul>\n</li>\n<li>AND型信号量</li>\n<li>信号量集<ul>\n<li>理解:AND型号量的wait和signal仅能对信号施以加1或减1操作，意味着每次只能对某类临界资源进行一个单位的申请或释放。当一次需要N个单位时，便要进行N次wait操作，这显然是低效的，甚至会增加死锁的概率。此外，在有些情况下，为确保系统的安全性，当所申请的资源数量低于某一下限值时，还必须进行管制，不予以分配。因此，当进程申请某类临界资源时，在每次分配前，都必须测试资源数量，判断是否大于可分配的下限值，决定是否予以分配</li>\n<li>操作<ul>\n<li>Swait(S1，t1，d1…Sn，tn，dn)</li>\n<li>Ssignal(S1，d1…Sn，dn)</li>\n</ul>\n</li>\n<li>特殊情况</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>经典进程的同步问题<ul>\n<li>生产者–消费者问题</li>\n<li>哲学家进餐问题</li>\n<li>读者–写者问题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h3><ul>\n<li>进程通信是指进程之间的信息交换，又称低级进程通信</li>\n<li>进程通信的类型<ul>\n<li>共享存储器系统<ul>\n<li>基于共享数据结构的通信方式<ul>\n<li>生产者和消费者</li>\n</ul>\n</li>\n<li>基于共享存储区的通信方式<ul>\n<li>高级通信</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>管道通信系统(pipe)<ul>\n<li>高级通信</li>\n</ul>\n</li>\n<li>消息传递系统<ul>\n<li>高级通信</li>\n<li>方式分类<ul>\n<li>直接通信</li>\n<li>间接通信</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>客服机–服务器系统</li>\n</ul>\n</li>\n<li>消息传递通信的实现方式<ul>\n<li>直接消息传递系统</li>\n<li>信箱通信</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程的基本概念\"><a href=\"#线程的基本概念\" class=\"headerlink\" title=\"线程的基本概念\"></a>线程的基本概念</h3><ul>\n<li>线程的引入<ul>\n<li>线程的引入正是为了简化线程间的通信，以小的开销来提高进程内的并发程度</li>\n<li>多线程并发的不足<ul>\n<li>进程的两个基本属性<ul>\n<li>一个拥有资源的独立单位，可独立分配系统资源</li>\n<li>一个可独立调度和分派的基本单位，PCB</li>\n</ul>\n</li>\n<li>程序并发执行所需付出的时空开销<ul>\n<li>创建进程</li>\n<li>撤销进程</li>\n<li>进程切换</li>\n</ul>\n</li>\n<li>进程间通信效率低</li>\n<li>将分配资源和调度两个属性分开</li>\n</ul>\n</li>\n<li>线程——作为调度和分派的基本单位<ul>\n<li>进程是系统资源分配的单位，线程是处理器调度的单位</li>\n<li>线程表示进程的一个控制点，可以执行一系列的指令。通常，和应用程序的一个函数相对应</li>\n<li>进程分解为线程还可以有效利用多处理器和多核计算机</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>线程与进程的比较<ul>\n<li>不同点<ul>\n<li>调度的基本单位</li>\n<li>并发性</li>\n</ul>\n</li>\n<li>相似点<ul>\n<li>状态：运行、阻塞、就绪</li>\n<li>线程具有一定的生命期</li>\n<li>进程可创建线程，一个线程可创建另一个子线程</li>\n<li>多个线程并发执行时仍然存在互斥与同步</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>线程的实现<ul>\n<li>线程的实现方式<ul>\n<li>内核支持线程KST</li>\n<li>用户级线程ULT</li>\n<li>组合方式</li>\n</ul>\n</li>\n<li>多线程OS中的进程属性<ul>\n<li>进程是一个可拥有资源的基本单位</li>\n<li>多个线程可并发执行</li>\n<li>进程已不是可执行的实体</li>\n</ul>\n</li>\n<li>线程的状态和线程控制块<ul>\n<li>线程运行的三个状态<ul>\n<li>执行状态</li>\n<li>就绪状态</li>\n<li>阻塞状态</li>\n</ul>\n</li>\n<li>线程控制块TCB</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第三章-处理机调度与死锁\"><a href=\"#第三章-处理机调度与死锁\" class=\"headerlink\" title=\"第三章:处理机调度与死锁\"></a>第三章:处理机调度与死锁</h2><h3 id=\"处理机调度算法的目标\"><a href=\"#处理机调度算法的目标\" class=\"headerlink\" title=\"处理机调度算法的目标\"></a>处理机调度算法的目标</h3><ul>\n<li>处理机调度算法的共同目标<ul>\n<li>资源利用率:CPU的利用率&#x3D;CPU有效工作时间&#x2F;(CPU有效工作时间+CPU空闲等待时间)</li>\n<li>公平性</li>\n<li>平衡性</li>\n<li>策略强制执行</li>\n</ul>\n</li>\n<li>批处理系统的目标<ul>\n<li>平均周转时间短</li>\n<li>系统吞吐量高</li>\n<li>处理机利用率高</li>\n</ul>\n</li>\n<li>分时系统的目标<ul>\n<li>响应时间快</li>\n<li>均衡性</li>\n</ul>\n</li>\n<li>实时系统目标<ul>\n<li>截止时间的保证</li>\n<li>可预测性</li>\n</ul>\n</li>\n<li>处理机调度的层次<ul>\n<li>高级调度（作业调度）<ul>\n<li>分时系统无需作业调度，因为需要交互</li>\n<li>批处理系统需要作业调度</li>\n</ul>\n</li>\n<li>中级调度（和挂起有关）</li>\n<li>低级调度（进程调度）<ul>\n<li>进程调度是最基本的调度，任何操作系统都有进程调度。</li>\n<li>低级调度的三个基本机制<ul>\n<li>排队器</li>\n<li>分派器</li>\n<li>上下文切换</li>\n</ul>\n</li>\n<li>进程调度方式<ul>\n<li>非抢占方式</li>\n<li>抢占方式<ul>\n<li>优先权原则</li>\n<li>短进程优先原则</li>\n<li>时间片原则</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>进程调度的任务<ul>\n<li>保存处理机的现场信息</li>\n<li>按某种算法选取进程</li>\n<li>把处理器分配给进程</li>\n</ul>\n</li>\n<li>进程调度的算法<ul>\n<li>优先级调度算法<ul>\n<li>优先级调度算法的类型<ul>\n<li>非抢占式优先级调度算法<ul>\n<li>等当前进程执行完以后，再执行另一个优先权最高的进程</li>\n<li>这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</li>\n</ul>\n</li>\n<li>抢占式优先级调度算法<ul>\n<li>不等当前进程结束，直接抢处理机</li>\n<li>常用于要求比较严格的实时系统中， 以及对性能要求较高的批处理和分时系统中。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>优先级的类型<ul>\n<li>静态优先级<ul>\n<li>优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，例如，0<del>7或0</del>255中的某一整数， 又把该整数称为优先数。</li>\n<li>可以参考BIOS系统中设置boot的优先级</li>\n</ul>\n</li>\n<li>动态优先级<ul>\n<li>在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>轮转调度算法<ul>\n<li>基本原理:在轮转(RR)法中，系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并可设置每隔一定时间间隔(如30ms)即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其执行</li>\n<li>进程切换时机<ul>\n<li>时间片未用完，进程完成</li>\n<li>时间片到，进程未完成</li>\n</ul>\n</li>\n<li>时间片大小的确定<ul>\n<li>太小利于短作业，增加系统切换开销</li>\n<li>太长就退化为FCFS算法</li>\n<li>一般选择: q略大于一次交互所需要的时间，使大多数进程在一个时间片内完成</li>\n</ul>\n</li>\n<li>一般来说，平均周转时间将比SJF长，但是有较好的响应时间</li>\n</ul>\n</li>\n<li>多队列调度算法</li>\n<li>多级反馈队列调度算法<ul>\n<li>调度机制<ul>\n<li>设置多个就绪队列</li>\n<li>每个队列都采用FCFS算法</li>\n<li>按照队列优先级调度，在第n队列中采取按时间片轮转的方式运行</li>\n</ul>\n</li>\n<li>调度算法的性能<ul>\n<li>对于终端型用户，由于作业小，感觉满意</li>\n<li>对于短批处理作业用户，周转时间也较小</li>\n<li>长批处理作业用户，也能够得到执行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>基于公平原则的调度算法<ul>\n<li>保证调度算法</li>\n<li>公平分享调度算法</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"作业与作业调度\"><a href=\"#作业与作业调度\" class=\"headerlink\" title=\"作业与作业调度\"></a>作业与作业调度</h3><ul>\n<li>作业<ul>\n<li>作业不仅包含程序和数据，还配有一份作业说明书，系统根据说明书对程序的运行进行控制。批处理系统是以作业为单位从外存掉入内存的。</li>\n</ul>\n</li>\n<li>作业控制块JCB<ul>\n<li>为每个作业设置一个JCB，保存了对作业管理调度的全部信息。是作业存在的标志。</li>\n</ul>\n</li>\n<li>作业步<ul>\n<li>作业步，每个作业都必须经过若干相对独立，有相互关联的顺序步骤才能得到结果。每一个步骤就是一个作业步。</li>\n</ul>\n</li>\n<li>作业运行的三个阶段<ul>\n<li>收容阶段</li>\n<li>运行阶段</li>\n<li>完成阶段</li>\n</ul>\n</li>\n<li>作业运行的三个状态<ul>\n<li>后备状态</li>\n<li>运行状态</li>\n<li>完成状态</li>\n</ul>\n</li>\n<li>作业调度的主要任务<ul>\n<li>接纳多少个作业</li>\n<li>接纳哪些作业</li>\n</ul>\n</li>\n<li>先来先服务(first–come first–served，FCFS)调度算法<ul>\n<li>比较有利于长作业，而不利于短作业。</li>\n<li>有利于CPU繁忙的作业，而不利于I&#x2F;O繁忙的作业。</li>\n</ul>\n</li>\n<li>短作业优先(short job first，SJF)的调度算法<ul>\n<li>优点<ul>\n<li>比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；</li>\n<li>提高系统的吞吐量；</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>必须预知作业的运行时间</li>\n<li>对长作业非常不利，长作业的周转时间会明显地增长</li>\n<li>在采用SJF算法时，人–机无法实现交互</li>\n<li>该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>优先级调度算法(priority–scheduling algorithm，PSA)</li>\n<li>高响应比优先调度算法(Highest Response Ratio Next,HRRN)<ul>\n<li>原理<ul>\n<li>在每次选择作业投入运行时，先计算此时后备作业队列中每个作业的响应比RP然后选择其值最大的作业投入运行</li>\n<li>优先权&#x3D;(等待时间+要求服务时间)&#x2F;要求服务时间&#x3D;响应时间&#x2F;要求服务时间&#x3D;1+等待时间&#x2F;要求服务时间</li>\n</ul>\n</li>\n<li>特点<ul>\n<li>如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而类似于SJF算法，有利于短作业</li>\n<li>当要求服务的时间相同时，作业的优先权又决定于其等待时间，因而该算法又类似于FCFS算法</li>\n<li>对于长时间的优先级，可以为随等待时间的增加而提高，当等待时间足够长时，也可获得处理机</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"实时调度-HRT和SRT任务\"><a href=\"#实时调度-HRT和SRT任务\" class=\"headerlink\" title=\"实时调度(HRT和SRT任务)\"></a>实时调度(HRT和SRT任务)</h3><ul>\n<li>实现实时调度的基本条件<ul>\n<li>提供必要信息<ul>\n<li>就绪时间</li>\n<li>开始截止时间和完成截止时间</li>\n<li>处理时间</li>\n<li>资源要求</li>\n<li>优先级</li>\n</ul>\n</li>\n<li>系统处理能力强<ul>\n<li>∑(Ci&#x2F;Pi)≤1</li>\n<li>N个处理机:∑(Ci&#x2F;Pi)≤N</li>\n</ul>\n</li>\n<li>采用抢占式调度机制</li>\n<li>具有快速切换机制<ul>\n<li>对中断的快速响应能力</li>\n<li>快速的任务分派能力</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>实时调度算法的分类<ul>\n<li>非抢占式调度算法<ul>\n<li>非抢占式轮转调度算法</li>\n<li>非抢占式优先调度算法</li>\n</ul>\n</li>\n<li>抢占式调度算法<ul>\n<li>基于时钟中断的抢占式优先级调度算法</li>\n<li>立即抢占的优先级调度算法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>最早截止时间优先EDF(Earliest Deadline First)算法<ul>\n<li>根据任务的开始截至时间来确定任务的优先级<ul>\n<li>截至时间越早，优先级越高</li>\n</ul>\n</li>\n<li>非抢占式调度方式用于非周期实时任务</li>\n<li>抢占式调度方式用于周期实时任务</li>\n</ul>\n</li>\n<li>最低松弛度优先LLF(Least Laxity First)算法<ul>\n<li>类似EDF</li>\n<li>算法根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高， 以使之优先执行。</li>\n<li>松弛度例子<ul>\n<li>例如，一个任务在200ms时必须完成，而它本身所需的运行时间就有100ms，因此，调度程序必须在100 ms之前调度执行，该任务的紧急程度(松弛程度)为100 ms</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>优先级倒置(Priority inversion problem)<ul>\n<li>优先级倒置的形成<ul>\n<li>高优先级进程被低优先级进程延迟或阻塞。</li>\n</ul>\n</li>\n<li>优先级倒置的解决方法<ul>\n<li>简单的:假如进程P3在进入临界区后P3所占用的处理机就不允许被抢占</li>\n<li>实用的:建立在动态优先级继承基础上的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"死锁概述\"><a href=\"#死锁概述\" class=\"headerlink\" title=\"死锁概述\"></a>死锁概述</h3><ul>\n<li>资源问题<ul>\n<li>可重用性资源<ul>\n<li>计算机外设</li>\n</ul>\n</li>\n<li>消耗性资源<ul>\n<li>数据，消息</li>\n</ul>\n</li>\n<li>可抢占性资源<ul>\n<li>不引起死锁</li>\n<li>CPU，内存</li>\n</ul>\n</li>\n<li>不可抢占性资源<ul>\n<li>光驱，打印机</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>计算机系统中的死锁<ul>\n<li>竞争不可抢占性资源引起死锁</li>\n<li>竞争可消耗资源引起死锁</li>\n<li>进程推进顺序不当引起死锁</li>\n</ul>\n</li>\n<li>死锁的定义，必要条件和处理方法<ul>\n<li>定义:如果一组进程中的每一个进程都在等待仅由该进程中的其他进程才能引发的事件，那么该组进程是死锁的</li>\n<li>产生死锁的必要条件<ul>\n<li>互斥条件</li>\n<li>请求和保存条件</li>\n<li>不可抢占条件</li>\n<li>循环等待条件<ul>\n<li>如果每个资源只有一个实例，则环路等待条件是死锁存在的充分必要条件</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>处理死锁的方法<ul>\n<li>预防死锁<ul>\n<li>静态方法，在进程执行前采取的措施，通过设置某些限制条件，去破坏产生死锁的四个条件之一，防止发生死锁。</li>\n<li>预防死锁的策略<ul>\n<li>破坏”请求和保存”条件<ul>\n<li>第一种协议<ul>\n<li>所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源</li>\n<li>优点:简单，易行，安全</li>\n<li>缺点<ul>\n<li>资源被严重浪费，严重地恶化了资源的利用率</li>\n<li>使进程经常会发生饥饿现象</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>第二种协议<ul>\n<li>它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的，且已用毕的全部资源，然后再请求新的所需资源</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>破坏”不可抢占”条件<ul>\n<li>当一个已经保存了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请</li>\n</ul>\n</li>\n<li>破坏”循环等待”条件<ul>\n<li>对系统所以资源类型进行线性排序，并赋予不同的序号</li>\n<li>例如令输入机的序号为1，打印机序号为2，磁盘机序号为3等。所有进程对资源的请求必须严格按资源序号递增的次序提出。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>避免死锁<ul>\n<li>动态的方法，在进程执行过程中采取的措施，不需事先采取限制措施破坏产生死锁的必要条件，而是在进程申请资源时用某种方法去防止系统进入不安全状态，从而避免发生死锁。如银行家算法</li>\n<li>避免死锁的策略<ul>\n<li>系统安全状态<ul>\n<li>安全状态<ul>\n<li>某时刻，对于并发执行的n个进程，若系统能够按照某种顺序如&lt;p1,p2…pn&gt;来为每个进程分配所需资源，直至最大需求，从而使每个进程都可顺利完成，则认为该时刻系统处于安全状态，这样的序列为安全序列</li>\n</ul>\n</li>\n<li>安全状态之例</li>\n<li>由安全状态向不安全状态的转换</li>\n</ul>\n</li>\n<li>利用银行家算法避免死锁<ul>\n<li>含义:每一个新进程在进入系统时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给它，否则让进程等待</li>\n<li>银行家算法中的数据结构<ul>\n<li>可用资源向量 Available[m]：m为系统中资源种类数，Available[j]&#x3D;k表示系统中第j类资源数为k个。</li>\n<li>最大需求矩阵 Max[n,m]：n为系统中进程数，Max[i,j]&#x3D;k表示进程i对j类资源的最大需求数为中k。</li>\n<li>分配矩阵 Allocation[n，m]:它定义了系统中每一类资源当前已分配给每一进程资源数，   Allocation[i,j] &#x3D; k表示进程i已分得j类资源的数目为k个。</li>\n<li>需求矩阵 Need[n,m]：它表示每个进程尚需的各类资源数，Need[i,j]&#x3D;k 表示进程i   还需要j类资源k个。Need[i,j]&#x3D;Max[i,j] - Allocation[i,j]</li>\n</ul>\n</li>\n<li>银行家算法</li>\n<li>安全性算法</li>\n<li>银行家算法之例</li>\n<li>解题<ul>\n<li>矩阵</li>\n<li>列表</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>检测死锁<ul>\n<li>死锁的检测与解除<ul>\n<li>死锁的检测<ul>\n<li>资源分配图<ul>\n<li>简化步骤<ul>\n<li>选择一个没有阻塞的进程p</li>\n<li>将p移走，包括它的所有请求边和分配边</li>\n<li>重复步骤1，2，直至不能继续下去</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>死锁定理<ul>\n<li>若一系列简化以后不能使所有的进程节点都成为孤立节点</li>\n</ul>\n</li>\n<li>检测时机<ul>\n<li>当进程等待时检测死锁 （其缺点是系统的开销大）</li>\n<li>定时检测</li>\n<li>系统资源利用率下降时检测死锁</li>\n</ul>\n</li>\n<li>死锁检测中的数据结构</li>\n</ul>\n</li>\n<li>死锁的解除<ul>\n<li>抢占资源</li>\n<li>终止(或撤销)进程</li>\n<li>终止进程的方法<ul>\n<li>终止所有死锁进程</li>\n<li>逐个终止进程<ul>\n<li>代价最小<ul>\n<li>进程的优先级的大小</li>\n<li>进程已执行了多少时间，还需时间</li>\n<li>进程在运行中已经使用资源的多少，还需多少资源</li>\n<li>进程的性质是交互式还是批处理的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>付出代价最小的死锁解除算法<ul>\n<li>是使用一个有效的挂起和解除机构来挂起一些死锁的进程</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>解除死锁</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第四章-存储器管理\"><a href=\"#第四章-存储器管理\" class=\"headerlink\" title=\"第四章:存储器管理\"></a>第四章:存储器管理</h2><h3 id=\"存储器的层次结构\"><a href=\"#存储器的层次结构\" class=\"headerlink\" title=\"存储器的层次结构\"></a>存储器的层次结构</h3><ul>\n<li>多层结构的存储系统<ul>\n<li>存储器的多层结构<ul>\n<li>CPU寄存器</li>\n<li>主存</li>\n<li>辅存</li>\n</ul>\n</li>\n<li>可执行存储器<ul>\n<li>寄存器和主存的总称</li>\n<li>访问速度快，进程可以在很少的时钟周期内用一条load或store指令完成存取。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>主存储器与寄存器</li>\n<li>高速缓存和磁盘缓存</li>\n</ul>\n<h3 id=\"程序的装入和链接\"><a href=\"#程序的装入和链接\" class=\"headerlink\" title=\"程序的装入和链接\"></a>程序的装入和链接</h3><ul>\n<li>步骤<ul>\n<li>编译<ul>\n<li>源程序 -&gt;目标模块（Object modules）——–Compiler<ul>\n<li>由编译程序对用户源程序进行编译，形成若干个目标模块</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>链接<ul>\n<li>一组目标模块 -&gt;装入模块 （Load Module）———-Linker<ul>\n<li>由链接程序将编译后形成的一组目标模板以及它们所需要的库函数链接在一起，形成一个完整的装入模块</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>装入<ul>\n<li>装入模块 -&gt;内存  ——–Loader<ul>\n<li>由装入程序将装入模块装入内存</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>程序的装入<ul>\n<li>绝对装入方式<ul>\n<li>在编译时，如果知道程序将驻留在内存中指定的位置。编译程序将产生绝对地址的目标代码。</li>\n</ul>\n</li>\n<li>可重定位装入方式<ul>\n<li>在可执行文件中，列出各个需要重定位的地址单元和相对地址值。当用户程序被装入内存时，一次性实现逻辑地址到物理地址的转换，以后不再转换(一般在装入内存时由软件完成)。</li>\n<li>优点：不需硬件支持，可以装入有限多道程序。</li>\n<li>缺点：一个程序通常需要占用连续的内存空间，程序装入内存后不能移动。不易实现共享。</li>\n</ul>\n</li>\n<li>动态运行时的装入方式<ul>\n<li>动态运行时的装入程序在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换为物理地址，而是把这种地址转换推迟到程序真正要执行时才进行</li>\n<li>优点：<ul>\n<li>OS可以将一个程序分散存放于不连续的内存空间，可以移动程序，有利用实现共享。</li>\n<li>能够支持程序执行中产生的地址引用，如指针变量（而不仅是生成可执行文件时的地址引用）。</li>\n</ul>\n</li>\n<li>缺点：需要硬件支持，OS实现较复杂。</li>\n<li>它是虚拟存储的基础。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>程序的链接<ul>\n<li>静态链接方式(lib)</li>\n<li>装入时动态链接</li>\n<li>运行时动态链接(dll)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"连续分配存储管理方式\"><a href=\"#连续分配存储管理方式\" class=\"headerlink\" title=\"连续分配存储管理方式\"></a>连续分配存储管理方式</h3><ul>\n<li>连续分配<ul>\n<li>单一连续分配(DOS)</li>\n<li>固定分区分配(浪费很多空间)</li>\n<li>动态分区分配</li>\n</ul>\n</li>\n<li>地址映射和存储保护措施<ul>\n<li>基址寄存器：程序的最小物理地址</li>\n<li>界限寄存器：程序的逻辑地址范围</li>\n<li>物理地址 &#x3D; 逻辑地址 + 基址</li>\n</ul>\n</li>\n<li>内碎片：占用分区之内未被利用的空间</li>\n<li>外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）</li>\n<li>把内存划分为若干个固定大小的连续分区。固定式分区又称为静态分区。<ul>\n<li>分区大小相等：只适合于多个相同程序的并发执行（处理多个类型相同的对象）。</li>\n<li>分区大小不等：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。</li>\n<li>优点：无外碎片、易实现、开销小。</li>\n<li>缺点：<ul>\n<li>存在内碎片，造成浪费</li>\n<li>分区总数固定，限制了并发执行的程序数目。</li>\n<li>通用Os很少采用，部分控制系统中采用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>动态创建分区：指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。可变式分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。<ul>\n<li>基于顺序搜索的动态分区分配算法<ul>\n<li>首次适应算法（first fit,FF）<ul>\n<li>顺序找，找到一个满足的就分配，但是可能存在浪费</li>\n<li>这种方法目的在于减少查找时间。</li>\n<li>空闲分区表（空闲区链）中的空闲分区要按地址由低到高进行排序</li>\n</ul>\n</li>\n<li>循环首次适应算法（next fit，NF）<ul>\n<li>相对上面那种，不是顺序，类似哈希算法中左右交叉排序</li>\n<li>空闲分区分布得更均匀，查找开销小</li>\n<li>从上次找到的空闲区的下一个空闲区开始查找，直到找到第一个能满足要求的的空闲区为止，并从中划出一块与请求大小相等的内存空间分配给作业。</li>\n</ul>\n</li>\n<li>最佳适应算法（best fit，BF）<ul>\n<li>找到最合适的，但是大区域的访问次数减少</li>\n<li>这种方法能使外碎片尽量小。</li>\n<li>空闲分区表（空闲区链）中的空闲分区要按大小从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。</li>\n</ul>\n</li>\n<li>最坏适应算法（worst fit，WF）<ul>\n<li>相对于最好而言，找最大的区域下手，导致最大的区域可能很少，也造成许多碎片</li>\n<li>空闲分区按大小由大到小排序</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>基于索引搜索的动态分区分配算法<ul>\n<li>快速适应算法（quick fit）</li>\n<li>伙伴系统（buddy system）</li>\n<li>哈希算法</li>\n</ul>\n</li>\n<li>动态可重定位分区分配<ul>\n<li>紧凑</li>\n<li>动态重定位<ul>\n<li>动态运行时装入，地址转化在指令执行时进行，需获得硬件地址变换机制的支持</li>\n<li>内存地址&#x3D;相对地址+起始地址</li>\n</ul>\n</li>\n<li>动态重定位分区分配算法<ul>\n<li>1、在某个分区被释放后立即进行紧凑，系统总是只有一个连续的分区而无碎片，此法很花费机时。</li>\n<li>2、当“请求分配模块”找不到足够大的自由分区分给用户时再进行紧凑，这样紧缩的次数比上种方法少得多，但管理复杂。采用此法的动态重定位分区分配算法框图如下：</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>优点：没有内碎片。</li>\n<li>缺点：外碎片。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"对换（了解）\"><a href=\"#对换（了解）\" class=\"headerlink\" title=\"对换（了解）\"></a>对换（了解）</h3><ul>\n<li>系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。</li>\n</ul>\n<h3 id=\"基本分页存储管理方式\"><a href=\"#基本分页存储管理方式\" class=\"headerlink\" title=\"基本分页存储管理方式\"></a>基本分页存储管理方式</h3><ul>\n<li>分页存储管理的基本方式<ul>\n<li>页面<ul>\n<li>将一个进程的逻辑地址空间分成若干个大小相等的片</li>\n</ul>\n</li>\n<li>页框（frame）<ul>\n<li>内存空间分成与页面相同大小的存储块</li>\n</ul>\n</li>\n<li>由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”</li>\n<li>地址结构<ul>\n<li>页号P+位移量W(0-31)</li>\n</ul>\n</li>\n<li>页表<ul>\n<li>在分页系统中，允许将进程的各个页离散地存储在内存在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每一个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表</li>\n<li>页表的作用是实现从页面号到物理块号的地址映射</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>地址变换机构<ul>\n<li>基本的地址变换机构<ul>\n<li>要访问两次内存</li>\n<li>页表大都驻留在内存中</li>\n<li>为了实现地址变换功能，在系统中设置页表寄存器（PTR），用来存放页表的始址和页表的长度。</li>\n<li>在进程未执行时，每个进程对应的页表的始址和长度存放在进程的PCB中，当该进程被调度时，就将它们装入页表寄存器。</li>\n</ul>\n</li>\n<li>具有快表的地址变换机构<ul>\n<li>提高了效率，此处会有计算题</li>\n<li>如果页表存放在内存中，则每次访问内存时，都要先访问内存中的页表，然后根据所形成的物理地址再访问内存。这样CPU存一个数据必须访问两次内存，从而使计算机的处理速度降低了1&#x2F;2。</li>\n<li>为了提高地址变换的速度，在地址变换机构中增设了一个具有并行查询功能的特殊的高速缓冲存储器，称为“联想存储器”或“快表”，用以存放当前访问的那些页表项。</li>\n<li>地址变换过程为：<ul>\n<li>1、CPU给出有效地址</li>\n<li>2、地址变换机构自动地将页号送入高速缓存，确定所需要的页是否在快表中。</li>\n<li>3、若是，则直接读出该页所对应的物理块号，送入物理地址寄存器；</li>\n<li>4、若快表中未找到对应的页表项，则需再访问内存中的页表</li>\n<li>5、找到后，把从页表中读出的页表项存入快表中的一个寄存器单元中，以取代一个旧的页表项。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>两级和多级页表<ul>\n<li>主要是有的时候页表太多了，要化简</li>\n<li>格式：外层页号P1+外层页内地址P2+页内地址d</li>\n<li>基本方法：将页表进行分页，每个页面的大小与内存物理块的大小相同，并为它们进行编号，可以离散地将各个页面分别存放在不同的物理块中。</li>\n</ul>\n</li>\n<li>反置页表<ul>\n<li>反置页表为每一个物理块（页框）设置一个页表项，并按物理块排序，其内容则是页号和其所属进程的标识。</li>\n</ul>\n</li>\n<li>优点：<ul>\n<li>没有外碎片，每个内碎片不超过页大小。</li>\n<li>一个程序不必连续存放。</li>\n<li>便于改变程序占用空间的大小。即随着程序运行而动态生成的数据增多，地址空间可相应增长。</li>\n</ul>\n</li>\n<li>缺点：程序全部装入内存。</li>\n</ul>\n<h3 id=\"分段存储管理方式\"><a href=\"#分段存储管理方式\" class=\"headerlink\" title=\"分段存储管理方式\"></a>分段存储管理方式</h3><ul>\n<li>引入<ul>\n<li>方便编程</li>\n<li>信息共享</li>\n<li>动态增长</li>\n<li>动态链接</li>\n</ul>\n</li>\n<li>在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。</li>\n<li>内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定</li>\n<li>分段系统的基本原理<ul>\n<li>分段<ul>\n<li>格式：段号+段内地址</li>\n</ul>\n</li>\n<li>段表<ul>\n<li>段表实现了从逻辑段到物理内存区的映射。</li>\n</ul>\n</li>\n<li>地址变换机构</li>\n</ul>\n</li>\n<li>和分页的区别<ul>\n<li>页是信息的物理单位</li>\n<li>页的大小固定且由系统固定</li>\n<li>分页的用户程序地址空间是一维的</li>\n<li>通常段比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。</li>\n<li>分页是系统管理的需要，分段是用户应用的需要。一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。</li>\n</ul>\n</li>\n<li>信息共享<ul>\n<li>这是分段最重要的优点</li>\n</ul>\n</li>\n<li>段页式存储管理方式<ul>\n<li>基本原理<ul>\n<li>格式：段号（S）+段内页号（P）+页内地址（W）</li>\n</ul>\n</li>\n<li>地址变换过程<ul>\n<li>需要三次访问过程</li>\n</ul>\n</li>\n<li>在段页式系统中，为了获得一条指令或数据，需三次访问内存：第一次访问内存中的段表，从中取得页表始址；第二次访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正根据所得的物理地址取出指令或数据。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第五章：虚拟存储器\"><a href=\"#第五章：虚拟存储器\" class=\"headerlink\" title=\"第五章：虚拟存储器\"></a>第五章：虚拟存储器</h2><h3 id=\"常规存储管理方式的特征\"><a href=\"#常规存储管理方式的特征\" class=\"headerlink\" title=\"常规存储管理方式的特征\"></a>常规存储管理方式的特征</h3><ul>\n<li>一次性</li>\n<li>驻留性</li>\n</ul>\n<h3 id=\"局部性原理\"><a href=\"#局部性原理\" class=\"headerlink\" title=\"局部性原理\"></a>局部性原理</h3><ul>\n<li>程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域</li>\n<li>时间局限性<ul>\n<li>如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环操作</li>\n</ul>\n</li>\n<li>空间局限性<ul>\n<li>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><ul>\n<li>指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统</li>\n</ul>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>大程序：可在较小的可用内存中执行较大的用户程序；</li>\n<li>大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存(real memory)</li>\n<li>并发：可在内存中容纳更多程序并发执行；</li>\n<li>易于开发：不必影响编程时的程序结构</li>\n<li>以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术</li>\n</ul>\n<h3 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h3><ul>\n<li>离散性<ul>\n<li>指在内存分配时采用离散的分配方式，它是虚拟存储器的实现的基础</li>\n</ul>\n</li>\n<li>多次性<ul>\n<li>指一个作业被分成多次调入内存运行，即在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可。多次性是虚拟存储器最重要的特征</li>\n</ul>\n</li>\n<li>对换性<ul>\n<li>指允许在作业的运行过程中在内存和外存的对换区之间换进、换出。</li>\n</ul>\n</li>\n<li>虚拟性<ul>\n<li>指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"虚拟存储器的实现方式\"><a href=\"#虚拟存储器的实现方式\" class=\"headerlink\" title=\"虚拟存储器的实现方式\"></a>虚拟存储器的实现方式</h3><ul>\n<li>请求分页存储管理方式<ul>\n<li>硬件<ul>\n<li>请求页表机制<ul>\n<li>格式：页号+物理块号+状态位P+访问字段A+修改位M+外存地址</li>\n</ul>\n</li>\n<li>缺页中断机构</li>\n<li>地址变换机构（过程图很关键）</li>\n</ul>\n</li>\n<li>请求分页中的内存分配<ul>\n<li>最小物理块数<ul>\n<li>即能保证进程正常运行所需的最小物理块数</li>\n</ul>\n</li>\n<li>内存分配策略<ul>\n<li>固定分配局部置换（国王的大儿子）</li>\n<li>可变分配全局置换（国王的二儿子）</li>\n<li>可变分配局部置换（国王的小儿子）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>物理块分配算法<ul>\n<li>平均分配算法</li>\n<li>按比例分配算法</li>\n<li>考虑优先权的分配算法</li>\n</ul>\n</li>\n<li>页面调入策略<ul>\n<li>系统应在何时调入所需页面<ul>\n<li>预调页策略（不能实现）</li>\n<li>请求调页策略（需要才给）</li>\n</ul>\n</li>\n<li>系统应该从何处调入这些页面<ul>\n<li>对换区</li>\n<li>文件区</li>\n</ul>\n</li>\n<li>页面调入过程</li>\n<li>缺页率（出计算题）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>请求分段系统<ul>\n<li>硬件<ul>\n<li>请求分段的段表机构</li>\n<li>缺段中断机构</li>\n<li>地址变换机构</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"页面置换算法\"><a href=\"#页面置换算法\" class=\"headerlink\" title=\"页面置换算法\"></a>页面置换算法</h3><ul>\n<li>抖动的概念<ul>\n<li>即刚被换出的页很快又要被访问，需要将它重新调入，此时又需要再选一页调出</li>\n</ul>\n</li>\n<li>最佳置换算法(需要预知后面进程，所以不能实现)</li>\n<li>先进先出页面置换算法（FIFO）<ul>\n<li>选择在内存中驻留时间最久的页面予以淘汰</li>\n</ul>\n</li>\n<li>最近最久未使用置换算法（LRU）Recently<ul>\n<li>寄存器支持</li>\n<li>特殊的栈结构</li>\n</ul>\n</li>\n<li>最少使用置换算法（LFU）Frequently</li>\n<li>clock置换算法（对访问位A的判断）<ul>\n<li>改进型——增加对修改位M思维判断</li>\n</ul>\n</li>\n<li>页面缓冲算法（PBA,page buffering algorithm）<ul>\n<li>空闲页面链表</li>\n<li>修改页面链表</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第六章：输入输出系统\"><a href=\"#第六章：输入输出系统\" class=\"headerlink\" title=\"第六章：输入输出系统\"></a>第六章：输入输出系统</h2><h3 id=\"I-O系统的功能，模型和接口\"><a href=\"#I-O系统的功能，模型和接口\" class=\"headerlink\" title=\"I&#x2F;O系统的功能，模型和接口\"></a>I&#x2F;O系统的功能，模型和接口</h3><ul>\n<li>I&#x2F;O系统管理的对象是I&#x2F;O设备和相应的设备控制器。</li>\n<li>I&#x2F;O系统的基本功能<ul>\n<li>隐藏物理设备的细节</li>\n<li>与设备的无关性</li>\n<li>提高处理机和I&#x2F;O设备的利用率</li>\n<li>对I&#x2F;O设备进行控制</li>\n<li>确保对设备的正确共享</li>\n<li>错误处理</li>\n</ul>\n</li>\n<li>I&#x2F;O软件的层次结构<ul>\n<li>用户层I&#x2F;O软件</li>\n<li>设备独立性软件</li>\n<li>设备驱动程序（厂家开发）</li>\n<li>中断处理程序</li>\n<li>硬件</li>\n</ul>\n</li>\n<li>I&#x2F;O系统的分层<ul>\n<li>中断处理程序</li>\n<li>设备驱动程序</li>\n<li>设备独立性软件</li>\n</ul>\n</li>\n<li>I&#x2F;O系统接口<ul>\n<li>块设备接口<ul>\n<li>指以数据块为单位来组织和传送数据信息的设备</li>\n<li>典型的块设备是磁盘、光盘</li>\n<li>块设备的基本特征<ul>\n<li>①传输速率较高，通常每秒钟为几兆位；</li>\n<li>②它是可寻址的，即可随机地读&#x2F;写任意一块；</li>\n<li>③磁盘设备的I&#x2F;O采用DMA方式。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>流设备接口<ul>\n<li>又称字符设备指以单个字符为单位来传送数据信息的设备</li>\n<li>这类设备一般用于数据的输入和输出，有交互式终端、打印机</li>\n<li>字符设备的基本特征<ul>\n<li>①传输速率较低；</li>\n<li>②不可寻址，即不能指定输入时的源地址或输出时的目标地址；</li>\n<li>③字符设备的I&#x2F;O常采用中断驱动方式。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>网络通信接口<ul>\n<li>提供网络接入功能，使计算机能通过网络与其他计算机进行通信或上网浏览。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"I-O设备和设备控制器\"><a href=\"#I-O设备和设备控制器\" class=\"headerlink\" title=\"I&#x2F;O设备和设备控制器\"></a>I&#x2F;O设备和设备控制器</h3><ul>\n<li>分类<ul>\n<li>使用特性分<ul>\n<li>存储设备</li>\n<li>I&#x2F;O设备</li>\n</ul>\n</li>\n<li>传输速率分<ul>\n<li>低速设备（几字节——几百字节）<ul>\n<li>典型的设备有键盘、鼠标、语音的输入</li>\n</ul>\n</li>\n<li>中速设备（数千——数万字节）<ul>\n<li>典型的设备有行式打印机、激光打印机</li>\n</ul>\n</li>\n<li>高速设备（数十万——千兆字节）<ul>\n<li>典型的设备有磁带机、磁盘机、光盘机</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>设备并不是直接与CPU进行通信，而是与设备控制器通信。在设备与设备控制器之间应该有一个接口。<ul>\n<li>数据信号：控制器 ←  设备 ←  控制器<ul>\n<li>传送数据信号，输入、输出bit</li>\n</ul>\n</li>\n<li>控制信号: 控制器  →  设备<ul>\n<li>执行读、写操作的信号</li>\n</ul>\n</li>\n<li>状态信号：设备当前使用状态</li>\n</ul>\n</li>\n<li>设备控制器<ul>\n<li>主要功能：控制一个或多个I&#x2F;O设备，以实现I&#x2F;O设备和计算机之间的数据交换</li>\n<li>基本功能<ul>\n<li>接收和识别命令<ul>\n<li>控制寄存器、命令译码器</li>\n</ul>\n</li>\n<li>数据交换<ul>\n<li>实现CPU与控制器，控制器与设备间的数据交换</li>\n</ul>\n</li>\n<li>标识和报告设备的状态</li>\n<li>地址识别<ul>\n<li>配置地址译码器，识别不同的设备</li>\n</ul>\n</li>\n<li>数据缓冲区</li>\n<li>差错控制</li>\n</ul>\n</li>\n<li>设备控制器的组成<ul>\n<li>设备控制器与处理机（CPU）的接口<ul>\n<li>实现CPU与设备控制器之间的通信</li>\n</ul>\n</li>\n<li>设备控制器与设备的接口<ul>\n<li>控制器可连接多个设备</li>\n</ul>\n</li>\n<li>I&#x2F;O逻辑<ul>\n<li>实现对设备的控制</li>\n<li>CPU利用该逻辑向控制器发送I&#x2F;O命令</li>\n<li>命令、地址译码</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>内存映像I&#x2F;O<ul>\n<li>驱动程序将抽象I&#x2F;O命令转换出的一系列具体的命令，参数等数据装入设备控制器的相应寄存器，由控制器来执行这些命令，具体实施对I&#x2F;O设备的操作</li>\n</ul>\n</li>\n<li>I&#x2F;O通道<ul>\n<li><p>目的：建立独立的I&#x2F;O操作(组织, 管理和结束)，使由CPU处理的I&#x2F;O工作转由通道完成（解放CPU，实现并行）</p>\n</li>\n<li><p>什么是I&#x2F;O通道？</p>\n<ul>\n<li>是一种特殊的处理机，具有通过执行通道程序完成I&#x2F;O操作的指令</li>\n<li>特点：指令单一(局限于与I&#x2F;O操作相关的指令)，与CPU共享内存</li>\n</ul>\n</li>\n<li><p>基本过程：</p>\n<ul>\n<li>CPU向通道发出I&#x2F;O指令-&gt;通道接收指令-&gt;从内存取出通道程序处理I&#x2F;O-&gt;向CPU发出中断</li>\n</ul>\n</li>\n<li><p>通道类型</p>\n<ul>\n<li>字节多路通道<ul>\n<li>低中速连接子通道时间片轮转方式共享主通道</li>\n<li>字节多路通道不适于连接高速设备，这推动了按数组方式进行数据传送的数组选择通道的形成。</li>\n</ul>\n</li>\n<li>数组选择通道<ul>\n<li>这种通道可以连接多台高速设备，但只含有一个分配型子通道，在一段时间内只能执行一道通道程序， 控制一台设备进行数据传送， 直至该设备传送完毕释放该通道。这种通道的利用率很低。</li>\n</ul>\n</li>\n<li>数组多路通道<ul>\n<li>含有多个非分配型子通道，前两种通道的组合，通道利用率较好</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>瓶颈问题</p>\n<ul>\n<li>原因;通道不足</li>\n<li>解决办法：增加设备到主机间的通路，而不增加通道（结果类似RS触发器）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"中断机构和中断处理程序\"><a href=\"#中断机构和中断处理程序\" class=\"headerlink\" title=\"中断机构和中断处理程序\"></a>中断机构和中断处理程序</h3><ul>\n<li>中断<ul>\n<li>分类<ul>\n<li>中断（外部触发）<ul>\n<li>对外部I&#x2F;O设备发出的中断信号的响应</li>\n</ul>\n</li>\n<li>陷入（内部原因：除0）<ul>\n<li>由CPU内部事件引起的中断</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>中断向量表（类比51单片机）<ul>\n<li>中断程序的入口地址表</li>\n</ul>\n</li>\n<li>中断优先级<ul>\n<li>对紧急程度不同的中断处理方式</li>\n</ul>\n</li>\n<li>对多中断源的处理方式<ul>\n<li>屏蔽中断</li>\n<li>嵌套中断</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>中断处理程序<ul>\n<li>测定是否有未响应的中断信号</li>\n<li>保护被中断进程的CPU环境</li>\n<li>转入相应的设备处理程序</li>\n<li>中断处理</li>\n<li>恢复CPU 的现场并退出中断</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"设备驱动程序\"><a href=\"#设备驱动程序\" class=\"headerlink\" title=\"设备驱动程序\"></a>设备驱动程序</h3><ul>\n<li>是I&#x2F;O进程与设备控制器之间的通信程序，又由于它常以进程的形式存在，故以后就简称为设备驱动进程</li>\n<li>主要任务是接受来自它上一层的与设备无关软件的抽象请求，并执行这个请求。</li>\n<li>功能<ul>\n<li><ol>\n<li>接收由I&#x2F;O进程发来的命令和参数， 并将命令中的抽象要求转换为具体要求。例如，将磁盘块号转换为磁盘的盘面、 磁道号及扇区号。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>检查用户I&#x2F;O请求的合法性，了解I&#x2F;O设备的状态，传递有关参数，设置设备的工作方式。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>发出I&#x2F;O命令，如果设备空闲，便立即启动I&#x2F;O设备去完成指定的I&#x2F;O操作；如果设备处于忙碌状态，则将请求者的请求块挂在设备队列上等待。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>对于设置有通道的计算机系统，驱动程序还应能够根据用户的I&#x2F;O请求，自动地构成通道程序。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>设备驱动程序的处理过程<ul>\n<li>将用户和上层软件对设备控制的抽象要求转换成对设备的具体要求，如对抽象要求的盘块号转换为磁盘的盘面、磁道及扇区。</li>\n<li>检查I&#x2F;O请求的合理性。</li>\n<li>读出和检查设备的状态，确保设备处于就绪态。</li>\n<li>传送必要的参数，如传送的字节数，数据在主存的首址等。</li>\n<li>工作方式的设置。</li>\n<li>启动I&#x2F;O设备，并检查启动是否成功，如成功则将控制返回给I&#x2F;O控制系统，在I&#x2F;O设备忙于传送数据时，该用户进程把自己阻塞，直至中断到来才将它唤醒，而CPU可干别的事。</li>\n</ul>\n</li>\n<li>对I&#x2F;O设备的控制方式<ul>\n<li>I&#x2F;O控制的宗旨<ul>\n<li>减少CPU对I&#x2F;O控制的干预</li>\n<li>充分利用CPU完成数据处理工作</li>\n</ul>\n</li>\n<li>I&#x2F;O 控制方式<ul>\n<li>轮询的可编程I&#x2F;O方式</li>\n<li>中断驱动I&#x2F;O方式</li>\n<li>DMA控制方式</li>\n<li>I&#x2F;O通道控制方式</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>DMA控制器组成<ul>\n<li>主机与DMA控制器的接口</li>\n<li>DMA控制器与块设备的接口</li>\n<li>I&#x2F;O控制逻辑</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"与设备无关的I-O软件\"><a href=\"#与设备无关的I-O软件\" class=\"headerlink\" title=\"与设备无关的I&#x2F;O软件\"></a>与设备无关的I&#x2F;O软件</h3><ul>\n<li>基本概念<ul>\n<li>含义： 应用程序独立于具体使用的物理设备。</li>\n<li>驱动程序是一个与硬件(或设备)紧密相关的软件。为实现设备独立性，须在驱动程序上设置一层软件，称为设备独立性软件。</li>\n<li>设备独立性(Device Independence)的优点<ul>\n<li>以物理设备名使用设备</li>\n<li>引入了逻辑设备名</li>\n<li>逻辑设备名称到物理设备名称的转换（易于实现I&#x2F;O重定向）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>与设备无关的软件<ul>\n<li>设备驱动程序的统一接口</li>\n<li>缓存管理</li>\n<li>差错控制</li>\n<li>对独立设备的分配与回收</li>\n<li>独立于设备的逻辑数据块</li>\n</ul>\n</li>\n<li>设备分配中的数据结构<ul>\n<li>设备控制表DCT</li>\n<li>控制器控制表COCT</li>\n<li>通道控制表CHCT</li>\n<li>显然，在有通道的系统中，一个进程只有获得了通道，控制器和所需设备三者之后，才具备了进行I&#x2F;O操作的物理条件</li>\n<li>系统设备表SDT</li>\n<li>逻辑设备表LUT</li>\n<li>分配的流程，从资源多的到资源紧张的:LUT-&gt;SDT-&gt;DCT-&gt;COCT-&gt;CHCT</li>\n<li>在申请设备的过程中，根据用户请求的I&#x2F;O设备的逻辑名，查找逻辑设备和物理设备的映射表；以物理设备为索引，查找SDT，找到该设备所连接的DCT；继续查找与该设备连接的COCT和CHCT，就找到了一条通路。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"用户层的I-O软件\"><a href=\"#用户层的I-O软件\" class=\"headerlink\" title=\"用户层的I&#x2F;O软件\"></a>用户层的I&#x2F;O软件</h3><ul>\n<li>系统调用与库函数<ul>\n<li>OS向用户提供的所有功能，用户进程都必须通过系统调用来获取</li>\n<li>在C语言以及UNIX系统中，系统调用（如read）与各系统调用所使用的库函数（如read）之间几乎是一一对应的。而微软的叫Win32API</li>\n</ul>\n</li>\n<li>假脱机系统（spooling）<ul>\n<li>spooling技术是对脱机输入&#x2F;输出系统的模拟</li>\n<li>主要组成<ul>\n<li>输入&#x2F;输出井</li>\n<li>输入&#x2F;输出缓冲区</li>\n<li>输入&#x2F;输出进程</li>\n<li>井管理程序</li>\n</ul>\n</li>\n<li>特点（体现操作系统的虚拟性）<ul>\n<li>提高了I&#x2F;O的速度<ul>\n<li>对数据所进行的I&#x2F;O操作，已从对低速设备演变为对输入井或输出井中的数据存取。</li>\n</ul>\n</li>\n<li>将独占设备改造为共享设备<ul>\n<li>实际分给用户进程的不是打印设备，而是共享输出井中的存储区域</li>\n</ul>\n</li>\n<li>实现了虚拟设备功能<ul>\n<li>将独占设备变成多台独占的虚拟设备。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"缓冲区管理\"><a href=\"#缓冲区管理\" class=\"headerlink\" title=\"缓冲区管理\"></a>缓冲区管理</h3><ul>\n<li>缓冲的引入（原因）<ul>\n<li>缓和CPU与I&#x2F;O设备间速度不匹配的矛盾</li>\n<li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</li>\n<li>提高CPU和I&#x2F;O设备之间的并行性</li>\n<li>解决数据粒度不匹配的问题</li>\n</ul>\n</li>\n<li>单缓冲区<ul>\n<li>即在CPU计算的时候，将数据数据输入到缓冲区(大小取决与T和C的大小)</li>\n</ul>\n</li>\n<li>双缓冲区<ul>\n<li>即允许CPU连续工作（T不断）</li>\n</ul>\n</li>\n<li>环形缓冲区（专为生产者和消费者打造）<ul>\n<li>组成<ul>\n<li>多个缓冲区</li>\n<li>多个指针</li>\n</ul>\n</li>\n<li>使用<ul>\n<li>Getbuf过程</li>\n<li>Releasebuf过程</li>\n</ul>\n</li>\n<li>同步问题</li>\n</ul>\n</li>\n<li>缓冲池(理解为更大的缓冲区)<ul>\n<li>组成<ul>\n<li>空白缓冲队列（emq）<ul>\n<li>由空缓冲区链接而成F(emq)，L(emq)分别指向该队列首尾缓冲区</li>\n</ul>\n</li>\n<li>输入队列（inq）<ul>\n<li>由装满输入数据的缓冲区链接而成F(inq)，L(inq)分别指向该队列首尾缓冲区</li>\n</ul>\n</li>\n<li>输出队列（outq）<ul>\n<li>由装满输出数据的缓冲区链接而成F(outq)， L(outq)分别指向该队列首尾缓冲</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Getbuf和Putbuf过程<ul>\n<li>收容：缓冲池接收外界数据</li>\n<li>提取：外界从缓冲池获得数据</li>\n</ul>\n</li>\n<li>缓冲区工作方式（从缓冲区的角度来看）<ul>\n<li>收容输入</li>\n<li>提取输入</li>\n<li>收容输出</li>\n<li>提取输出</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"磁盘存储器的性能和调度\"><a href=\"#磁盘存储器的性能和调度\" class=\"headerlink\" title=\"磁盘存储器的性能和调度\"></a>磁盘存储器的性能和调度</h3><ul>\n<li>数据的组织和格式</li>\n<li>磁盘的类型<ul>\n<li>固定头磁盘（贵）</li>\n<li>移动头磁盘</li>\n</ul>\n</li>\n<li>磁盘访问的时间（关键）<ul>\n<li>寻道时间Ts&#x3D;m*n+s</li>\n<li>旋转延迟时间Tr</li>\n<li>传输时间Tt&#x3D;b&#x2F;rN</li>\n<li>总时间Ta&#x3D;Ts+1&#x2F;2r+b&#x2F;rN</li>\n</ul>\n</li>\n<li>磁盘的调度算法（掌握图表）<ul>\n<li>先来先服务（FCFS）<ul>\n<li>优点：公平，简单</li>\n<li>缺点：可能导致某些进程的请求长期得不到满足</li>\n</ul>\n</li>\n<li>最短寻道时间优先（SSTF）<ul>\n<li>说明：要求访问的磁道和当前磁头所在的磁道距离最近，以使每次的寻道时间最短</li>\n</ul>\n</li>\n<li>扫描算法（SCAN）<ul>\n<li>扫描算法不仅考虑到欲访问的磁道与当前磁道间的距离，更优先考虑的是磁道当前的移动方向</li>\n<li>联想电梯的运行</li>\n<li>可防止低优先级进程出现“饥饿”的现象</li>\n</ul>\n</li>\n<li>循环扫描算法（CSCAN）<ul>\n<li>算法规定磁头单向移动，例如，只是自里向外移动，当磁头移到最外的磁道并访问后，磁头立即返回到最里的欲访问磁道，亦即将最小磁道号紧接着最大磁道号构成循环，进行循环扫描</li>\n</ul>\n</li>\n<li>NStepScan算法<ul>\n<li>N步SCAN算法是将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次这些子队列。</li>\n</ul>\n</li>\n<li>FSCAN算法<ul>\n<li>是Nstepscan算法的简化，将磁盘请求队列分成两个子队列</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第七章：文件管理\"><a href=\"#第七章：文件管理\" class=\"headerlink\" title=\"第七章：文件管理\"></a>第七章：文件管理</h2><h3 id=\"数据项\"><a href=\"#数据项\" class=\"headerlink\" title=\"数据项\"></a>数据项</h3><ul>\n<li>基本数据项</li>\n<li>组合数据项</li>\n</ul>\n<h3 id=\"记录\"><a href=\"#记录\" class=\"headerlink\" title=\"记录\"></a>记录</h3><ul>\n<li>记录是一组相关数据项的集合，用于描述一个对象在某个方面的属性</li>\n</ul>\n<h3 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h3><ul>\n<li>文件类型</li>\n<li>文件长度</li>\n<li>文件的物理位置</li>\n<li>文件的建立时间</li>\n</ul>\n<h3 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h3><ul>\n<li>创建文件</li>\n<li>删除文件</li>\n<li>读文件</li>\n<li>写文件</li>\n<li>设置文件读写的位置</li>\n</ul>\n<h3 id=\"文件的逻辑结构\"><a href=\"#文件的逻辑结构\" class=\"headerlink\" title=\"文件的逻辑结构\"></a>文件的逻辑结构</h3><ul>\n<li>顺序文件</li>\n<li>记录寻址</li>\n<li>索引文件</li>\n<li>索引顺序文件</li>\n<li>直接文件和哈希文件</li>\n</ul>\n<h3 id=\"文件目录\"><a href=\"#文件目录\" class=\"headerlink\" title=\"文件目录\"></a>文件目录</h3><ul>\n<li>文件控制块（FCB）<ul>\n<li>文件名+inode(属性)</li>\n</ul>\n</li>\n<li>简单的文件目录<ul>\n<li>单级文件目录<ul>\n<li>查找慢</li>\n<li>不允许重名</li>\n<li>不便于实现文件共享</li>\n</ul>\n</li>\n<li>两级文件目录<ul>\n<li>提高检索速度，从M*N到M+N</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>树形结构目录<ul>\n<li>路径名<ul>\n<li>“..”是父目录</li>\n<li>“&#x2F;”是根目录</li>\n<li>区别绝对路径和相对路径（..&#x2F;…&#x2F;…&#x2F;1&#x2F;2&#x2F;3&#x2F;）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"文件共享\"><a href=\"#文件共享\" class=\"headerlink\" title=\"文件共享\"></a>文件共享</h3><ul>\n<li>有向无循环图（DAG）</li>\n<li>利用符号链接实现文件共享<ul>\n<li>实际上就是“快捷方式”</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"文件保护\"><a href=\"#文件保护\" class=\"headerlink\" title=\"文件保护\"></a>文件保护</h3><p><img src=\"https://github.com/SSHeRun/CS-Xmind-Note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png\" alt=\"picture\"></p>\n","excerpt":"","more":"<h1 id=\"计算机操作系统\"><a href=\"#计算机操作系统\" class=\"headerlink\" title=\"计算机操作系统\"></a>计算机操作系统</h1><h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><h2 id=\"一-操作系统引论\"><a href=\"#一-操作系统引论\" class=\"headerlink\" title=\"一.操作系统引论\"></a>一.操作系统引论</h2><h3 id=\"1-操作系统的目标和功能\"><a href=\"#1-操作系统的目标和功能\" class=\"headerlink\" title=\"1.操作系统的目标和功能\"></a>1.操作系统的目标和功能</h3><ul>\n<li>目标<ul>\n<li>方便性</li>\n<li>有效性<ul>\n<li>提高系统资源利用率</li>\n<li>提高系统吞吐量</li>\n</ul>\n</li>\n<li>可扩充性</li>\n<li>开放性</li>\n</ul>\n</li>\n<li>作用<ul>\n<li>OS作为用户与计算机硬件系统之间的接口<ul>\n<li>命令方式</li>\n<li>系统调用方式</li>\n<li>图标–窗口方式</li>\n</ul>\n</li>\n<li>OS实现了对计算机资源的抽象</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-操作系统的发展过程\"><a href=\"#2-操作系统的发展过程\" class=\"headerlink\" title=\"2.操作系统的发展过程\"></a>2.操作系统的发展过程</h3><ul>\n<li><p>未配置操作系统的计算机系统</p>\n<ul>\n<li><p>人工操作方式</p>\n</li>\n<li><blockquote>\n<p>用户独占全机 CPU等待人工操作 严重降低了计算机资源的利用率</p>\n</blockquote>\n</li>\n<li><p>脱机输入&#x2F;输出(Off–Line I&#x2F;O)方式</p>\n</li>\n<li><blockquote>\n<p>减少了CPU的空闲时间 提高了I&#x2F;O速度 效率仍然不理想</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>单道批处理系统</p>\n</li>\n<li><p>多道批处理系统</p>\n</li>\n<li><blockquote>\n<p>1.资源利用率高</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>2.系统吞吐量大</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>3.平均周转时间长</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>4.无交互能力</p>\n</blockquote>\n<ul>\n<li>(宏观并行，微观串行)</li>\n</ul>\n</li>\n<li><p>分时系统</p>\n</li>\n<li><blockquote>\n<p>特征:</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>1.多路性</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>2.独立性</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>3.及时性</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>4.交互性</p>\n</blockquote>\n</li>\n<li><p>实时系统</p>\n</li>\n<li><p>集群系统–超算~云计算</p>\n</li>\n<li><p>微机操作系统的发展</p>\n</li>\n</ul>\n<h3 id=\"3-操作系统的基本特征\"><a href=\"#3-操作系统的基本特征\" class=\"headerlink\" title=\"3.操作系统的基本特征\"></a>3.操作系统的基本特征</h3><ul>\n<li><p>1.并发concurrence</p>\n<ul>\n<li>区别并行和并发</li>\n<li><blockquote>\n<p>并行性是指两个或多个事件在同一时刻发生→宏观并行，微观并行</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>并发性是指两个或多个事件在同一时间间隔内发生→宏观并行，微观串行</p>\n</blockquote>\n<ul>\n<li>并发是进程宏观一起运行，微观上交替运行，而并行是指同时运行</li>\n</ul>\n</li>\n<li>引入进程</li>\n<li><blockquote>\n<p>进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令，数据和堆栈等组成的，是一个能独立运行的活动实体</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>2.共享sharing</p>\n<ul>\n<li>1.互斥共享方式</li>\n<li>2.同时访问方式</li>\n<li>并发和共享是多用户(多任务)OS的两个最基本的特征。它们又是互为存在的条件</li>\n</ul>\n</li>\n<li><p>3.虚拟virtual</p>\n<ul>\n<li>时分复用技术</li>\n<li>空分复用技术</li>\n</ul>\n</li>\n<li><p>4.异步asynchronism</p>\n</li>\n</ul>\n<h3 id=\"4-操作系统的主要功能\"><a href=\"#4-操作系统的主要功能\" class=\"headerlink\" title=\"4.操作系统的主要功能\"></a>4.操作系统的主要功能</h3><ul>\n<li>1.处理机管理功能<ul>\n<li>进程控制</li>\n<li>进程同步<ul>\n<li>进程互斥方式</li>\n<li>进程同步方式(协同)</li>\n</ul>\n</li>\n<li>进程通信</li>\n<li>调度<ul>\n<li>作业调度</li>\n<li>进程调度</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>2.存储器管理功能<ul>\n<li>内存分配<ul>\n<li>静态分配</li>\n<li>动态分配</li>\n</ul>\n</li>\n<li>内存保护</li>\n<li>地址映射</li>\n<li>内存扩充</li>\n</ul>\n</li>\n<li>3.设备管理功能<ul>\n<li>缓冲管理</li>\n<li>设备分配</li>\n<li>设备处理<ul>\n<li>设备处理程序又称设备驱动程序</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>4.文件管理功能<ul>\n<li>文件存储空间的管理</li>\n<li>目录管理</li>\n<li>文件的读写管理和保护</li>\n</ul>\n</li>\n<li>5.操作系统与用户之间的接口<ul>\n<li>用户接口</li>\n<li>程序接口</li>\n</ul>\n</li>\n<li>6.现代操作系统的新功能<ul>\n<li>系统安全</li>\n<li>网络的功能和服务</li>\n<li>支持多媒体</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-OS结构设计\"><a href=\"#5-OS结构设计\" class=\"headerlink\" title=\"5.OS结构设计\"></a>5.OS结构设计</h3><ul>\n<li>传统操作系统结构<ul>\n<li>无结构操作系统</li>\n<li>模块化OS</li>\n<li>分层式结构OS</li>\n</ul>\n</li>\n<li>微内核os结构<ul>\n<li>客户&#x2F;服务器模式</li>\n<li>面对对象的程序设计</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二章进程的描述与控制\"><a href=\"#第二章进程的描述与控制\" class=\"headerlink\" title=\"第二章进程的描述与控制\"></a>第二章进程的描述与控制</h2><h3 id=\"前驱图和程序执行\"><a href=\"#前驱图和程序执行\" class=\"headerlink\" title=\"前驱图和程序执行\"></a>前驱图和程序执行</h3><h3 id=\"程序并发执行\"><a href=\"#程序并发执行\" class=\"headerlink\" title=\"程序并发执行\"></a>程序并发执行</h3><ul>\n<li>程序的并发执行</li>\n<li>程序并发执行时的特征<ul>\n<li>间断性</li>\n<li>失去封闭性</li>\n<li>不可再现性</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进程的描述\"><a href=\"#进程的描述\" class=\"headerlink\" title=\"进程的描述\"></a>进程的描述</h3><ul>\n<li>进程的定义<ul>\n<li>进程是程序的一次执行</li>\n<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li>\n<li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li>\n</ul>\n</li>\n<li>进程的特征<ul>\n<li>动态性</li>\n<li>并发性</li>\n<li>独立性</li>\n<li>异步性</li>\n</ul>\n</li>\n<li>从操作系统角度分类<ul>\n<li>系统进程</li>\n<li>用户进程</li>\n</ul>\n</li>\n<li>进程和程序的区别<ul>\n<li>进程是动态概念，而程序则是静态概念</li>\n<li>程序是指令的有序集合，永远存在；进程强调是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；</li>\n<li>进程具有并发性，而程序没有</li>\n<li>进程可创建其他进程，而程序并不能形成新的程序</li>\n<li>进程是竞争计算机资源的基本单位，程序不是</li>\n</ul>\n</li>\n<li>进程和程序的联系<ul>\n<li>进程是程序在数据集上的一次执行</li>\n<li>程序是构成进程的组成部分，一个程序可对应多个进程，一个进程可包括多个程序</li>\n<li>进程的运行目标是执行所对应的程序</li>\n<li>从静态看，进程由程序、数据和进程控制块（PCB）组成</li>\n</ul>\n</li>\n<li>进程的基本状态及转换<ul>\n<li>进程的三种基本状态<ul>\n<li>就绪状态ready</li>\n<li>执行状态running</li>\n<li>阻塞状态block</li>\n</ul>\n</li>\n<li>三种基本状态的转换</li>\n<li>创建状态和终止状态<ul>\n<li>五状态进程模型</li>\n</ul>\n</li>\n<li>注意<ul>\n<li>阻塞态-&gt;运行态和就绪态-&gt;阻塞态这二种状态转换不可能发生</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>挂起操作和进程状态的转换<ul>\n<li>挂起和阻塞的区别</li>\n<li>挂起操作的目的<ul>\n<li>终端用户的需要: 修改、检查进程</li>\n<li>父进程的需要：修改、协调子进程</li>\n<li>对换的需要：缓和内存</li>\n<li>负荷调节的需要：保证实时任务的执行</li>\n</ul>\n</li>\n<li>关键图</li>\n</ul>\n</li>\n<li>进程管理中的数据结构<ul>\n<li>进程控制块PCB的作用<ul>\n<li>作为独立运行基本单位的标志</li>\n<li>能实现间断性运行方式</li>\n<li>提供进程管理所需要的信息</li>\n<li>提供进程调度所需要的信息</li>\n<li>实现与其他进程的同步与通信</li>\n</ul>\n</li>\n<li>进程控制块的信息<ul>\n<li>进程标识符<ul>\n<li>外部标识符PID</li>\n<li>内部标识符(端口)</li>\n</ul>\n</li>\n<li>处理机状态<ul>\n<li>通用寄存器</li>\n<li>指令计数器</li>\n<li>程序状态字PSW</li>\n<li>用户栈指针</li>\n</ul>\n</li>\n<li>进程调度信息<ul>\n<li>进程状态</li>\n<li>进程优先级</li>\n<li>进程调度所需的其他信息</li>\n<li>事件</li>\n</ul>\n</li>\n<li>进程控制信息<ul>\n<li>程序和数据的地址</li>\n<li>进程同步和通信机制</li>\n<li>资源清单</li>\n<li>链接指针</li>\n</ul>\n</li>\n<li>进程控制块的组织方式<ul>\n<li>线性方式</li>\n<li>链接方式</li>\n<li>索引方式</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h3><ul>\n<li>操作系统内核<ul>\n<li>两大功能<ul>\n<li>支撑功能<ul>\n<li>中断管理</li>\n<li>时钟管理</li>\n<li>原语操作<ul>\n<li>进程的管理，由若干原语（primitive）来执行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>资源管理功能<ul>\n<li>进程管理</li>\n<li>存储器管理</li>\n<li>设备管理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>状态<ul>\n<li>系统态，管态，内核态</li>\n<li>用户态，目态</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>进程的创建<ul>\n<li>进程的层次结构<ul>\n<li>父进程</li>\n<li>子进程</li>\n</ul>\n</li>\n<li>引起创建进程的事件<ul>\n<li>用户登录</li>\n<li>作业调度</li>\n<li>提供服务</li>\n<li>应用请求</li>\n</ul>\n</li>\n<li>进程的创建过程<ul>\n<li>1.申请空白PCB</li>\n<li>2.为新进程分配其运行所需的资源</li>\n<li>3.初始化进程块PCB</li>\n<li>4.如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列</li>\n</ul>\n</li>\n<li>进程的终止<ul>\n<li>引起进程终止的事件<ul>\n<li>1.正常结束</li>\n<li>2.异常结束</li>\n<li>3.外界干预</li>\n</ul>\n</li>\n<li>进程的终止过程<ul>\n<li>1.根据被终止进程的标识符</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>进程的阻塞与唤醒<ul>\n<li>引起进程阻塞和唤醒的事件<ul>\n<li>请求系统服务而未满足</li>\n<li>启动某种操作而阻塞当前进程</li>\n<li>新数据尚未到达</li>\n<li>无新工作可做：系统进程</li>\n</ul>\n</li>\n<li>进程阻塞过程(自己阻塞自己)</li>\n<li>进程唤醒过程(系统或其他进程唤醒自己)</li>\n</ul>\n</li>\n<li>进程的挂起与激活<ul>\n<li>suspend</li>\n<li>active</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>进程同步<ul>\n<li>基本概念<ul>\n<li>两种形式的制约关系<ul>\n<li>间接相互制约关系<ul>\n<li>互斥——竞争</li>\n</ul>\n</li>\n<li>直接相互制约关系<ul>\n<li>同步——协作</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>临界资源</li>\n<li>分区<ul>\n<li>进入区enter section</li>\n<li>临界区critical section</li>\n<li>退出区exit section</li>\n<li>剩余区remainder section</li>\n</ul>\n</li>\n<li>同步机制应遵循的规则<ul>\n<li>1.空闲让进</li>\n<li>2.忙则等待</li>\n<li>3.有限等待</li>\n<li>4.让权等待</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>进程同步机制<ul>\n<li>软件同步机制:都没有解决让权等待，而且部分方法还会产生死锁的情况</li>\n<li>硬件同步机制<ul>\n<li>关中断</li>\n<li>利用Test-and-Set指令实现互斥</li>\n<li>利用swap指令实现进程互斥</li>\n</ul>\n</li>\n<li>信号量机制<ul>\n<li>整型信号量</li>\n<li>记录型信号量<ul>\n<li>由于整型信号量没有遵循让权等待原则，记录型允许负数，即阻塞链表</li>\n</ul>\n</li>\n<li>AND型信号量</li>\n<li>信号量集<ul>\n<li>理解:AND型号量的wait和signal仅能对信号施以加1或减1操作，意味着每次只能对某类临界资源进行一个单位的申请或释放。当一次需要N个单位时，便要进行N次wait操作，这显然是低效的，甚至会增加死锁的概率。此外，在有些情况下，为确保系统的安全性，当所申请的资源数量低于某一下限值时，还必须进行管制，不予以分配。因此，当进程申请某类临界资源时，在每次分配前，都必须测试资源数量，判断是否大于可分配的下限值，决定是否予以分配</li>\n<li>操作<ul>\n<li>Swait(S1，t1，d1…Sn，tn，dn)</li>\n<li>Ssignal(S1，d1…Sn，dn)</li>\n</ul>\n</li>\n<li>特殊情况</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>经典进程的同步问题<ul>\n<li>生产者–消费者问题</li>\n<li>哲学家进餐问题</li>\n<li>读者–写者问题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h3><ul>\n<li>进程通信是指进程之间的信息交换，又称低级进程通信</li>\n<li>进程通信的类型<ul>\n<li>共享存储器系统<ul>\n<li>基于共享数据结构的通信方式<ul>\n<li>生产者和消费者</li>\n</ul>\n</li>\n<li>基于共享存储区的通信方式<ul>\n<li>高级通信</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>管道通信系统(pipe)<ul>\n<li>高级通信</li>\n</ul>\n</li>\n<li>消息传递系统<ul>\n<li>高级通信</li>\n<li>方式分类<ul>\n<li>直接通信</li>\n<li>间接通信</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>客服机–服务器系统</li>\n</ul>\n</li>\n<li>消息传递通信的实现方式<ul>\n<li>直接消息传递系统</li>\n<li>信箱通信</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程的基本概念\"><a href=\"#线程的基本概念\" class=\"headerlink\" title=\"线程的基本概念\"></a>线程的基本概念</h3><ul>\n<li>线程的引入<ul>\n<li>线程的引入正是为了简化线程间的通信，以小的开销来提高进程内的并发程度</li>\n<li>多线程并发的不足<ul>\n<li>进程的两个基本属性<ul>\n<li>一个拥有资源的独立单位，可独立分配系统资源</li>\n<li>一个可独立调度和分派的基本单位，PCB</li>\n</ul>\n</li>\n<li>程序并发执行所需付出的时空开销<ul>\n<li>创建进程</li>\n<li>撤销进程</li>\n<li>进程切换</li>\n</ul>\n</li>\n<li>进程间通信效率低</li>\n<li>将分配资源和调度两个属性分开</li>\n</ul>\n</li>\n<li>线程——作为调度和分派的基本单位<ul>\n<li>进程是系统资源分配的单位，线程是处理器调度的单位</li>\n<li>线程表示进程的一个控制点，可以执行一系列的指令。通常，和应用程序的一个函数相对应</li>\n<li>进程分解为线程还可以有效利用多处理器和多核计算机</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>线程与进程的比较<ul>\n<li>不同点<ul>\n<li>调度的基本单位</li>\n<li>并发性</li>\n</ul>\n</li>\n<li>相似点<ul>\n<li>状态：运行、阻塞、就绪</li>\n<li>线程具有一定的生命期</li>\n<li>进程可创建线程，一个线程可创建另一个子线程</li>\n<li>多个线程并发执行时仍然存在互斥与同步</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>线程的实现<ul>\n<li>线程的实现方式<ul>\n<li>内核支持线程KST</li>\n<li>用户级线程ULT</li>\n<li>组合方式</li>\n</ul>\n</li>\n<li>多线程OS中的进程属性<ul>\n<li>进程是一个可拥有资源的基本单位</li>\n<li>多个线程可并发执行</li>\n<li>进程已不是可执行的实体</li>\n</ul>\n</li>\n<li>线程的状态和线程控制块<ul>\n<li>线程运行的三个状态<ul>\n<li>执行状态</li>\n<li>就绪状态</li>\n<li>阻塞状态</li>\n</ul>\n</li>\n<li>线程控制块TCB</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第三章-处理机调度与死锁\"><a href=\"#第三章-处理机调度与死锁\" class=\"headerlink\" title=\"第三章:处理机调度与死锁\"></a>第三章:处理机调度与死锁</h2><h3 id=\"处理机调度算法的目标\"><a href=\"#处理机调度算法的目标\" class=\"headerlink\" title=\"处理机调度算法的目标\"></a>处理机调度算法的目标</h3><ul>\n<li>处理机调度算法的共同目标<ul>\n<li>资源利用率:CPU的利用率&#x3D;CPU有效工作时间&#x2F;(CPU有效工作时间+CPU空闲等待时间)</li>\n<li>公平性</li>\n<li>平衡性</li>\n<li>策略强制执行</li>\n</ul>\n</li>\n<li>批处理系统的目标<ul>\n<li>平均周转时间短</li>\n<li>系统吞吐量高</li>\n<li>处理机利用率高</li>\n</ul>\n</li>\n<li>分时系统的目标<ul>\n<li>响应时间快</li>\n<li>均衡性</li>\n</ul>\n</li>\n<li>实时系统目标<ul>\n<li>截止时间的保证</li>\n<li>可预测性</li>\n</ul>\n</li>\n<li>处理机调度的层次<ul>\n<li>高级调度（作业调度）<ul>\n<li>分时系统无需作业调度，因为需要交互</li>\n<li>批处理系统需要作业调度</li>\n</ul>\n</li>\n<li>中级调度（和挂起有关）</li>\n<li>低级调度（进程调度）<ul>\n<li>进程调度是最基本的调度，任何操作系统都有进程调度。</li>\n<li>低级调度的三个基本机制<ul>\n<li>排队器</li>\n<li>分派器</li>\n<li>上下文切换</li>\n</ul>\n</li>\n<li>进程调度方式<ul>\n<li>非抢占方式</li>\n<li>抢占方式<ul>\n<li>优先权原则</li>\n<li>短进程优先原则</li>\n<li>时间片原则</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>进程调度的任务<ul>\n<li>保存处理机的现场信息</li>\n<li>按某种算法选取进程</li>\n<li>把处理器分配给进程</li>\n</ul>\n</li>\n<li>进程调度的算法<ul>\n<li>优先级调度算法<ul>\n<li>优先级调度算法的类型<ul>\n<li>非抢占式优先级调度算法<ul>\n<li>等当前进程执行完以后，再执行另一个优先权最高的进程</li>\n<li>这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</li>\n</ul>\n</li>\n<li>抢占式优先级调度算法<ul>\n<li>不等当前进程结束，直接抢处理机</li>\n<li>常用于要求比较严格的实时系统中， 以及对性能要求较高的批处理和分时系统中。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>优先级的类型<ul>\n<li>静态优先级<ul>\n<li>优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，例如，0<del>7或0</del>255中的某一整数， 又把该整数称为优先数。</li>\n<li>可以参考BIOS系统中设置boot的优先级</li>\n</ul>\n</li>\n<li>动态优先级<ul>\n<li>在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>轮转调度算法<ul>\n<li>基本原理:在轮转(RR)法中，系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并可设置每隔一定时间间隔(如30ms)即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其执行</li>\n<li>进程切换时机<ul>\n<li>时间片未用完，进程完成</li>\n<li>时间片到，进程未完成</li>\n</ul>\n</li>\n<li>时间片大小的确定<ul>\n<li>太小利于短作业，增加系统切换开销</li>\n<li>太长就退化为FCFS算法</li>\n<li>一般选择: q略大于一次交互所需要的时间，使大多数进程在一个时间片内完成</li>\n</ul>\n</li>\n<li>一般来说，平均周转时间将比SJF长，但是有较好的响应时间</li>\n</ul>\n</li>\n<li>多队列调度算法</li>\n<li>多级反馈队列调度算法<ul>\n<li>调度机制<ul>\n<li>设置多个就绪队列</li>\n<li>每个队列都采用FCFS算法</li>\n<li>按照队列优先级调度，在第n队列中采取按时间片轮转的方式运行</li>\n</ul>\n</li>\n<li>调度算法的性能<ul>\n<li>对于终端型用户，由于作业小，感觉满意</li>\n<li>对于短批处理作业用户，周转时间也较小</li>\n<li>长批处理作业用户，也能够得到执行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>基于公平原则的调度算法<ul>\n<li>保证调度算法</li>\n<li>公平分享调度算法</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"作业与作业调度\"><a href=\"#作业与作业调度\" class=\"headerlink\" title=\"作业与作业调度\"></a>作业与作业调度</h3><ul>\n<li>作业<ul>\n<li>作业不仅包含程序和数据，还配有一份作业说明书，系统根据说明书对程序的运行进行控制。批处理系统是以作业为单位从外存掉入内存的。</li>\n</ul>\n</li>\n<li>作业控制块JCB<ul>\n<li>为每个作业设置一个JCB，保存了对作业管理调度的全部信息。是作业存在的标志。</li>\n</ul>\n</li>\n<li>作业步<ul>\n<li>作业步，每个作业都必须经过若干相对独立，有相互关联的顺序步骤才能得到结果。每一个步骤就是一个作业步。</li>\n</ul>\n</li>\n<li>作业运行的三个阶段<ul>\n<li>收容阶段</li>\n<li>运行阶段</li>\n<li>完成阶段</li>\n</ul>\n</li>\n<li>作业运行的三个状态<ul>\n<li>后备状态</li>\n<li>运行状态</li>\n<li>完成状态</li>\n</ul>\n</li>\n<li>作业调度的主要任务<ul>\n<li>接纳多少个作业</li>\n<li>接纳哪些作业</li>\n</ul>\n</li>\n<li>先来先服务(first–come first–served，FCFS)调度算法<ul>\n<li>比较有利于长作业，而不利于短作业。</li>\n<li>有利于CPU繁忙的作业，而不利于I&#x2F;O繁忙的作业。</li>\n</ul>\n</li>\n<li>短作业优先(short job first，SJF)的调度算法<ul>\n<li>优点<ul>\n<li>比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；</li>\n<li>提高系统的吞吐量；</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>必须预知作业的运行时间</li>\n<li>对长作业非常不利，长作业的周转时间会明显地增长</li>\n<li>在采用SJF算法时，人–机无法实现交互</li>\n<li>该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>优先级调度算法(priority–scheduling algorithm，PSA)</li>\n<li>高响应比优先调度算法(Highest Response Ratio Next,HRRN)<ul>\n<li>原理<ul>\n<li>在每次选择作业投入运行时，先计算此时后备作业队列中每个作业的响应比RP然后选择其值最大的作业投入运行</li>\n<li>优先权&#x3D;(等待时间+要求服务时间)&#x2F;要求服务时间&#x3D;响应时间&#x2F;要求服务时间&#x3D;1+等待时间&#x2F;要求服务时间</li>\n</ul>\n</li>\n<li>特点<ul>\n<li>如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而类似于SJF算法，有利于短作业</li>\n<li>当要求服务的时间相同时，作业的优先权又决定于其等待时间，因而该算法又类似于FCFS算法</li>\n<li>对于长时间的优先级，可以为随等待时间的增加而提高，当等待时间足够长时，也可获得处理机</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"实时调度-HRT和SRT任务\"><a href=\"#实时调度-HRT和SRT任务\" class=\"headerlink\" title=\"实时调度(HRT和SRT任务)\"></a>实时调度(HRT和SRT任务)</h3><ul>\n<li>实现实时调度的基本条件<ul>\n<li>提供必要信息<ul>\n<li>就绪时间</li>\n<li>开始截止时间和完成截止时间</li>\n<li>处理时间</li>\n<li>资源要求</li>\n<li>优先级</li>\n</ul>\n</li>\n<li>系统处理能力强<ul>\n<li>∑(Ci&#x2F;Pi)≤1</li>\n<li>N个处理机:∑(Ci&#x2F;Pi)≤N</li>\n</ul>\n</li>\n<li>采用抢占式调度机制</li>\n<li>具有快速切换机制<ul>\n<li>对中断的快速响应能力</li>\n<li>快速的任务分派能力</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>实时调度算法的分类<ul>\n<li>非抢占式调度算法<ul>\n<li>非抢占式轮转调度算法</li>\n<li>非抢占式优先调度算法</li>\n</ul>\n</li>\n<li>抢占式调度算法<ul>\n<li>基于时钟中断的抢占式优先级调度算法</li>\n<li>立即抢占的优先级调度算法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>最早截止时间优先EDF(Earliest Deadline First)算法<ul>\n<li>根据任务的开始截至时间来确定任务的优先级<ul>\n<li>截至时间越早，优先级越高</li>\n</ul>\n</li>\n<li>非抢占式调度方式用于非周期实时任务</li>\n<li>抢占式调度方式用于周期实时任务</li>\n</ul>\n</li>\n<li>最低松弛度优先LLF(Least Laxity First)算法<ul>\n<li>类似EDF</li>\n<li>算法根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高， 以使之优先执行。</li>\n<li>松弛度例子<ul>\n<li>例如，一个任务在200ms时必须完成，而它本身所需的运行时间就有100ms，因此，调度程序必须在100 ms之前调度执行，该任务的紧急程度(松弛程度)为100 ms</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>优先级倒置(Priority inversion problem)<ul>\n<li>优先级倒置的形成<ul>\n<li>高优先级进程被低优先级进程延迟或阻塞。</li>\n</ul>\n</li>\n<li>优先级倒置的解决方法<ul>\n<li>简单的:假如进程P3在进入临界区后P3所占用的处理机就不允许被抢占</li>\n<li>实用的:建立在动态优先级继承基础上的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"死锁概述\"><a href=\"#死锁概述\" class=\"headerlink\" title=\"死锁概述\"></a>死锁概述</h3><ul>\n<li>资源问题<ul>\n<li>可重用性资源<ul>\n<li>计算机外设</li>\n</ul>\n</li>\n<li>消耗性资源<ul>\n<li>数据，消息</li>\n</ul>\n</li>\n<li>可抢占性资源<ul>\n<li>不引起死锁</li>\n<li>CPU，内存</li>\n</ul>\n</li>\n<li>不可抢占性资源<ul>\n<li>光驱，打印机</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>计算机系统中的死锁<ul>\n<li>竞争不可抢占性资源引起死锁</li>\n<li>竞争可消耗资源引起死锁</li>\n<li>进程推进顺序不当引起死锁</li>\n</ul>\n</li>\n<li>死锁的定义，必要条件和处理方法<ul>\n<li>定义:如果一组进程中的每一个进程都在等待仅由该进程中的其他进程才能引发的事件，那么该组进程是死锁的</li>\n<li>产生死锁的必要条件<ul>\n<li>互斥条件</li>\n<li>请求和保存条件</li>\n<li>不可抢占条件</li>\n<li>循环等待条件<ul>\n<li>如果每个资源只有一个实例，则环路等待条件是死锁存在的充分必要条件</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>处理死锁的方法<ul>\n<li>预防死锁<ul>\n<li>静态方法，在进程执行前采取的措施，通过设置某些限制条件，去破坏产生死锁的四个条件之一，防止发生死锁。</li>\n<li>预防死锁的策略<ul>\n<li>破坏”请求和保存”条件<ul>\n<li>第一种协议<ul>\n<li>所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源</li>\n<li>优点:简单，易行，安全</li>\n<li>缺点<ul>\n<li>资源被严重浪费，严重地恶化了资源的利用率</li>\n<li>使进程经常会发生饥饿现象</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>第二种协议<ul>\n<li>它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的，且已用毕的全部资源，然后再请求新的所需资源</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>破坏”不可抢占”条件<ul>\n<li>当一个已经保存了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请</li>\n</ul>\n</li>\n<li>破坏”循环等待”条件<ul>\n<li>对系统所以资源类型进行线性排序，并赋予不同的序号</li>\n<li>例如令输入机的序号为1，打印机序号为2，磁盘机序号为3等。所有进程对资源的请求必须严格按资源序号递增的次序提出。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>避免死锁<ul>\n<li>动态的方法，在进程执行过程中采取的措施，不需事先采取限制措施破坏产生死锁的必要条件，而是在进程申请资源时用某种方法去防止系统进入不安全状态，从而避免发生死锁。如银行家算法</li>\n<li>避免死锁的策略<ul>\n<li>系统安全状态<ul>\n<li>安全状态<ul>\n<li>某时刻，对于并发执行的n个进程，若系统能够按照某种顺序如&lt;p1,p2…pn&gt;来为每个进程分配所需资源，直至最大需求，从而使每个进程都可顺利完成，则认为该时刻系统处于安全状态，这样的序列为安全序列</li>\n</ul>\n</li>\n<li>安全状态之例</li>\n<li>由安全状态向不安全状态的转换</li>\n</ul>\n</li>\n<li>利用银行家算法避免死锁<ul>\n<li>含义:每一个新进程在进入系统时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给它，否则让进程等待</li>\n<li>银行家算法中的数据结构<ul>\n<li>可用资源向量 Available[m]：m为系统中资源种类数，Available[j]&#x3D;k表示系统中第j类资源数为k个。</li>\n<li>最大需求矩阵 Max[n,m]：n为系统中进程数，Max[i,j]&#x3D;k表示进程i对j类资源的最大需求数为中k。</li>\n<li>分配矩阵 Allocation[n，m]:它定义了系统中每一类资源当前已分配给每一进程资源数，   Allocation[i,j] &#x3D; k表示进程i已分得j类资源的数目为k个。</li>\n<li>需求矩阵 Need[n,m]：它表示每个进程尚需的各类资源数，Need[i,j]&#x3D;k 表示进程i   还需要j类资源k个。Need[i,j]&#x3D;Max[i,j] - Allocation[i,j]</li>\n</ul>\n</li>\n<li>银行家算法</li>\n<li>安全性算法</li>\n<li>银行家算法之例</li>\n<li>解题<ul>\n<li>矩阵</li>\n<li>列表</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>检测死锁<ul>\n<li>死锁的检测与解除<ul>\n<li>死锁的检测<ul>\n<li>资源分配图<ul>\n<li>简化步骤<ul>\n<li>选择一个没有阻塞的进程p</li>\n<li>将p移走，包括它的所有请求边和分配边</li>\n<li>重复步骤1，2，直至不能继续下去</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>死锁定理<ul>\n<li>若一系列简化以后不能使所有的进程节点都成为孤立节点</li>\n</ul>\n</li>\n<li>检测时机<ul>\n<li>当进程等待时检测死锁 （其缺点是系统的开销大）</li>\n<li>定时检测</li>\n<li>系统资源利用率下降时检测死锁</li>\n</ul>\n</li>\n<li>死锁检测中的数据结构</li>\n</ul>\n</li>\n<li>死锁的解除<ul>\n<li>抢占资源</li>\n<li>终止(或撤销)进程</li>\n<li>终止进程的方法<ul>\n<li>终止所有死锁进程</li>\n<li>逐个终止进程<ul>\n<li>代价最小<ul>\n<li>进程的优先级的大小</li>\n<li>进程已执行了多少时间，还需时间</li>\n<li>进程在运行中已经使用资源的多少，还需多少资源</li>\n<li>进程的性质是交互式还是批处理的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>付出代价最小的死锁解除算法<ul>\n<li>是使用一个有效的挂起和解除机构来挂起一些死锁的进程</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>解除死锁</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第四章-存储器管理\"><a href=\"#第四章-存储器管理\" class=\"headerlink\" title=\"第四章:存储器管理\"></a>第四章:存储器管理</h2><h3 id=\"存储器的层次结构\"><a href=\"#存储器的层次结构\" class=\"headerlink\" title=\"存储器的层次结构\"></a>存储器的层次结构</h3><ul>\n<li>多层结构的存储系统<ul>\n<li>存储器的多层结构<ul>\n<li>CPU寄存器</li>\n<li>主存</li>\n<li>辅存</li>\n</ul>\n</li>\n<li>可执行存储器<ul>\n<li>寄存器和主存的总称</li>\n<li>访问速度快，进程可以在很少的时钟周期内用一条load或store指令完成存取。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>主存储器与寄存器</li>\n<li>高速缓存和磁盘缓存</li>\n</ul>\n<h3 id=\"程序的装入和链接\"><a href=\"#程序的装入和链接\" class=\"headerlink\" title=\"程序的装入和链接\"></a>程序的装入和链接</h3><ul>\n<li>步骤<ul>\n<li>编译<ul>\n<li>源程序 -&gt;目标模块（Object modules）——–Compiler<ul>\n<li>由编译程序对用户源程序进行编译，形成若干个目标模块</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>链接<ul>\n<li>一组目标模块 -&gt;装入模块 （Load Module）———-Linker<ul>\n<li>由链接程序将编译后形成的一组目标模板以及它们所需要的库函数链接在一起，形成一个完整的装入模块</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>装入<ul>\n<li>装入模块 -&gt;内存  ——–Loader<ul>\n<li>由装入程序将装入模块装入内存</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>程序的装入<ul>\n<li>绝对装入方式<ul>\n<li>在编译时，如果知道程序将驻留在内存中指定的位置。编译程序将产生绝对地址的目标代码。</li>\n</ul>\n</li>\n<li>可重定位装入方式<ul>\n<li>在可执行文件中，列出各个需要重定位的地址单元和相对地址值。当用户程序被装入内存时，一次性实现逻辑地址到物理地址的转换，以后不再转换(一般在装入内存时由软件完成)。</li>\n<li>优点：不需硬件支持，可以装入有限多道程序。</li>\n<li>缺点：一个程序通常需要占用连续的内存空间，程序装入内存后不能移动。不易实现共享。</li>\n</ul>\n</li>\n<li>动态运行时的装入方式<ul>\n<li>动态运行时的装入程序在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换为物理地址，而是把这种地址转换推迟到程序真正要执行时才进行</li>\n<li>优点：<ul>\n<li>OS可以将一个程序分散存放于不连续的内存空间，可以移动程序，有利用实现共享。</li>\n<li>能够支持程序执行中产生的地址引用，如指针变量（而不仅是生成可执行文件时的地址引用）。</li>\n</ul>\n</li>\n<li>缺点：需要硬件支持，OS实现较复杂。</li>\n<li>它是虚拟存储的基础。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>程序的链接<ul>\n<li>静态链接方式(lib)</li>\n<li>装入时动态链接</li>\n<li>运行时动态链接(dll)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"连续分配存储管理方式\"><a href=\"#连续分配存储管理方式\" class=\"headerlink\" title=\"连续分配存储管理方式\"></a>连续分配存储管理方式</h3><ul>\n<li>连续分配<ul>\n<li>单一连续分配(DOS)</li>\n<li>固定分区分配(浪费很多空间)</li>\n<li>动态分区分配</li>\n</ul>\n</li>\n<li>地址映射和存储保护措施<ul>\n<li>基址寄存器：程序的最小物理地址</li>\n<li>界限寄存器：程序的逻辑地址范围</li>\n<li>物理地址 &#x3D; 逻辑地址 + 基址</li>\n</ul>\n</li>\n<li>内碎片：占用分区之内未被利用的空间</li>\n<li>外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）</li>\n<li>把内存划分为若干个固定大小的连续分区。固定式分区又称为静态分区。<ul>\n<li>分区大小相等：只适合于多个相同程序的并发执行（处理多个类型相同的对象）。</li>\n<li>分区大小不等：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。</li>\n<li>优点：无外碎片、易实现、开销小。</li>\n<li>缺点：<ul>\n<li>存在内碎片，造成浪费</li>\n<li>分区总数固定，限制了并发执行的程序数目。</li>\n<li>通用Os很少采用，部分控制系统中采用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>动态创建分区：指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。可变式分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。<ul>\n<li>基于顺序搜索的动态分区分配算法<ul>\n<li>首次适应算法（first fit,FF）<ul>\n<li>顺序找，找到一个满足的就分配，但是可能存在浪费</li>\n<li>这种方法目的在于减少查找时间。</li>\n<li>空闲分区表（空闲区链）中的空闲分区要按地址由低到高进行排序</li>\n</ul>\n</li>\n<li>循环首次适应算法（next fit，NF）<ul>\n<li>相对上面那种，不是顺序，类似哈希算法中左右交叉排序</li>\n<li>空闲分区分布得更均匀，查找开销小</li>\n<li>从上次找到的空闲区的下一个空闲区开始查找，直到找到第一个能满足要求的的空闲区为止，并从中划出一块与请求大小相等的内存空间分配给作业。</li>\n</ul>\n</li>\n<li>最佳适应算法（best fit，BF）<ul>\n<li>找到最合适的，但是大区域的访问次数减少</li>\n<li>这种方法能使外碎片尽量小。</li>\n<li>空闲分区表（空闲区链）中的空闲分区要按大小从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。</li>\n</ul>\n</li>\n<li>最坏适应算法（worst fit，WF）<ul>\n<li>相对于最好而言，找最大的区域下手，导致最大的区域可能很少，也造成许多碎片</li>\n<li>空闲分区按大小由大到小排序</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>基于索引搜索的动态分区分配算法<ul>\n<li>快速适应算法（quick fit）</li>\n<li>伙伴系统（buddy system）</li>\n<li>哈希算法</li>\n</ul>\n</li>\n<li>动态可重定位分区分配<ul>\n<li>紧凑</li>\n<li>动态重定位<ul>\n<li>动态运行时装入，地址转化在指令执行时进行，需获得硬件地址变换机制的支持</li>\n<li>内存地址&#x3D;相对地址+起始地址</li>\n</ul>\n</li>\n<li>动态重定位分区分配算法<ul>\n<li>1、在某个分区被释放后立即进行紧凑，系统总是只有一个连续的分区而无碎片，此法很花费机时。</li>\n<li>2、当“请求分配模块”找不到足够大的自由分区分给用户时再进行紧凑，这样紧缩的次数比上种方法少得多，但管理复杂。采用此法的动态重定位分区分配算法框图如下：</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>优点：没有内碎片。</li>\n<li>缺点：外碎片。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"对换（了解）\"><a href=\"#对换（了解）\" class=\"headerlink\" title=\"对换（了解）\"></a>对换（了解）</h3><ul>\n<li>系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。</li>\n</ul>\n<h3 id=\"基本分页存储管理方式\"><a href=\"#基本分页存储管理方式\" class=\"headerlink\" title=\"基本分页存储管理方式\"></a>基本分页存储管理方式</h3><ul>\n<li>分页存储管理的基本方式<ul>\n<li>页面<ul>\n<li>将一个进程的逻辑地址空间分成若干个大小相等的片</li>\n</ul>\n</li>\n<li>页框（frame）<ul>\n<li>内存空间分成与页面相同大小的存储块</li>\n</ul>\n</li>\n<li>由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”</li>\n<li>地址结构<ul>\n<li>页号P+位移量W(0-31)</li>\n</ul>\n</li>\n<li>页表<ul>\n<li>在分页系统中，允许将进程的各个页离散地存储在内存在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每一个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表</li>\n<li>页表的作用是实现从页面号到物理块号的地址映射</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>地址变换机构<ul>\n<li>基本的地址变换机构<ul>\n<li>要访问两次内存</li>\n<li>页表大都驻留在内存中</li>\n<li>为了实现地址变换功能，在系统中设置页表寄存器（PTR），用来存放页表的始址和页表的长度。</li>\n<li>在进程未执行时，每个进程对应的页表的始址和长度存放在进程的PCB中，当该进程被调度时，就将它们装入页表寄存器。</li>\n</ul>\n</li>\n<li>具有快表的地址变换机构<ul>\n<li>提高了效率，此处会有计算题</li>\n<li>如果页表存放在内存中，则每次访问内存时，都要先访问内存中的页表，然后根据所形成的物理地址再访问内存。这样CPU存一个数据必须访问两次内存，从而使计算机的处理速度降低了1&#x2F;2。</li>\n<li>为了提高地址变换的速度，在地址变换机构中增设了一个具有并行查询功能的特殊的高速缓冲存储器，称为“联想存储器”或“快表”，用以存放当前访问的那些页表项。</li>\n<li>地址变换过程为：<ul>\n<li>1、CPU给出有效地址</li>\n<li>2、地址变换机构自动地将页号送入高速缓存，确定所需要的页是否在快表中。</li>\n<li>3、若是，则直接读出该页所对应的物理块号，送入物理地址寄存器；</li>\n<li>4、若快表中未找到对应的页表项，则需再访问内存中的页表</li>\n<li>5、找到后，把从页表中读出的页表项存入快表中的一个寄存器单元中，以取代一个旧的页表项。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>两级和多级页表<ul>\n<li>主要是有的时候页表太多了，要化简</li>\n<li>格式：外层页号P1+外层页内地址P2+页内地址d</li>\n<li>基本方法：将页表进行分页，每个页面的大小与内存物理块的大小相同，并为它们进行编号，可以离散地将各个页面分别存放在不同的物理块中。</li>\n</ul>\n</li>\n<li>反置页表<ul>\n<li>反置页表为每一个物理块（页框）设置一个页表项，并按物理块排序，其内容则是页号和其所属进程的标识。</li>\n</ul>\n</li>\n<li>优点：<ul>\n<li>没有外碎片，每个内碎片不超过页大小。</li>\n<li>一个程序不必连续存放。</li>\n<li>便于改变程序占用空间的大小。即随着程序运行而动态生成的数据增多，地址空间可相应增长。</li>\n</ul>\n</li>\n<li>缺点：程序全部装入内存。</li>\n</ul>\n<h3 id=\"分段存储管理方式\"><a href=\"#分段存储管理方式\" class=\"headerlink\" title=\"分段存储管理方式\"></a>分段存储管理方式</h3><ul>\n<li>引入<ul>\n<li>方便编程</li>\n<li>信息共享</li>\n<li>动态增长</li>\n<li>动态链接</li>\n</ul>\n</li>\n<li>在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。</li>\n<li>内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定</li>\n<li>分段系统的基本原理<ul>\n<li>分段<ul>\n<li>格式：段号+段内地址</li>\n</ul>\n</li>\n<li>段表<ul>\n<li>段表实现了从逻辑段到物理内存区的映射。</li>\n</ul>\n</li>\n<li>地址变换机构</li>\n</ul>\n</li>\n<li>和分页的区别<ul>\n<li>页是信息的物理单位</li>\n<li>页的大小固定且由系统固定</li>\n<li>分页的用户程序地址空间是一维的</li>\n<li>通常段比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。</li>\n<li>分页是系统管理的需要，分段是用户应用的需要。一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。</li>\n</ul>\n</li>\n<li>信息共享<ul>\n<li>这是分段最重要的优点</li>\n</ul>\n</li>\n<li>段页式存储管理方式<ul>\n<li>基本原理<ul>\n<li>格式：段号（S）+段内页号（P）+页内地址（W）</li>\n</ul>\n</li>\n<li>地址变换过程<ul>\n<li>需要三次访问过程</li>\n</ul>\n</li>\n<li>在段页式系统中，为了获得一条指令或数据，需三次访问内存：第一次访问内存中的段表，从中取得页表始址；第二次访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正根据所得的物理地址取出指令或数据。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第五章：虚拟存储器\"><a href=\"#第五章：虚拟存储器\" class=\"headerlink\" title=\"第五章：虚拟存储器\"></a>第五章：虚拟存储器</h2><h3 id=\"常规存储管理方式的特征\"><a href=\"#常规存储管理方式的特征\" class=\"headerlink\" title=\"常规存储管理方式的特征\"></a>常规存储管理方式的特征</h3><ul>\n<li>一次性</li>\n<li>驻留性</li>\n</ul>\n<h3 id=\"局部性原理\"><a href=\"#局部性原理\" class=\"headerlink\" title=\"局部性原理\"></a>局部性原理</h3><ul>\n<li>程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域</li>\n<li>时间局限性<ul>\n<li>如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环操作</li>\n</ul>\n</li>\n<li>空间局限性<ul>\n<li>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><ul>\n<li>指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统</li>\n</ul>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>大程序：可在较小的可用内存中执行较大的用户程序；</li>\n<li>大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存(real memory)</li>\n<li>并发：可在内存中容纳更多程序并发执行；</li>\n<li>易于开发：不必影响编程时的程序结构</li>\n<li>以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术</li>\n</ul>\n<h3 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h3><ul>\n<li>离散性<ul>\n<li>指在内存分配时采用离散的分配方式，它是虚拟存储器的实现的基础</li>\n</ul>\n</li>\n<li>多次性<ul>\n<li>指一个作业被分成多次调入内存运行，即在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可。多次性是虚拟存储器最重要的特征</li>\n</ul>\n</li>\n<li>对换性<ul>\n<li>指允许在作业的运行过程中在内存和外存的对换区之间换进、换出。</li>\n</ul>\n</li>\n<li>虚拟性<ul>\n<li>指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"虚拟存储器的实现方式\"><a href=\"#虚拟存储器的实现方式\" class=\"headerlink\" title=\"虚拟存储器的实现方式\"></a>虚拟存储器的实现方式</h3><ul>\n<li>请求分页存储管理方式<ul>\n<li>硬件<ul>\n<li>请求页表机制<ul>\n<li>格式：页号+物理块号+状态位P+访问字段A+修改位M+外存地址</li>\n</ul>\n</li>\n<li>缺页中断机构</li>\n<li>地址变换机构（过程图很关键）</li>\n</ul>\n</li>\n<li>请求分页中的内存分配<ul>\n<li>最小物理块数<ul>\n<li>即能保证进程正常运行所需的最小物理块数</li>\n</ul>\n</li>\n<li>内存分配策略<ul>\n<li>固定分配局部置换（国王的大儿子）</li>\n<li>可变分配全局置换（国王的二儿子）</li>\n<li>可变分配局部置换（国王的小儿子）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>物理块分配算法<ul>\n<li>平均分配算法</li>\n<li>按比例分配算法</li>\n<li>考虑优先权的分配算法</li>\n</ul>\n</li>\n<li>页面调入策略<ul>\n<li>系统应在何时调入所需页面<ul>\n<li>预调页策略（不能实现）</li>\n<li>请求调页策略（需要才给）</li>\n</ul>\n</li>\n<li>系统应该从何处调入这些页面<ul>\n<li>对换区</li>\n<li>文件区</li>\n</ul>\n</li>\n<li>页面调入过程</li>\n<li>缺页率（出计算题）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>请求分段系统<ul>\n<li>硬件<ul>\n<li>请求分段的段表机构</li>\n<li>缺段中断机构</li>\n<li>地址变换机构</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"页面置换算法\"><a href=\"#页面置换算法\" class=\"headerlink\" title=\"页面置换算法\"></a>页面置换算法</h3><ul>\n<li>抖动的概念<ul>\n<li>即刚被换出的页很快又要被访问，需要将它重新调入，此时又需要再选一页调出</li>\n</ul>\n</li>\n<li>最佳置换算法(需要预知后面进程，所以不能实现)</li>\n<li>先进先出页面置换算法（FIFO）<ul>\n<li>选择在内存中驻留时间最久的页面予以淘汰</li>\n</ul>\n</li>\n<li>最近最久未使用置换算法（LRU）Recently<ul>\n<li>寄存器支持</li>\n<li>特殊的栈结构</li>\n</ul>\n</li>\n<li>最少使用置换算法（LFU）Frequently</li>\n<li>clock置换算法（对访问位A的判断）<ul>\n<li>改进型——增加对修改位M思维判断</li>\n</ul>\n</li>\n<li>页面缓冲算法（PBA,page buffering algorithm）<ul>\n<li>空闲页面链表</li>\n<li>修改页面链表</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第六章：输入输出系统\"><a href=\"#第六章：输入输出系统\" class=\"headerlink\" title=\"第六章：输入输出系统\"></a>第六章：输入输出系统</h2><h3 id=\"I-O系统的功能，模型和接口\"><a href=\"#I-O系统的功能，模型和接口\" class=\"headerlink\" title=\"I&#x2F;O系统的功能，模型和接口\"></a>I&#x2F;O系统的功能，模型和接口</h3><ul>\n<li>I&#x2F;O系统管理的对象是I&#x2F;O设备和相应的设备控制器。</li>\n<li>I&#x2F;O系统的基本功能<ul>\n<li>隐藏物理设备的细节</li>\n<li>与设备的无关性</li>\n<li>提高处理机和I&#x2F;O设备的利用率</li>\n<li>对I&#x2F;O设备进行控制</li>\n<li>确保对设备的正确共享</li>\n<li>错误处理</li>\n</ul>\n</li>\n<li>I&#x2F;O软件的层次结构<ul>\n<li>用户层I&#x2F;O软件</li>\n<li>设备独立性软件</li>\n<li>设备驱动程序（厂家开发）</li>\n<li>中断处理程序</li>\n<li>硬件</li>\n</ul>\n</li>\n<li>I&#x2F;O系统的分层<ul>\n<li>中断处理程序</li>\n<li>设备驱动程序</li>\n<li>设备独立性软件</li>\n</ul>\n</li>\n<li>I&#x2F;O系统接口<ul>\n<li>块设备接口<ul>\n<li>指以数据块为单位来组织和传送数据信息的设备</li>\n<li>典型的块设备是磁盘、光盘</li>\n<li>块设备的基本特征<ul>\n<li>①传输速率较高，通常每秒钟为几兆位；</li>\n<li>②它是可寻址的，即可随机地读&#x2F;写任意一块；</li>\n<li>③磁盘设备的I&#x2F;O采用DMA方式。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>流设备接口<ul>\n<li>又称字符设备指以单个字符为单位来传送数据信息的设备</li>\n<li>这类设备一般用于数据的输入和输出，有交互式终端、打印机</li>\n<li>字符设备的基本特征<ul>\n<li>①传输速率较低；</li>\n<li>②不可寻址，即不能指定输入时的源地址或输出时的目标地址；</li>\n<li>③字符设备的I&#x2F;O常采用中断驱动方式。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>网络通信接口<ul>\n<li>提供网络接入功能，使计算机能通过网络与其他计算机进行通信或上网浏览。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"I-O设备和设备控制器\"><a href=\"#I-O设备和设备控制器\" class=\"headerlink\" title=\"I&#x2F;O设备和设备控制器\"></a>I&#x2F;O设备和设备控制器</h3><ul>\n<li>分类<ul>\n<li>使用特性分<ul>\n<li>存储设备</li>\n<li>I&#x2F;O设备</li>\n</ul>\n</li>\n<li>传输速率分<ul>\n<li>低速设备（几字节——几百字节）<ul>\n<li>典型的设备有键盘、鼠标、语音的输入</li>\n</ul>\n</li>\n<li>中速设备（数千——数万字节）<ul>\n<li>典型的设备有行式打印机、激光打印机</li>\n</ul>\n</li>\n<li>高速设备（数十万——千兆字节）<ul>\n<li>典型的设备有磁带机、磁盘机、光盘机</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>设备并不是直接与CPU进行通信，而是与设备控制器通信。在设备与设备控制器之间应该有一个接口。<ul>\n<li>数据信号：控制器 ←  设备 ←  控制器<ul>\n<li>传送数据信号，输入、输出bit</li>\n</ul>\n</li>\n<li>控制信号: 控制器  →  设备<ul>\n<li>执行读、写操作的信号</li>\n</ul>\n</li>\n<li>状态信号：设备当前使用状态</li>\n</ul>\n</li>\n<li>设备控制器<ul>\n<li>主要功能：控制一个或多个I&#x2F;O设备，以实现I&#x2F;O设备和计算机之间的数据交换</li>\n<li>基本功能<ul>\n<li>接收和识别命令<ul>\n<li>控制寄存器、命令译码器</li>\n</ul>\n</li>\n<li>数据交换<ul>\n<li>实现CPU与控制器，控制器与设备间的数据交换</li>\n</ul>\n</li>\n<li>标识和报告设备的状态</li>\n<li>地址识别<ul>\n<li>配置地址译码器，识别不同的设备</li>\n</ul>\n</li>\n<li>数据缓冲区</li>\n<li>差错控制</li>\n</ul>\n</li>\n<li>设备控制器的组成<ul>\n<li>设备控制器与处理机（CPU）的接口<ul>\n<li>实现CPU与设备控制器之间的通信</li>\n</ul>\n</li>\n<li>设备控制器与设备的接口<ul>\n<li>控制器可连接多个设备</li>\n</ul>\n</li>\n<li>I&#x2F;O逻辑<ul>\n<li>实现对设备的控制</li>\n<li>CPU利用该逻辑向控制器发送I&#x2F;O命令</li>\n<li>命令、地址译码</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>内存映像I&#x2F;O<ul>\n<li>驱动程序将抽象I&#x2F;O命令转换出的一系列具体的命令，参数等数据装入设备控制器的相应寄存器，由控制器来执行这些命令，具体实施对I&#x2F;O设备的操作</li>\n</ul>\n</li>\n<li>I&#x2F;O通道<ul>\n<li><p>目的：建立独立的I&#x2F;O操作(组织, 管理和结束)，使由CPU处理的I&#x2F;O工作转由通道完成（解放CPU，实现并行）</p>\n</li>\n<li><p>什么是I&#x2F;O通道？</p>\n<ul>\n<li>是一种特殊的处理机，具有通过执行通道程序完成I&#x2F;O操作的指令</li>\n<li>特点：指令单一(局限于与I&#x2F;O操作相关的指令)，与CPU共享内存</li>\n</ul>\n</li>\n<li><p>基本过程：</p>\n<ul>\n<li>CPU向通道发出I&#x2F;O指令-&gt;通道接收指令-&gt;从内存取出通道程序处理I&#x2F;O-&gt;向CPU发出中断</li>\n</ul>\n</li>\n<li><p>通道类型</p>\n<ul>\n<li>字节多路通道<ul>\n<li>低中速连接子通道时间片轮转方式共享主通道</li>\n<li>字节多路通道不适于连接高速设备，这推动了按数组方式进行数据传送的数组选择通道的形成。</li>\n</ul>\n</li>\n<li>数组选择通道<ul>\n<li>这种通道可以连接多台高速设备，但只含有一个分配型子通道，在一段时间内只能执行一道通道程序， 控制一台设备进行数据传送， 直至该设备传送完毕释放该通道。这种通道的利用率很低。</li>\n</ul>\n</li>\n<li>数组多路通道<ul>\n<li>含有多个非分配型子通道，前两种通道的组合，通道利用率较好</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>瓶颈问题</p>\n<ul>\n<li>原因;通道不足</li>\n<li>解决办法：增加设备到主机间的通路，而不增加通道（结果类似RS触发器）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"中断机构和中断处理程序\"><a href=\"#中断机构和中断处理程序\" class=\"headerlink\" title=\"中断机构和中断处理程序\"></a>中断机构和中断处理程序</h3><ul>\n<li>中断<ul>\n<li>分类<ul>\n<li>中断（外部触发）<ul>\n<li>对外部I&#x2F;O设备发出的中断信号的响应</li>\n</ul>\n</li>\n<li>陷入（内部原因：除0）<ul>\n<li>由CPU内部事件引起的中断</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>中断向量表（类比51单片机）<ul>\n<li>中断程序的入口地址表</li>\n</ul>\n</li>\n<li>中断优先级<ul>\n<li>对紧急程度不同的中断处理方式</li>\n</ul>\n</li>\n<li>对多中断源的处理方式<ul>\n<li>屏蔽中断</li>\n<li>嵌套中断</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>中断处理程序<ul>\n<li>测定是否有未响应的中断信号</li>\n<li>保护被中断进程的CPU环境</li>\n<li>转入相应的设备处理程序</li>\n<li>中断处理</li>\n<li>恢复CPU 的现场并退出中断</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"设备驱动程序\"><a href=\"#设备驱动程序\" class=\"headerlink\" title=\"设备驱动程序\"></a>设备驱动程序</h3><ul>\n<li>是I&#x2F;O进程与设备控制器之间的通信程序，又由于它常以进程的形式存在，故以后就简称为设备驱动进程</li>\n<li>主要任务是接受来自它上一层的与设备无关软件的抽象请求，并执行这个请求。</li>\n<li>功能<ul>\n<li><ol>\n<li>接收由I&#x2F;O进程发来的命令和参数， 并将命令中的抽象要求转换为具体要求。例如，将磁盘块号转换为磁盘的盘面、 磁道号及扇区号。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>检查用户I&#x2F;O请求的合法性，了解I&#x2F;O设备的状态，传递有关参数，设置设备的工作方式。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>发出I&#x2F;O命令，如果设备空闲，便立即启动I&#x2F;O设备去完成指定的I&#x2F;O操作；如果设备处于忙碌状态，则将请求者的请求块挂在设备队列上等待。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>对于设置有通道的计算机系统，驱动程序还应能够根据用户的I&#x2F;O请求，自动地构成通道程序。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>设备驱动程序的处理过程<ul>\n<li>将用户和上层软件对设备控制的抽象要求转换成对设备的具体要求，如对抽象要求的盘块号转换为磁盘的盘面、磁道及扇区。</li>\n<li>检查I&#x2F;O请求的合理性。</li>\n<li>读出和检查设备的状态，确保设备处于就绪态。</li>\n<li>传送必要的参数，如传送的字节数，数据在主存的首址等。</li>\n<li>工作方式的设置。</li>\n<li>启动I&#x2F;O设备，并检查启动是否成功，如成功则将控制返回给I&#x2F;O控制系统，在I&#x2F;O设备忙于传送数据时，该用户进程把自己阻塞，直至中断到来才将它唤醒，而CPU可干别的事。</li>\n</ul>\n</li>\n<li>对I&#x2F;O设备的控制方式<ul>\n<li>I&#x2F;O控制的宗旨<ul>\n<li>减少CPU对I&#x2F;O控制的干预</li>\n<li>充分利用CPU完成数据处理工作</li>\n</ul>\n</li>\n<li>I&#x2F;O 控制方式<ul>\n<li>轮询的可编程I&#x2F;O方式</li>\n<li>中断驱动I&#x2F;O方式</li>\n<li>DMA控制方式</li>\n<li>I&#x2F;O通道控制方式</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>DMA控制器组成<ul>\n<li>主机与DMA控制器的接口</li>\n<li>DMA控制器与块设备的接口</li>\n<li>I&#x2F;O控制逻辑</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"与设备无关的I-O软件\"><a href=\"#与设备无关的I-O软件\" class=\"headerlink\" title=\"与设备无关的I&#x2F;O软件\"></a>与设备无关的I&#x2F;O软件</h3><ul>\n<li>基本概念<ul>\n<li>含义： 应用程序独立于具体使用的物理设备。</li>\n<li>驱动程序是一个与硬件(或设备)紧密相关的软件。为实现设备独立性，须在驱动程序上设置一层软件，称为设备独立性软件。</li>\n<li>设备独立性(Device Independence)的优点<ul>\n<li>以物理设备名使用设备</li>\n<li>引入了逻辑设备名</li>\n<li>逻辑设备名称到物理设备名称的转换（易于实现I&#x2F;O重定向）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>与设备无关的软件<ul>\n<li>设备驱动程序的统一接口</li>\n<li>缓存管理</li>\n<li>差错控制</li>\n<li>对独立设备的分配与回收</li>\n<li>独立于设备的逻辑数据块</li>\n</ul>\n</li>\n<li>设备分配中的数据结构<ul>\n<li>设备控制表DCT</li>\n<li>控制器控制表COCT</li>\n<li>通道控制表CHCT</li>\n<li>显然，在有通道的系统中，一个进程只有获得了通道，控制器和所需设备三者之后，才具备了进行I&#x2F;O操作的物理条件</li>\n<li>系统设备表SDT</li>\n<li>逻辑设备表LUT</li>\n<li>分配的流程，从资源多的到资源紧张的:LUT-&gt;SDT-&gt;DCT-&gt;COCT-&gt;CHCT</li>\n<li>在申请设备的过程中，根据用户请求的I&#x2F;O设备的逻辑名，查找逻辑设备和物理设备的映射表；以物理设备为索引，查找SDT，找到该设备所连接的DCT；继续查找与该设备连接的COCT和CHCT，就找到了一条通路。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"用户层的I-O软件\"><a href=\"#用户层的I-O软件\" class=\"headerlink\" title=\"用户层的I&#x2F;O软件\"></a>用户层的I&#x2F;O软件</h3><ul>\n<li>系统调用与库函数<ul>\n<li>OS向用户提供的所有功能，用户进程都必须通过系统调用来获取</li>\n<li>在C语言以及UNIX系统中，系统调用（如read）与各系统调用所使用的库函数（如read）之间几乎是一一对应的。而微软的叫Win32API</li>\n</ul>\n</li>\n<li>假脱机系统（spooling）<ul>\n<li>spooling技术是对脱机输入&#x2F;输出系统的模拟</li>\n<li>主要组成<ul>\n<li>输入&#x2F;输出井</li>\n<li>输入&#x2F;输出缓冲区</li>\n<li>输入&#x2F;输出进程</li>\n<li>井管理程序</li>\n</ul>\n</li>\n<li>特点（体现操作系统的虚拟性）<ul>\n<li>提高了I&#x2F;O的速度<ul>\n<li>对数据所进行的I&#x2F;O操作，已从对低速设备演变为对输入井或输出井中的数据存取。</li>\n</ul>\n</li>\n<li>将独占设备改造为共享设备<ul>\n<li>实际分给用户进程的不是打印设备，而是共享输出井中的存储区域</li>\n</ul>\n</li>\n<li>实现了虚拟设备功能<ul>\n<li>将独占设备变成多台独占的虚拟设备。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"缓冲区管理\"><a href=\"#缓冲区管理\" class=\"headerlink\" title=\"缓冲区管理\"></a>缓冲区管理</h3><ul>\n<li>缓冲的引入（原因）<ul>\n<li>缓和CPU与I&#x2F;O设备间速度不匹配的矛盾</li>\n<li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</li>\n<li>提高CPU和I&#x2F;O设备之间的并行性</li>\n<li>解决数据粒度不匹配的问题</li>\n</ul>\n</li>\n<li>单缓冲区<ul>\n<li>即在CPU计算的时候，将数据数据输入到缓冲区(大小取决与T和C的大小)</li>\n</ul>\n</li>\n<li>双缓冲区<ul>\n<li>即允许CPU连续工作（T不断）</li>\n</ul>\n</li>\n<li>环形缓冲区（专为生产者和消费者打造）<ul>\n<li>组成<ul>\n<li>多个缓冲区</li>\n<li>多个指针</li>\n</ul>\n</li>\n<li>使用<ul>\n<li>Getbuf过程</li>\n<li>Releasebuf过程</li>\n</ul>\n</li>\n<li>同步问题</li>\n</ul>\n</li>\n<li>缓冲池(理解为更大的缓冲区)<ul>\n<li>组成<ul>\n<li>空白缓冲队列（emq）<ul>\n<li>由空缓冲区链接而成F(emq)，L(emq)分别指向该队列首尾缓冲区</li>\n</ul>\n</li>\n<li>输入队列（inq）<ul>\n<li>由装满输入数据的缓冲区链接而成F(inq)，L(inq)分别指向该队列首尾缓冲区</li>\n</ul>\n</li>\n<li>输出队列（outq）<ul>\n<li>由装满输出数据的缓冲区链接而成F(outq)， L(outq)分别指向该队列首尾缓冲</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Getbuf和Putbuf过程<ul>\n<li>收容：缓冲池接收外界数据</li>\n<li>提取：外界从缓冲池获得数据</li>\n</ul>\n</li>\n<li>缓冲区工作方式（从缓冲区的角度来看）<ul>\n<li>收容输入</li>\n<li>提取输入</li>\n<li>收容输出</li>\n<li>提取输出</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"磁盘存储器的性能和调度\"><a href=\"#磁盘存储器的性能和调度\" class=\"headerlink\" title=\"磁盘存储器的性能和调度\"></a>磁盘存储器的性能和调度</h3><ul>\n<li>数据的组织和格式</li>\n<li>磁盘的类型<ul>\n<li>固定头磁盘（贵）</li>\n<li>移动头磁盘</li>\n</ul>\n</li>\n<li>磁盘访问的时间（关键）<ul>\n<li>寻道时间Ts&#x3D;m*n+s</li>\n<li>旋转延迟时间Tr</li>\n<li>传输时间Tt&#x3D;b&#x2F;rN</li>\n<li>总时间Ta&#x3D;Ts+1&#x2F;2r+b&#x2F;rN</li>\n</ul>\n</li>\n<li>磁盘的调度算法（掌握图表）<ul>\n<li>先来先服务（FCFS）<ul>\n<li>优点：公平，简单</li>\n<li>缺点：可能导致某些进程的请求长期得不到满足</li>\n</ul>\n</li>\n<li>最短寻道时间优先（SSTF）<ul>\n<li>说明：要求访问的磁道和当前磁头所在的磁道距离最近，以使每次的寻道时间最短</li>\n</ul>\n</li>\n<li>扫描算法（SCAN）<ul>\n<li>扫描算法不仅考虑到欲访问的磁道与当前磁道间的距离，更优先考虑的是磁道当前的移动方向</li>\n<li>联想电梯的运行</li>\n<li>可防止低优先级进程出现“饥饿”的现象</li>\n</ul>\n</li>\n<li>循环扫描算法（CSCAN）<ul>\n<li>算法规定磁头单向移动，例如，只是自里向外移动，当磁头移到最外的磁道并访问后，磁头立即返回到最里的欲访问磁道，亦即将最小磁道号紧接着最大磁道号构成循环，进行循环扫描</li>\n</ul>\n</li>\n<li>NStepScan算法<ul>\n<li>N步SCAN算法是将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次这些子队列。</li>\n</ul>\n</li>\n<li>FSCAN算法<ul>\n<li>是Nstepscan算法的简化，将磁盘请求队列分成两个子队列</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第七章：文件管理\"><a href=\"#第七章：文件管理\" class=\"headerlink\" title=\"第七章：文件管理\"></a>第七章：文件管理</h2><h3 id=\"数据项\"><a href=\"#数据项\" class=\"headerlink\" title=\"数据项\"></a>数据项</h3><ul>\n<li>基本数据项</li>\n<li>组合数据项</li>\n</ul>\n<h3 id=\"记录\"><a href=\"#记录\" class=\"headerlink\" title=\"记录\"></a>记录</h3><ul>\n<li>记录是一组相关数据项的集合，用于描述一个对象在某个方面的属性</li>\n</ul>\n<h3 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h3><ul>\n<li>文件类型</li>\n<li>文件长度</li>\n<li>文件的物理位置</li>\n<li>文件的建立时间</li>\n</ul>\n<h3 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h3><ul>\n<li>创建文件</li>\n<li>删除文件</li>\n<li>读文件</li>\n<li>写文件</li>\n<li>设置文件读写的位置</li>\n</ul>\n<h3 id=\"文件的逻辑结构\"><a href=\"#文件的逻辑结构\" class=\"headerlink\" title=\"文件的逻辑结构\"></a>文件的逻辑结构</h3><ul>\n<li>顺序文件</li>\n<li>记录寻址</li>\n<li>索引文件</li>\n<li>索引顺序文件</li>\n<li>直接文件和哈希文件</li>\n</ul>\n<h3 id=\"文件目录\"><a href=\"#文件目录\" class=\"headerlink\" title=\"文件目录\"></a>文件目录</h3><ul>\n<li>文件控制块（FCB）<ul>\n<li>文件名+inode(属性)</li>\n</ul>\n</li>\n<li>简单的文件目录<ul>\n<li>单级文件目录<ul>\n<li>查找慢</li>\n<li>不允许重名</li>\n<li>不便于实现文件共享</li>\n</ul>\n</li>\n<li>两级文件目录<ul>\n<li>提高检索速度，从M*N到M+N</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>树形结构目录<ul>\n<li>路径名<ul>\n<li>“..”是父目录</li>\n<li>“&#x2F;”是根目录</li>\n<li>区别绝对路径和相对路径（..&#x2F;…&#x2F;…&#x2F;1&#x2F;2&#x2F;3&#x2F;）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"文件共享\"><a href=\"#文件共享\" class=\"headerlink\" title=\"文件共享\"></a>文件共享</h3><ul>\n<li>有向无循环图（DAG）</li>\n<li>利用符号链接实现文件共享<ul>\n<li>实际上就是“快捷方式”</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"文件保护\"><a href=\"#文件保护\" class=\"headerlink\" title=\"文件保护\"></a>文件保护</h3><p><img src=\"https://github.com/SSHeRun/CS-Xmind-Note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png\" alt=\"picture\"></p>\n"},{"_content":"# 一.操作系统引论\n## 1.操作系统的目标和功能\n### 目标\n* 方便性\n* 有效性\n    * 提高系统资源利用率\n    * 提高系统吞吐量\n* 可扩充性\n* 开放性\n### 作用\n* OS作为用户与计算机硬件系统之间的接口\n    * 命令方式\n    * 系统调用方式\n    * 图标–窗口方式\n* OS实现了对计算机资源的抽象\n## 2.操作系统的发展过程\n### 未配置操作系统的计算机系统\n* 人工操作方式\n* > 用户独占全机 CPU等待人工操作 严重降低了计算机资源的利用率\n\n* 脱机输入/输出(Off–Line I/O)方式\n* > 减少了CPU的空闲时间 提高了I/O速度 效率仍然不理想\n\n### 单道批处理系统\n### 多道批处理系统\n> 1.资源利用率高\n> 2.系统吞吐量大\n> 3.平均周转时间长\n> 4.无交互能力\n\n* (宏观并行，微观串行)\n### 分时系统\n> 特征:\n> 1.多路性\n> 2.独立性\n> 3.及时性\n> 4.交互性\n\n### 实时系统\n### 集群系统–超算~云计算\n### 微机操作系统的发展\n## 3.操作系统的基本特征\n### 1.并发concurrence\n* 区别并行和并发\n* > 并行性是指两个或多个事件在同一时刻发生→宏观并行，微观并行\n* > 并发性是指两个或多个事件在同一时间间隔内发生→宏观并行，微观串行\n\n    * 并发是进程宏观一起运行，微观上交替运行，而并行是指同时运行\n* 引入进程\n* > 进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令，数据和堆栈等组成的，是一个能独立运行的活动实体\n\n### 2.共享sharing\n* 1.互斥共享方式\n* 2.同时访问方式\n* 并发和共享是多用户(多任务)OS的两个最基本的特征。它们又是互为存在的条件\n### 3.虚拟virtual\n* 时分复用技术\n* 空分复用技术\n### 4.异步asynchronism\n## 4.操作系统的主要功能\n### 1.处理机管理功能\n* 进程控制\n* 进程同步\n    * 进程互斥方式\n    * 进程同步方式(协同)\n* 进程通信\n* 调度\n    * 作业调度\n    * 进程调度\n### 2.存储器管理功能\n* 内存分配\n    * 静态分配\n    * 动态分配\n* 内存保护\n* 地址映射\n* 内存扩充\n### 3.设备管理功能\n* 缓冲管理\n* 设备分配\n* 设备处理\n    * 设备处理程序又称设备驱动程序\n### 4.文件管理功能\n* 文件存储空间的管理\n* 目录管理\n* 文件的读写管理和保护\n### 5.操作系统与用户之间的接口\n* 用户接口\n* 程序接口\n### 6.现代操作系统的新功能\n* 系统安全\n* 网络的功能和服务\n* 支持多媒体\n## 5.OS结构设计\n### 传统操作系统结构\n* 无结构操作系统\n* 模块化OS\n* 分层式结构OS\n### 微内核os结构\n* 客户/服务器模式\n* 面对对象的程序设计\n","source":"_posts/2023-06-14-1-操作系统引论.md","raw":"# 一.操作系统引论\n## 1.操作系统的目标和功能\n### 目标\n* 方便性\n* 有效性\n    * 提高系统资源利用率\n    * 提高系统吞吐量\n* 可扩充性\n* 开放性\n### 作用\n* OS作为用户与计算机硬件系统之间的接口\n    * 命令方式\n    * 系统调用方式\n    * 图标–窗口方式\n* OS实现了对计算机资源的抽象\n## 2.操作系统的发展过程\n### 未配置操作系统的计算机系统\n* 人工操作方式\n* > 用户独占全机 CPU等待人工操作 严重降低了计算机资源的利用率\n\n* 脱机输入/输出(Off–Line I/O)方式\n* > 减少了CPU的空闲时间 提高了I/O速度 效率仍然不理想\n\n### 单道批处理系统\n### 多道批处理系统\n> 1.资源利用率高\n> 2.系统吞吐量大\n> 3.平均周转时间长\n> 4.无交互能力\n\n* (宏观并行，微观串行)\n### 分时系统\n> 特征:\n> 1.多路性\n> 2.独立性\n> 3.及时性\n> 4.交互性\n\n### 实时系统\n### 集群系统–超算~云计算\n### 微机操作系统的发展\n## 3.操作系统的基本特征\n### 1.并发concurrence\n* 区别并行和并发\n* > 并行性是指两个或多个事件在同一时刻发生→宏观并行，微观并行\n* > 并发性是指两个或多个事件在同一时间间隔内发生→宏观并行，微观串行\n\n    * 并发是进程宏观一起运行，微观上交替运行，而并行是指同时运行\n* 引入进程\n* > 进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令，数据和堆栈等组成的，是一个能独立运行的活动实体\n\n### 2.共享sharing\n* 1.互斥共享方式\n* 2.同时访问方式\n* 并发和共享是多用户(多任务)OS的两个最基本的特征。它们又是互为存在的条件\n### 3.虚拟virtual\n* 时分复用技术\n* 空分复用技术\n### 4.异步asynchronism\n## 4.操作系统的主要功能\n### 1.处理机管理功能\n* 进程控制\n* 进程同步\n    * 进程互斥方式\n    * 进程同步方式(协同)\n* 进程通信\n* 调度\n    * 作业调度\n    * 进程调度\n### 2.存储器管理功能\n* 内存分配\n    * 静态分配\n    * 动态分配\n* 内存保护\n* 地址映射\n* 内存扩充\n### 3.设备管理功能\n* 缓冲管理\n* 设备分配\n* 设备处理\n    * 设备处理程序又称设备驱动程序\n### 4.文件管理功能\n* 文件存储空间的管理\n* 目录管理\n* 文件的读写管理和保护\n### 5.操作系统与用户之间的接口\n* 用户接口\n* 程序接口\n### 6.现代操作系统的新功能\n* 系统安全\n* 网络的功能和服务\n* 支持多媒体\n## 5.OS结构设计\n### 传统操作系统结构\n* 无结构操作系统\n* 模块化OS\n* 分层式结构OS\n### 微内核os结构\n* 客户/服务器模式\n* 面对对象的程序设计\n","slug":"2023-06-14-1-操作系统引论","published":1,"date":"2023-12-15T02:31:41.979Z","updated":"2023-12-15T02:31:41.991Z","_id":"clq60jop500014zgsgdl40yn5","title":"","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"一-操作系统引论\"><a href=\"#一-操作系统引论\" class=\"headerlink\" title=\"一.操作系统引论\"></a>一.操作系统引论</h1><h2 id=\"1-操作系统的目标和功能\"><a href=\"#1-操作系统的目标和功能\" class=\"headerlink\" title=\"1.操作系统的目标和功能\"></a>1.操作系统的目标和功能</h2><h3 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h3><ul>\n<li>方便性</li>\n<li>有效性<ul>\n<li>提高系统资源利用率</li>\n<li>提高系统吞吐量</li>\n</ul>\n</li>\n<li>可扩充性</li>\n<li>开放性</li>\n</ul>\n<h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><ul>\n<li>OS作为用户与计算机硬件系统之间的接口<ul>\n<li>命令方式</li>\n<li>系统调用方式</li>\n<li>图标–窗口方式</li>\n</ul>\n</li>\n<li>OS实现了对计算机资源的抽象</li>\n</ul>\n<h2 id=\"2-操作系统的发展过程\"><a href=\"#2-操作系统的发展过程\" class=\"headerlink\" title=\"2.操作系统的发展过程\"></a>2.操作系统的发展过程</h2><h3 id=\"未配置操作系统的计算机系统\"><a href=\"#未配置操作系统的计算机系统\" class=\"headerlink\" title=\"未配置操作系统的计算机系统\"></a>未配置操作系统的计算机系统</h3><ul>\n<li><p>人工操作方式</p>\n</li>\n<li><blockquote>\n<p>用户独占全机 CPU等待人工操作 严重降低了计算机资源的利用率</p>\n</blockquote>\n</li>\n<li><p>脱机输入&#x2F;输出(Off–Line I&#x2F;O)方式</p>\n</li>\n<li><blockquote>\n<p>减少了CPU的空闲时间 提高了I&#x2F;O速度 效率仍然不理想</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"单道批处理系统\"><a href=\"#单道批处理系统\" class=\"headerlink\" title=\"单道批处理系统\"></a>单道批处理系统</h3><h3 id=\"多道批处理系统\"><a href=\"#多道批处理系统\" class=\"headerlink\" title=\"多道批处理系统\"></a>多道批处理系统</h3><blockquote>\n<p>1.资源利用率高<br>2.系统吞吐量大<br>3.平均周转时间长<br>4.无交互能力</p>\n</blockquote>\n<ul>\n<li>(宏观并行，微观串行)</li>\n</ul>\n<h3 id=\"分时系统\"><a href=\"#分时系统\" class=\"headerlink\" title=\"分时系统\"></a>分时系统</h3><blockquote>\n<p>特征:<br>1.多路性<br>2.独立性<br>3.及时性<br>4.交互性</p>\n</blockquote>\n<h3 id=\"实时系统\"><a href=\"#实时系统\" class=\"headerlink\" title=\"实时系统\"></a>实时系统</h3><h3 id=\"集群系统–超算-云计算\"><a href=\"#集群系统–超算-云计算\" class=\"headerlink\" title=\"集群系统–超算~云计算\"></a>集群系统–超算~云计算</h3><h3 id=\"微机操作系统的发展\"><a href=\"#微机操作系统的发展\" class=\"headerlink\" title=\"微机操作系统的发展\"></a>微机操作系统的发展</h3><h2 id=\"3-操作系统的基本特征\"><a href=\"#3-操作系统的基本特征\" class=\"headerlink\" title=\"3.操作系统的基本特征\"></a>3.操作系统的基本特征</h2><h3 id=\"1-并发concurrence\"><a href=\"#1-并发concurrence\" class=\"headerlink\" title=\"1.并发concurrence\"></a>1.并发concurrence</h3><ul>\n<li>区别并行和并发</li>\n<li><blockquote>\n<p>并行性是指两个或多个事件在同一时刻发生→宏观并行，微观并行</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>并发性是指两个或多个事件在同一时间间隔内发生→宏观并行，微观串行</p>\n</blockquote>\n<ul>\n<li>并发是进程宏观一起运行，微观上交替运行，而并行是指同时运行</li>\n</ul>\n</li>\n<li>引入进程</li>\n<li><blockquote>\n<p>进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令，数据和堆栈等组成的，是一个能独立运行的活动实体</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"2-共享sharing\"><a href=\"#2-共享sharing\" class=\"headerlink\" title=\"2.共享sharing\"></a>2.共享sharing</h3><ul>\n<li>1.互斥共享方式</li>\n<li>2.同时访问方式</li>\n<li>并发和共享是多用户(多任务)OS的两个最基本的特征。它们又是互为存在的条件</li>\n</ul>\n<h3 id=\"3-虚拟virtual\"><a href=\"#3-虚拟virtual\" class=\"headerlink\" title=\"3.虚拟virtual\"></a>3.虚拟virtual</h3><ul>\n<li>时分复用技术</li>\n<li>空分复用技术</li>\n</ul>\n<h3 id=\"4-异步asynchronism\"><a href=\"#4-异步asynchronism\" class=\"headerlink\" title=\"4.异步asynchronism\"></a>4.异步asynchronism</h3><h2 id=\"4-操作系统的主要功能\"><a href=\"#4-操作系统的主要功能\" class=\"headerlink\" title=\"4.操作系统的主要功能\"></a>4.操作系统的主要功能</h2><h3 id=\"1-处理机管理功能\"><a href=\"#1-处理机管理功能\" class=\"headerlink\" title=\"1.处理机管理功能\"></a>1.处理机管理功能</h3><ul>\n<li>进程控制</li>\n<li>进程同步<ul>\n<li>进程互斥方式</li>\n<li>进程同步方式(协同)</li>\n</ul>\n</li>\n<li>进程通信</li>\n<li>调度<ul>\n<li>作业调度</li>\n<li>进程调度</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-存储器管理功能\"><a href=\"#2-存储器管理功能\" class=\"headerlink\" title=\"2.存储器管理功能\"></a>2.存储器管理功能</h3><ul>\n<li>内存分配<ul>\n<li>静态分配</li>\n<li>动态分配</li>\n</ul>\n</li>\n<li>内存保护</li>\n<li>地址映射</li>\n<li>内存扩充</li>\n</ul>\n<h3 id=\"3-设备管理功能\"><a href=\"#3-设备管理功能\" class=\"headerlink\" title=\"3.设备管理功能\"></a>3.设备管理功能</h3><ul>\n<li>缓冲管理</li>\n<li>设备分配</li>\n<li>设备处理<ul>\n<li>设备处理程序又称设备驱动程序</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-文件管理功能\"><a href=\"#4-文件管理功能\" class=\"headerlink\" title=\"4.文件管理功能\"></a>4.文件管理功能</h3><ul>\n<li>文件存储空间的管理</li>\n<li>目录管理</li>\n<li>文件的读写管理和保护</li>\n</ul>\n<h3 id=\"5-操作系统与用户之间的接口\"><a href=\"#5-操作系统与用户之间的接口\" class=\"headerlink\" title=\"5.操作系统与用户之间的接口\"></a>5.操作系统与用户之间的接口</h3><ul>\n<li>用户接口</li>\n<li>程序接口</li>\n</ul>\n<h3 id=\"6-现代操作系统的新功能\"><a href=\"#6-现代操作系统的新功能\" class=\"headerlink\" title=\"6.现代操作系统的新功能\"></a>6.现代操作系统的新功能</h3><ul>\n<li>系统安全</li>\n<li>网络的功能和服务</li>\n<li>支持多媒体</li>\n</ul>\n<h2 id=\"5-OS结构设计\"><a href=\"#5-OS结构设计\" class=\"headerlink\" title=\"5.OS结构设计\"></a>5.OS结构设计</h2><h3 id=\"传统操作系统结构\"><a href=\"#传统操作系统结构\" class=\"headerlink\" title=\"传统操作系统结构\"></a>传统操作系统结构</h3><ul>\n<li>无结构操作系统</li>\n<li>模块化OS</li>\n<li>分层式结构OS</li>\n</ul>\n<h3 id=\"微内核os结构\"><a href=\"#微内核os结构\" class=\"headerlink\" title=\"微内核os结构\"></a>微内核os结构</h3><ul>\n<li>客户&#x2F;服务器模式</li>\n<li>面对对象的程序设计</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"一-操作系统引论\"><a href=\"#一-操作系统引论\" class=\"headerlink\" title=\"一.操作系统引论\"></a>一.操作系统引论</h1><h2 id=\"1-操作系统的目标和功能\"><a href=\"#1-操作系统的目标和功能\" class=\"headerlink\" title=\"1.操作系统的目标和功能\"></a>1.操作系统的目标和功能</h2><h3 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h3><ul>\n<li>方便性</li>\n<li>有效性<ul>\n<li>提高系统资源利用率</li>\n<li>提高系统吞吐量</li>\n</ul>\n</li>\n<li>可扩充性</li>\n<li>开放性</li>\n</ul>\n<h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><ul>\n<li>OS作为用户与计算机硬件系统之间的接口<ul>\n<li>命令方式</li>\n<li>系统调用方式</li>\n<li>图标–窗口方式</li>\n</ul>\n</li>\n<li>OS实现了对计算机资源的抽象</li>\n</ul>\n<h2 id=\"2-操作系统的发展过程\"><a href=\"#2-操作系统的发展过程\" class=\"headerlink\" title=\"2.操作系统的发展过程\"></a>2.操作系统的发展过程</h2><h3 id=\"未配置操作系统的计算机系统\"><a href=\"#未配置操作系统的计算机系统\" class=\"headerlink\" title=\"未配置操作系统的计算机系统\"></a>未配置操作系统的计算机系统</h3><ul>\n<li><p>人工操作方式</p>\n</li>\n<li><blockquote>\n<p>用户独占全机 CPU等待人工操作 严重降低了计算机资源的利用率</p>\n</blockquote>\n</li>\n<li><p>脱机输入&#x2F;输出(Off–Line I&#x2F;O)方式</p>\n</li>\n<li><blockquote>\n<p>减少了CPU的空闲时间 提高了I&#x2F;O速度 效率仍然不理想</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"单道批处理系统\"><a href=\"#单道批处理系统\" class=\"headerlink\" title=\"单道批处理系统\"></a>单道批处理系统</h3><h3 id=\"多道批处理系统\"><a href=\"#多道批处理系统\" class=\"headerlink\" title=\"多道批处理系统\"></a>多道批处理系统</h3><blockquote>\n<p>1.资源利用率高<br>2.系统吞吐量大<br>3.平均周转时间长<br>4.无交互能力</p>\n</blockquote>\n<ul>\n<li>(宏观并行，微观串行)</li>\n</ul>\n<h3 id=\"分时系统\"><a href=\"#分时系统\" class=\"headerlink\" title=\"分时系统\"></a>分时系统</h3><blockquote>\n<p>特征:<br>1.多路性<br>2.独立性<br>3.及时性<br>4.交互性</p>\n</blockquote>\n<h3 id=\"实时系统\"><a href=\"#实时系统\" class=\"headerlink\" title=\"实时系统\"></a>实时系统</h3><h3 id=\"集群系统–超算-云计算\"><a href=\"#集群系统–超算-云计算\" class=\"headerlink\" title=\"集群系统–超算~云计算\"></a>集群系统–超算~云计算</h3><h3 id=\"微机操作系统的发展\"><a href=\"#微机操作系统的发展\" class=\"headerlink\" title=\"微机操作系统的发展\"></a>微机操作系统的发展</h3><h2 id=\"3-操作系统的基本特征\"><a href=\"#3-操作系统的基本特征\" class=\"headerlink\" title=\"3.操作系统的基本特征\"></a>3.操作系统的基本特征</h2><h3 id=\"1-并发concurrence\"><a href=\"#1-并发concurrence\" class=\"headerlink\" title=\"1.并发concurrence\"></a>1.并发concurrence</h3><ul>\n<li>区别并行和并发</li>\n<li><blockquote>\n<p>并行性是指两个或多个事件在同一时刻发生→宏观并行，微观并行</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>并发性是指两个或多个事件在同一时间间隔内发生→宏观并行，微观串行</p>\n</blockquote>\n<ul>\n<li>并发是进程宏观一起运行，微观上交替运行，而并行是指同时运行</li>\n</ul>\n</li>\n<li>引入进程</li>\n<li><blockquote>\n<p>进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令，数据和堆栈等组成的，是一个能独立运行的活动实体</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"2-共享sharing\"><a href=\"#2-共享sharing\" class=\"headerlink\" title=\"2.共享sharing\"></a>2.共享sharing</h3><ul>\n<li>1.互斥共享方式</li>\n<li>2.同时访问方式</li>\n<li>并发和共享是多用户(多任务)OS的两个最基本的特征。它们又是互为存在的条件</li>\n</ul>\n<h3 id=\"3-虚拟virtual\"><a href=\"#3-虚拟virtual\" class=\"headerlink\" title=\"3.虚拟virtual\"></a>3.虚拟virtual</h3><ul>\n<li>时分复用技术</li>\n<li>空分复用技术</li>\n</ul>\n<h3 id=\"4-异步asynchronism\"><a href=\"#4-异步asynchronism\" class=\"headerlink\" title=\"4.异步asynchronism\"></a>4.异步asynchronism</h3><h2 id=\"4-操作系统的主要功能\"><a href=\"#4-操作系统的主要功能\" class=\"headerlink\" title=\"4.操作系统的主要功能\"></a>4.操作系统的主要功能</h2><h3 id=\"1-处理机管理功能\"><a href=\"#1-处理机管理功能\" class=\"headerlink\" title=\"1.处理机管理功能\"></a>1.处理机管理功能</h3><ul>\n<li>进程控制</li>\n<li>进程同步<ul>\n<li>进程互斥方式</li>\n<li>进程同步方式(协同)</li>\n</ul>\n</li>\n<li>进程通信</li>\n<li>调度<ul>\n<li>作业调度</li>\n<li>进程调度</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-存储器管理功能\"><a href=\"#2-存储器管理功能\" class=\"headerlink\" title=\"2.存储器管理功能\"></a>2.存储器管理功能</h3><ul>\n<li>内存分配<ul>\n<li>静态分配</li>\n<li>动态分配</li>\n</ul>\n</li>\n<li>内存保护</li>\n<li>地址映射</li>\n<li>内存扩充</li>\n</ul>\n<h3 id=\"3-设备管理功能\"><a href=\"#3-设备管理功能\" class=\"headerlink\" title=\"3.设备管理功能\"></a>3.设备管理功能</h3><ul>\n<li>缓冲管理</li>\n<li>设备分配</li>\n<li>设备处理<ul>\n<li>设备处理程序又称设备驱动程序</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-文件管理功能\"><a href=\"#4-文件管理功能\" class=\"headerlink\" title=\"4.文件管理功能\"></a>4.文件管理功能</h3><ul>\n<li>文件存储空间的管理</li>\n<li>目录管理</li>\n<li>文件的读写管理和保护</li>\n</ul>\n<h3 id=\"5-操作系统与用户之间的接口\"><a href=\"#5-操作系统与用户之间的接口\" class=\"headerlink\" title=\"5.操作系统与用户之间的接口\"></a>5.操作系统与用户之间的接口</h3><ul>\n<li>用户接口</li>\n<li>程序接口</li>\n</ul>\n<h3 id=\"6-现代操作系统的新功能\"><a href=\"#6-现代操作系统的新功能\" class=\"headerlink\" title=\"6.现代操作系统的新功能\"></a>6.现代操作系统的新功能</h3><ul>\n<li>系统安全</li>\n<li>网络的功能和服务</li>\n<li>支持多媒体</li>\n</ul>\n<h2 id=\"5-OS结构设计\"><a href=\"#5-OS结构设计\" class=\"headerlink\" title=\"5.OS结构设计\"></a>5.OS结构设计</h2><h3 id=\"传统操作系统结构\"><a href=\"#传统操作系统结构\" class=\"headerlink\" title=\"传统操作系统结构\"></a>传统操作系统结构</h3><ul>\n<li>无结构操作系统</li>\n<li>模块化OS</li>\n<li>分层式结构OS</li>\n</ul>\n<h3 id=\"微内核os结构\"><a href=\"#微内核os结构\" class=\"headerlink\" title=\"微内核os结构\"></a>微内核os结构</h3><ul>\n<li>客户&#x2F;服务器模式</li>\n<li>面对对象的程序设计</li>\n</ul>\n"},{"_content":"# 第二章进程的描述与控制\n## 前驱图和程序执行\n## 程序并发执行\n### 程序的并发执行\n### 程序并发执行时的特征\n* 间断性\n* 失去封闭性\n* 不可再现性\n## 进程的描述\n### 进程的定义\n* 进程是程序的一次执行\n* 进程是一个程序及其数据在处理机上顺序执行时所发生的活动\n* 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位\n### 进程的特征\n* 动态性\n* 并发性\n* 独立性\n* 异步性\n### 从操作系统角度分类\n* 系统进程\n* 用户进程\n### 进程和程序的区别\n* 进程是动态概念，而程序则是静态概念\n* 程序是指令的有序集合，永远存在；进程强调是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；\n* 进程具有并发性，而程序没有\n* 进程可创建其他进程，而程序并不能形成新的程序\n* 进程是竞争计算机资源的基本单位，程序不是\n### 进程和程序的联系\n* 进程是程序在数据集上的一次执行\n* 程序是构成进程的组成部分，一个程序可对应多个进程，一个进程可包括多个程序\n* 进程的运行目标是执行所对应的程序\n* 从静态看，进程由程序、数据和进程控制块（PCB）组成\n### 进程的基本状态及转换\n* 进程的三种基本状态\n    * 就绪状态ready\n    * 执行状态running\n    * 阻塞状态block\n* 三种基本状态的转换\n* 创建状态和终止状态\n    * 五状态进程模型\n* 注意\n    * 阻塞态->运行态和就绪态->阻塞态这二种状态转换不可能发生\n### 挂起操作和进程状态的转换\n* 挂起和阻塞的区别\n* 挂起操作的目的\n    * 终端用户的需要: 修改、检查进程\n    * 父进程的需要：修改、协调子进程\n    * 对换的需要：缓和内存\n    * 负荷调节的需要：保证实时任务的执行\n* 关键图\n### 进程管理中的数据结构\n* 进程控制块PCB的作用\n    * 作为独立运行基本单位的标志\n    * 能实现间断性运行方式\n    * 提供进程管理所需要的信息\n    * 提供进程调度所需要的信息\n    * 实现与其他进程的同步与通信\n* 进程控制块的信息\n    * 进程标识符\n        * 外部标识符PID\n        * 内部标识符(端口)\n    * 处理机状态\n        * 通用寄存器\n        * 指令计数器\n        * 程序状态字PSW\n        * 用户栈指针\n    * 进程调度信息\n        * 进程状态\n        * 进程优先级\n        * 进程调度所需的其他信息\n        * 事件\n    * 进程控制信息\n        * 程序和数据的地址\n        * 进程同步和通信机制\n        * 资源清单\n        * 链接指针\n    * 进程控制块的组织方式\n        * 线性方式\n        * 链接方式\n        * 索引方式\n## 进程控制\n### 操作系统内核\n* 两大功能\n    * 支撑功能\n        * 中断管理\n        * 时钟管理\n        * 原语操作\n            * 进程的管理，由若干原语（primitive）来执行\n    * 资源管理功能\n        * 进程管理\n        * 存储器管理\n        * 设备管理\n* 状态\n    * 系统态，管态，内核态\n    * 用户态，目态\n### 进程的创建\n* 进程的层次结构\n    * 父进程\n    * 子进程\n* 引起创建进程的事件\n    * 用户登录\n    * 作业调度\n    * 提供服务\n    * 应用请求\n* 进程的创建过程\n    * 1.申请空白PCB\n    * 2.为新进程分配其运行所需的资源\n    * 3.初始化进程块PCB\n    * 4.如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列\n* 进程的终止\n    * 引起进程终止的事件\n        * 1.正常结束\n        * 2.异常结束\n        * 3.外界干预\n    * 进程的终止过程\n        * 1.根据被终止进程的标识符\n* 进程的阻塞与唤醒\n    * 引起进程阻塞和唤醒的事件\n        * 请求系统服务而未满足\n        * 启动某种操作而阻塞当前进程\n        * 新数据尚未到达\n        * 无新工作可做：系统进程\n    * 进程阻塞过程(自己阻塞自己)\n    * 进程唤醒过程(系统或其他进程唤醒自己)\n* 进程的挂起与激活\n    * suspend\n    * active\n### 进程同步\n* 基本概念\n    * 两种形式的制约关系\n        * 间接相互制约关系\n            * 互斥——竞争\n        * 直接相互制约关系\n            * 同步——协作\n    * 临界资源\n    * 分区\n        * 进入区enter section\n        * 临界区critical section\n        * 退出区exit section\n        * 剩余区remainder section\n    * 同步机制应遵循的规则\n        * 1.空闲让进\n        * 2.忙则等待\n        * 3.有限等待\n        * 4.让权等待\n* 进程同步机制\n    * 软件同步机制:都没有解决让权等待，而且部分方法还会产生死锁的情况\n    * 硬件同步机制\n        * 关中断\n        * 利用Test-and-Set指令实现互斥\n        * 利用swap指令实现进程互斥\n    * 信号量机制\n        * 整型信号量\n        * 记录型信号量\n            * 由于整型信号量没有遵循让权等待原则，记录型允许负数，即阻塞链表\n        * AND型信号量\n        * 信号量集\n            * 理解:AND型号量的wait和signal仅能对信号施以加1或减1操作，意味着每次只能对某类临界资源进行一个单位的申请或释放。当一次需要N个单位时，便要进行N次wait操作，这显然是低效的，甚至会增加死锁的概率。此外，在有些情况下，为确保系统的安全性，当所申请的资源数量低于某一下限值时，还必须进行管制，不予以分配。因此，当进程申请某类临界资源时，在每次分配前，都必须测试资源数量，判断是否大于可分配的下限值，决定是否予以分配\n            * 操作\n                * Swait(S1，t1，d1…Sn，tn，dn)\n                * Ssignal(S1，d1…Sn，dn)\n            * 特殊情况\n* 经典进程的同步问题\n    * 生产者–消费者问题\n    * 哲学家进餐问题\n    * 读者–写者问题\n## 进程通信\n### 进程通信是指进程之间的信息交换，又称低级进程通信\n### 进程通信的类型\n* 共享存储器系统\n    * 基于共享数据结构的通信方式\n        * 生产者和消费者\n    * 基于共享存储区的通信方式\n        * 高级通信\n* 管道通信系统(pipe)\n    * 高级通信\n* 消息传递系统\n    * 高级通信\n    * 方式分类\n        * 直接通信\n        * 间接通信\n* 客服机–服务器系统\n### 消息传递通信的实现方式\n* 直接消息传递系统\n* 信箱通信\n## 线程的基本概念\n### 线程的引入\n* 线程的引入正是为了简化线程间的通信，以小的开销来提高进程内的并发程度\n* 多线程并发的不足\n    * 进程的两个基本属性\n        * 一个拥有资源的独立单位，可独立分配系统资源\n        * 一个可独立调度和分派的基本单位，PCB\n    * 程序并发执行所需付出的时空开销\n        * 创建进程\n        * 撤销进程\n        * 进程切换\n    * 进程间通信效率低\n    * 将分配资源和调度两个属性分开\n* 线程——作为调度和分派的基本单位\n    * 进程是系统资源分配的单位，线程是处理器调度的单位\n    * 线程表示进程的一个控制点，可以执行一系列的指令。通常，和应用程序的一个函数相对应\n    * 进程分解为线程还可以有效利用多处理器和多核计算机\n### 线程与进程的比较\n* 不同点\n    * 调度的基本单位\n    * 并发性\n* 相似点\n    * 状态：运行、阻塞、就绪\n    * 线程具有一定的生命期\n    * 进程可创建线程，一个线程可创建另一个子线程\n    * 多个线程并发执行时仍然存在互斥与同步\n### 线程的实现\n* 线程的实现方式\n    * 内核支持线程KST\n    * 用户级线程ULT\n    * 组合方式\n* 多线程OS中的进程属性\n    * 进程是一个可拥有资源的基本单位\n    * 多个线程可并发执行\n    * 进程已不是可执行的实体\n* 线程的状态和线程控制块\n    * 线程运行的三个状态\n        * 执行状态\n        * 就绪状态\n        * 阻塞状态\n    * 线程控制块TCB\n","source":"_posts/2023-06-14-2-进程的描述与控制.md","raw":"# 第二章进程的描述与控制\n## 前驱图和程序执行\n## 程序并发执行\n### 程序的并发执行\n### 程序并发执行时的特征\n* 间断性\n* 失去封闭性\n* 不可再现性\n## 进程的描述\n### 进程的定义\n* 进程是程序的一次执行\n* 进程是一个程序及其数据在处理机上顺序执行时所发生的活动\n* 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位\n### 进程的特征\n* 动态性\n* 并发性\n* 独立性\n* 异步性\n### 从操作系统角度分类\n* 系统进程\n* 用户进程\n### 进程和程序的区别\n* 进程是动态概念，而程序则是静态概念\n* 程序是指令的有序集合，永远存在；进程强调是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；\n* 进程具有并发性，而程序没有\n* 进程可创建其他进程，而程序并不能形成新的程序\n* 进程是竞争计算机资源的基本单位，程序不是\n### 进程和程序的联系\n* 进程是程序在数据集上的一次执行\n* 程序是构成进程的组成部分，一个程序可对应多个进程，一个进程可包括多个程序\n* 进程的运行目标是执行所对应的程序\n* 从静态看，进程由程序、数据和进程控制块（PCB）组成\n### 进程的基本状态及转换\n* 进程的三种基本状态\n    * 就绪状态ready\n    * 执行状态running\n    * 阻塞状态block\n* 三种基本状态的转换\n* 创建状态和终止状态\n    * 五状态进程模型\n* 注意\n    * 阻塞态->运行态和就绪态->阻塞态这二种状态转换不可能发生\n### 挂起操作和进程状态的转换\n* 挂起和阻塞的区别\n* 挂起操作的目的\n    * 终端用户的需要: 修改、检查进程\n    * 父进程的需要：修改、协调子进程\n    * 对换的需要：缓和内存\n    * 负荷调节的需要：保证实时任务的执行\n* 关键图\n### 进程管理中的数据结构\n* 进程控制块PCB的作用\n    * 作为独立运行基本单位的标志\n    * 能实现间断性运行方式\n    * 提供进程管理所需要的信息\n    * 提供进程调度所需要的信息\n    * 实现与其他进程的同步与通信\n* 进程控制块的信息\n    * 进程标识符\n        * 外部标识符PID\n        * 内部标识符(端口)\n    * 处理机状态\n        * 通用寄存器\n        * 指令计数器\n        * 程序状态字PSW\n        * 用户栈指针\n    * 进程调度信息\n        * 进程状态\n        * 进程优先级\n        * 进程调度所需的其他信息\n        * 事件\n    * 进程控制信息\n        * 程序和数据的地址\n        * 进程同步和通信机制\n        * 资源清单\n        * 链接指针\n    * 进程控制块的组织方式\n        * 线性方式\n        * 链接方式\n        * 索引方式\n## 进程控制\n### 操作系统内核\n* 两大功能\n    * 支撑功能\n        * 中断管理\n        * 时钟管理\n        * 原语操作\n            * 进程的管理，由若干原语（primitive）来执行\n    * 资源管理功能\n        * 进程管理\n        * 存储器管理\n        * 设备管理\n* 状态\n    * 系统态，管态，内核态\n    * 用户态，目态\n### 进程的创建\n* 进程的层次结构\n    * 父进程\n    * 子进程\n* 引起创建进程的事件\n    * 用户登录\n    * 作业调度\n    * 提供服务\n    * 应用请求\n* 进程的创建过程\n    * 1.申请空白PCB\n    * 2.为新进程分配其运行所需的资源\n    * 3.初始化进程块PCB\n    * 4.如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列\n* 进程的终止\n    * 引起进程终止的事件\n        * 1.正常结束\n        * 2.异常结束\n        * 3.外界干预\n    * 进程的终止过程\n        * 1.根据被终止进程的标识符\n* 进程的阻塞与唤醒\n    * 引起进程阻塞和唤醒的事件\n        * 请求系统服务而未满足\n        * 启动某种操作而阻塞当前进程\n        * 新数据尚未到达\n        * 无新工作可做：系统进程\n    * 进程阻塞过程(自己阻塞自己)\n    * 进程唤醒过程(系统或其他进程唤醒自己)\n* 进程的挂起与激活\n    * suspend\n    * active\n### 进程同步\n* 基本概念\n    * 两种形式的制约关系\n        * 间接相互制约关系\n            * 互斥——竞争\n        * 直接相互制约关系\n            * 同步——协作\n    * 临界资源\n    * 分区\n        * 进入区enter section\n        * 临界区critical section\n        * 退出区exit section\n        * 剩余区remainder section\n    * 同步机制应遵循的规则\n        * 1.空闲让进\n        * 2.忙则等待\n        * 3.有限等待\n        * 4.让权等待\n* 进程同步机制\n    * 软件同步机制:都没有解决让权等待，而且部分方法还会产生死锁的情况\n    * 硬件同步机制\n        * 关中断\n        * 利用Test-and-Set指令实现互斥\n        * 利用swap指令实现进程互斥\n    * 信号量机制\n        * 整型信号量\n        * 记录型信号量\n            * 由于整型信号量没有遵循让权等待原则，记录型允许负数，即阻塞链表\n        * AND型信号量\n        * 信号量集\n            * 理解:AND型号量的wait和signal仅能对信号施以加1或减1操作，意味着每次只能对某类临界资源进行一个单位的申请或释放。当一次需要N个单位时，便要进行N次wait操作，这显然是低效的，甚至会增加死锁的概率。此外，在有些情况下，为确保系统的安全性，当所申请的资源数量低于某一下限值时，还必须进行管制，不予以分配。因此，当进程申请某类临界资源时，在每次分配前，都必须测试资源数量，判断是否大于可分配的下限值，决定是否予以分配\n            * 操作\n                * Swait(S1，t1，d1…Sn，tn，dn)\n                * Ssignal(S1，d1…Sn，dn)\n            * 特殊情况\n* 经典进程的同步问题\n    * 生产者–消费者问题\n    * 哲学家进餐问题\n    * 读者–写者问题\n## 进程通信\n### 进程通信是指进程之间的信息交换，又称低级进程通信\n### 进程通信的类型\n* 共享存储器系统\n    * 基于共享数据结构的通信方式\n        * 生产者和消费者\n    * 基于共享存储区的通信方式\n        * 高级通信\n* 管道通信系统(pipe)\n    * 高级通信\n* 消息传递系统\n    * 高级通信\n    * 方式分类\n        * 直接通信\n        * 间接通信\n* 客服机–服务器系统\n### 消息传递通信的实现方式\n* 直接消息传递系统\n* 信箱通信\n## 线程的基本概念\n### 线程的引入\n* 线程的引入正是为了简化线程间的通信，以小的开销来提高进程内的并发程度\n* 多线程并发的不足\n    * 进程的两个基本属性\n        * 一个拥有资源的独立单位，可独立分配系统资源\n        * 一个可独立调度和分派的基本单位，PCB\n    * 程序并发执行所需付出的时空开销\n        * 创建进程\n        * 撤销进程\n        * 进程切换\n    * 进程间通信效率低\n    * 将分配资源和调度两个属性分开\n* 线程——作为调度和分派的基本单位\n    * 进程是系统资源分配的单位，线程是处理器调度的单位\n    * 线程表示进程的一个控制点，可以执行一系列的指令。通常，和应用程序的一个函数相对应\n    * 进程分解为线程还可以有效利用多处理器和多核计算机\n### 线程与进程的比较\n* 不同点\n    * 调度的基本单位\n    * 并发性\n* 相似点\n    * 状态：运行、阻塞、就绪\n    * 线程具有一定的生命期\n    * 进程可创建线程，一个线程可创建另一个子线程\n    * 多个线程并发执行时仍然存在互斥与同步\n### 线程的实现\n* 线程的实现方式\n    * 内核支持线程KST\n    * 用户级线程ULT\n    * 组合方式\n* 多线程OS中的进程属性\n    * 进程是一个可拥有资源的基本单位\n    * 多个线程可并发执行\n    * 进程已不是可执行的实体\n* 线程的状态和线程控制块\n    * 线程运行的三个状态\n        * 执行状态\n        * 就绪状态\n        * 阻塞状态\n    * 线程控制块TCB\n","slug":"2023-06-14-2-进程的描述与控制","published":1,"date":"2023-12-15T02:31:42.011Z","updated":"2023-12-15T02:31:42.019Z","_id":"clq60joq100024zgshrsk40hf","title":"","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"第二章进程的描述与控制\"><a href=\"#第二章进程的描述与控制\" class=\"headerlink\" title=\"第二章进程的描述与控制\"></a>第二章进程的描述与控制</h1><h2 id=\"前驱图和程序执行\"><a href=\"#前驱图和程序执行\" class=\"headerlink\" title=\"前驱图和程序执行\"></a>前驱图和程序执行</h2><h2 id=\"程序并发执行\"><a href=\"#程序并发执行\" class=\"headerlink\" title=\"程序并发执行\"></a>程序并发执行</h2><h3 id=\"程序的并发执行\"><a href=\"#程序的并发执行\" class=\"headerlink\" title=\"程序的并发执行\"></a>程序的并发执行</h3><h3 id=\"程序并发执行时的特征\"><a href=\"#程序并发执行时的特征\" class=\"headerlink\" title=\"程序并发执行时的特征\"></a>程序并发执行时的特征</h3><ul>\n<li>间断性</li>\n<li>失去封闭性</li>\n<li>不可再现性</li>\n</ul>\n<h2 id=\"进程的描述\"><a href=\"#进程的描述\" class=\"headerlink\" title=\"进程的描述\"></a>进程的描述</h2><h3 id=\"进程的定义\"><a href=\"#进程的定义\" class=\"headerlink\" title=\"进程的定义\"></a>进程的定义</h3><ul>\n<li>进程是程序的一次执行</li>\n<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li>\n<li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li>\n</ul>\n<h3 id=\"进程的特征\"><a href=\"#进程的特征\" class=\"headerlink\" title=\"进程的特征\"></a>进程的特征</h3><ul>\n<li>动态性</li>\n<li>并发性</li>\n<li>独立性</li>\n<li>异步性</li>\n</ul>\n<h3 id=\"从操作系统角度分类\"><a href=\"#从操作系统角度分类\" class=\"headerlink\" title=\"从操作系统角度分类\"></a>从操作系统角度分类</h3><ul>\n<li>系统进程</li>\n<li>用户进程</li>\n</ul>\n<h3 id=\"进程和程序的区别\"><a href=\"#进程和程序的区别\" class=\"headerlink\" title=\"进程和程序的区别\"></a>进程和程序的区别</h3><ul>\n<li>进程是动态概念，而程序则是静态概念</li>\n<li>程序是指令的有序集合，永远存在；进程强调是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；</li>\n<li>进程具有并发性，而程序没有</li>\n<li>进程可创建其他进程，而程序并不能形成新的程序</li>\n<li>进程是竞争计算机资源的基本单位，程序不是</li>\n</ul>\n<h3 id=\"进程和程序的联系\"><a href=\"#进程和程序的联系\" class=\"headerlink\" title=\"进程和程序的联系\"></a>进程和程序的联系</h3><ul>\n<li>进程是程序在数据集上的一次执行</li>\n<li>程序是构成进程的组成部分，一个程序可对应多个进程，一个进程可包括多个程序</li>\n<li>进程的运行目标是执行所对应的程序</li>\n<li>从静态看，进程由程序、数据和进程控制块（PCB）组成</li>\n</ul>\n<h3 id=\"进程的基本状态及转换\"><a href=\"#进程的基本状态及转换\" class=\"headerlink\" title=\"进程的基本状态及转换\"></a>进程的基本状态及转换</h3><ul>\n<li>进程的三种基本状态<ul>\n<li>就绪状态ready</li>\n<li>执行状态running</li>\n<li>阻塞状态block</li>\n</ul>\n</li>\n<li>三种基本状态的转换</li>\n<li>创建状态和终止状态<ul>\n<li>五状态进程模型</li>\n</ul>\n</li>\n<li>注意<ul>\n<li>阻塞态-&gt;运行态和就绪态-&gt;阻塞态这二种状态转换不可能发生</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"挂起操作和进程状态的转换\"><a href=\"#挂起操作和进程状态的转换\" class=\"headerlink\" title=\"挂起操作和进程状态的转换\"></a>挂起操作和进程状态的转换</h3><ul>\n<li>挂起和阻塞的区别</li>\n<li>挂起操作的目的<ul>\n<li>终端用户的需要: 修改、检查进程</li>\n<li>父进程的需要：修改、协调子进程</li>\n<li>对换的需要：缓和内存</li>\n<li>负荷调节的需要：保证实时任务的执行</li>\n</ul>\n</li>\n<li>关键图</li>\n</ul>\n<h3 id=\"进程管理中的数据结构\"><a href=\"#进程管理中的数据结构\" class=\"headerlink\" title=\"进程管理中的数据结构\"></a>进程管理中的数据结构</h3><ul>\n<li>进程控制块PCB的作用<ul>\n<li>作为独立运行基本单位的标志</li>\n<li>能实现间断性运行方式</li>\n<li>提供进程管理所需要的信息</li>\n<li>提供进程调度所需要的信息</li>\n<li>实现与其他进程的同步与通信</li>\n</ul>\n</li>\n<li>进程控制块的信息<ul>\n<li>进程标识符<ul>\n<li>外部标识符PID</li>\n<li>内部标识符(端口)</li>\n</ul>\n</li>\n<li>处理机状态<ul>\n<li>通用寄存器</li>\n<li>指令计数器</li>\n<li>程序状态字PSW</li>\n<li>用户栈指针</li>\n</ul>\n</li>\n<li>进程调度信息<ul>\n<li>进程状态</li>\n<li>进程优先级</li>\n<li>进程调度所需的其他信息</li>\n<li>事件</li>\n</ul>\n</li>\n<li>进程控制信息<ul>\n<li>程序和数据的地址</li>\n<li>进程同步和通信机制</li>\n<li>资源清单</li>\n<li>链接指针</li>\n</ul>\n</li>\n<li>进程控制块的组织方式<ul>\n<li>线性方式</li>\n<li>链接方式</li>\n<li>索引方式</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h2><h3 id=\"操作系统内核\"><a href=\"#操作系统内核\" class=\"headerlink\" title=\"操作系统内核\"></a>操作系统内核</h3><ul>\n<li>两大功能<ul>\n<li>支撑功能<ul>\n<li>中断管理</li>\n<li>时钟管理</li>\n<li>原语操作<ul>\n<li>进程的管理，由若干原语（primitive）来执行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>资源管理功能<ul>\n<li>进程管理</li>\n<li>存储器管理</li>\n<li>设备管理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>状态<ul>\n<li>系统态，管态，内核态</li>\n<li>用户态，目态</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进程的创建\"><a href=\"#进程的创建\" class=\"headerlink\" title=\"进程的创建\"></a>进程的创建</h3><ul>\n<li>进程的层次结构<ul>\n<li>父进程</li>\n<li>子进程</li>\n</ul>\n</li>\n<li>引起创建进程的事件<ul>\n<li>用户登录</li>\n<li>作业调度</li>\n<li>提供服务</li>\n<li>应用请求</li>\n</ul>\n</li>\n<li>进程的创建过程<ul>\n<li>1.申请空白PCB</li>\n<li>2.为新进程分配其运行所需的资源</li>\n<li>3.初始化进程块PCB</li>\n<li>4.如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列</li>\n</ul>\n</li>\n<li>进程的终止<ul>\n<li>引起进程终止的事件<ul>\n<li>1.正常结束</li>\n<li>2.异常结束</li>\n<li>3.外界干预</li>\n</ul>\n</li>\n<li>进程的终止过程<ul>\n<li>1.根据被终止进程的标识符</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>进程的阻塞与唤醒<ul>\n<li>引起进程阻塞和唤醒的事件<ul>\n<li>请求系统服务而未满足</li>\n<li>启动某种操作而阻塞当前进程</li>\n<li>新数据尚未到达</li>\n<li>无新工作可做：系统进程</li>\n</ul>\n</li>\n<li>进程阻塞过程(自己阻塞自己)</li>\n<li>进程唤醒过程(系统或其他进程唤醒自己)</li>\n</ul>\n</li>\n<li>进程的挂起与激活<ul>\n<li>suspend</li>\n<li>active</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进程同步\"><a href=\"#进程同步\" class=\"headerlink\" title=\"进程同步\"></a>进程同步</h3><ul>\n<li>基本概念<ul>\n<li>两种形式的制约关系<ul>\n<li>间接相互制约关系<ul>\n<li>互斥——竞争</li>\n</ul>\n</li>\n<li>直接相互制约关系<ul>\n<li>同步——协作</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>临界资源</li>\n<li>分区<ul>\n<li>进入区enter section</li>\n<li>临界区critical section</li>\n<li>退出区exit section</li>\n<li>剩余区remainder section</li>\n</ul>\n</li>\n<li>同步机制应遵循的规则<ul>\n<li>1.空闲让进</li>\n<li>2.忙则等待</li>\n<li>3.有限等待</li>\n<li>4.让权等待</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>进程同步机制<ul>\n<li>软件同步机制:都没有解决让权等待，而且部分方法还会产生死锁的情况</li>\n<li>硬件同步机制<ul>\n<li>关中断</li>\n<li>利用Test-and-Set指令实现互斥</li>\n<li>利用swap指令实现进程互斥</li>\n</ul>\n</li>\n<li>信号量机制<ul>\n<li>整型信号量</li>\n<li>记录型信号量<ul>\n<li>由于整型信号量没有遵循让权等待原则，记录型允许负数，即阻塞链表</li>\n</ul>\n</li>\n<li>AND型信号量</li>\n<li>信号量集<ul>\n<li>理解:AND型号量的wait和signal仅能对信号施以加1或减1操作，意味着每次只能对某类临界资源进行一个单位的申请或释放。当一次需要N个单位时，便要进行N次wait操作，这显然是低效的，甚至会增加死锁的概率。此外，在有些情况下，为确保系统的安全性，当所申请的资源数量低于某一下限值时，还必须进行管制，不予以分配。因此，当进程申请某类临界资源时，在每次分配前，都必须测试资源数量，判断是否大于可分配的下限值，决定是否予以分配</li>\n<li>操作<ul>\n<li>Swait(S1，t1，d1…Sn，tn，dn)</li>\n<li>Ssignal(S1，d1…Sn，dn)</li>\n</ul>\n</li>\n<li>特殊情况</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>经典进程的同步问题<ul>\n<li>生产者–消费者问题</li>\n<li>哲学家进餐问题</li>\n<li>读者–写者问题</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h2><h3 id=\"进程通信是指进程之间的信息交换，又称低级进程通信\"><a href=\"#进程通信是指进程之间的信息交换，又称低级进程通信\" class=\"headerlink\" title=\"进程通信是指进程之间的信息交换，又称低级进程通信\"></a>进程通信是指进程之间的信息交换，又称低级进程通信</h3><h3 id=\"进程通信的类型\"><a href=\"#进程通信的类型\" class=\"headerlink\" title=\"进程通信的类型\"></a>进程通信的类型</h3><ul>\n<li>共享存储器系统<ul>\n<li>基于共享数据结构的通信方式<ul>\n<li>生产者和消费者</li>\n</ul>\n</li>\n<li>基于共享存储区的通信方式<ul>\n<li>高级通信</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>管道通信系统(pipe)<ul>\n<li>高级通信</li>\n</ul>\n</li>\n<li>消息传递系统<ul>\n<li>高级通信</li>\n<li>方式分类<ul>\n<li>直接通信</li>\n<li>间接通信</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>客服机–服务器系统</li>\n</ul>\n<h3 id=\"消息传递通信的实现方式\"><a href=\"#消息传递通信的实现方式\" class=\"headerlink\" title=\"消息传递通信的实现方式\"></a>消息传递通信的实现方式</h3><ul>\n<li>直接消息传递系统</li>\n<li>信箱通信</li>\n</ul>\n<h2 id=\"线程的基本概念\"><a href=\"#线程的基本概念\" class=\"headerlink\" title=\"线程的基本概念\"></a>线程的基本概念</h2><h3 id=\"线程的引入\"><a href=\"#线程的引入\" class=\"headerlink\" title=\"线程的引入\"></a>线程的引入</h3><ul>\n<li>线程的引入正是为了简化线程间的通信，以小的开销来提高进程内的并发程度</li>\n<li>多线程并发的不足<ul>\n<li>进程的两个基本属性<ul>\n<li>一个拥有资源的独立单位，可独立分配系统资源</li>\n<li>一个可独立调度和分派的基本单位，PCB</li>\n</ul>\n</li>\n<li>程序并发执行所需付出的时空开销<ul>\n<li>创建进程</li>\n<li>撤销进程</li>\n<li>进程切换</li>\n</ul>\n</li>\n<li>进程间通信效率低</li>\n<li>将分配资源和调度两个属性分开</li>\n</ul>\n</li>\n<li>线程——作为调度和分派的基本单位<ul>\n<li>进程是系统资源分配的单位，线程是处理器调度的单位</li>\n<li>线程表示进程的一个控制点，可以执行一系列的指令。通常，和应用程序的一个函数相对应</li>\n<li>进程分解为线程还可以有效利用多处理器和多核计算机</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程与进程的比较\"><a href=\"#线程与进程的比较\" class=\"headerlink\" title=\"线程与进程的比较\"></a>线程与进程的比较</h3><ul>\n<li>不同点<ul>\n<li>调度的基本单位</li>\n<li>并发性</li>\n</ul>\n</li>\n<li>相似点<ul>\n<li>状态：运行、阻塞、就绪</li>\n<li>线程具有一定的生命期</li>\n<li>进程可创建线程，一个线程可创建另一个子线程</li>\n<li>多个线程并发执行时仍然存在互斥与同步</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程的实现\"><a href=\"#线程的实现\" class=\"headerlink\" title=\"线程的实现\"></a>线程的实现</h3><ul>\n<li>线程的实现方式<ul>\n<li>内核支持线程KST</li>\n<li>用户级线程ULT</li>\n<li>组合方式</li>\n</ul>\n</li>\n<li>多线程OS中的进程属性<ul>\n<li>进程是一个可拥有资源的基本单位</li>\n<li>多个线程可并发执行</li>\n<li>进程已不是可执行的实体</li>\n</ul>\n</li>\n<li>线程的状态和线程控制块<ul>\n<li>线程运行的三个状态<ul>\n<li>执行状态</li>\n<li>就绪状态</li>\n<li>阻塞状态</li>\n</ul>\n</li>\n<li>线程控制块TCB</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"第二章进程的描述与控制\"><a href=\"#第二章进程的描述与控制\" class=\"headerlink\" title=\"第二章进程的描述与控制\"></a>第二章进程的描述与控制</h1><h2 id=\"前驱图和程序执行\"><a href=\"#前驱图和程序执行\" class=\"headerlink\" title=\"前驱图和程序执行\"></a>前驱图和程序执行</h2><h2 id=\"程序并发执行\"><a href=\"#程序并发执行\" class=\"headerlink\" title=\"程序并发执行\"></a>程序并发执行</h2><h3 id=\"程序的并发执行\"><a href=\"#程序的并发执行\" class=\"headerlink\" title=\"程序的并发执行\"></a>程序的并发执行</h3><h3 id=\"程序并发执行时的特征\"><a href=\"#程序并发执行时的特征\" class=\"headerlink\" title=\"程序并发执行时的特征\"></a>程序并发执行时的特征</h3><ul>\n<li>间断性</li>\n<li>失去封闭性</li>\n<li>不可再现性</li>\n</ul>\n<h2 id=\"进程的描述\"><a href=\"#进程的描述\" class=\"headerlink\" title=\"进程的描述\"></a>进程的描述</h2><h3 id=\"进程的定义\"><a href=\"#进程的定义\" class=\"headerlink\" title=\"进程的定义\"></a>进程的定义</h3><ul>\n<li>进程是程序的一次执行</li>\n<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li>\n<li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li>\n</ul>\n<h3 id=\"进程的特征\"><a href=\"#进程的特征\" class=\"headerlink\" title=\"进程的特征\"></a>进程的特征</h3><ul>\n<li>动态性</li>\n<li>并发性</li>\n<li>独立性</li>\n<li>异步性</li>\n</ul>\n<h3 id=\"从操作系统角度分类\"><a href=\"#从操作系统角度分类\" class=\"headerlink\" title=\"从操作系统角度分类\"></a>从操作系统角度分类</h3><ul>\n<li>系统进程</li>\n<li>用户进程</li>\n</ul>\n<h3 id=\"进程和程序的区别\"><a href=\"#进程和程序的区别\" class=\"headerlink\" title=\"进程和程序的区别\"></a>进程和程序的区别</h3><ul>\n<li>进程是动态概念，而程序则是静态概念</li>\n<li>程序是指令的有序集合，永远存在；进程强调是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；</li>\n<li>进程具有并发性，而程序没有</li>\n<li>进程可创建其他进程，而程序并不能形成新的程序</li>\n<li>进程是竞争计算机资源的基本单位，程序不是</li>\n</ul>\n<h3 id=\"进程和程序的联系\"><a href=\"#进程和程序的联系\" class=\"headerlink\" title=\"进程和程序的联系\"></a>进程和程序的联系</h3><ul>\n<li>进程是程序在数据集上的一次执行</li>\n<li>程序是构成进程的组成部分，一个程序可对应多个进程，一个进程可包括多个程序</li>\n<li>进程的运行目标是执行所对应的程序</li>\n<li>从静态看，进程由程序、数据和进程控制块（PCB）组成</li>\n</ul>\n<h3 id=\"进程的基本状态及转换\"><a href=\"#进程的基本状态及转换\" class=\"headerlink\" title=\"进程的基本状态及转换\"></a>进程的基本状态及转换</h3><ul>\n<li>进程的三种基本状态<ul>\n<li>就绪状态ready</li>\n<li>执行状态running</li>\n<li>阻塞状态block</li>\n</ul>\n</li>\n<li>三种基本状态的转换</li>\n<li>创建状态和终止状态<ul>\n<li>五状态进程模型</li>\n</ul>\n</li>\n<li>注意<ul>\n<li>阻塞态-&gt;运行态和就绪态-&gt;阻塞态这二种状态转换不可能发生</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"挂起操作和进程状态的转换\"><a href=\"#挂起操作和进程状态的转换\" class=\"headerlink\" title=\"挂起操作和进程状态的转换\"></a>挂起操作和进程状态的转换</h3><ul>\n<li>挂起和阻塞的区别</li>\n<li>挂起操作的目的<ul>\n<li>终端用户的需要: 修改、检查进程</li>\n<li>父进程的需要：修改、协调子进程</li>\n<li>对换的需要：缓和内存</li>\n<li>负荷调节的需要：保证实时任务的执行</li>\n</ul>\n</li>\n<li>关键图</li>\n</ul>\n<h3 id=\"进程管理中的数据结构\"><a href=\"#进程管理中的数据结构\" class=\"headerlink\" title=\"进程管理中的数据结构\"></a>进程管理中的数据结构</h3><ul>\n<li>进程控制块PCB的作用<ul>\n<li>作为独立运行基本单位的标志</li>\n<li>能实现间断性运行方式</li>\n<li>提供进程管理所需要的信息</li>\n<li>提供进程调度所需要的信息</li>\n<li>实现与其他进程的同步与通信</li>\n</ul>\n</li>\n<li>进程控制块的信息<ul>\n<li>进程标识符<ul>\n<li>外部标识符PID</li>\n<li>内部标识符(端口)</li>\n</ul>\n</li>\n<li>处理机状态<ul>\n<li>通用寄存器</li>\n<li>指令计数器</li>\n<li>程序状态字PSW</li>\n<li>用户栈指针</li>\n</ul>\n</li>\n<li>进程调度信息<ul>\n<li>进程状态</li>\n<li>进程优先级</li>\n<li>进程调度所需的其他信息</li>\n<li>事件</li>\n</ul>\n</li>\n<li>进程控制信息<ul>\n<li>程序和数据的地址</li>\n<li>进程同步和通信机制</li>\n<li>资源清单</li>\n<li>链接指针</li>\n</ul>\n</li>\n<li>进程控制块的组织方式<ul>\n<li>线性方式</li>\n<li>链接方式</li>\n<li>索引方式</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h2><h3 id=\"操作系统内核\"><a href=\"#操作系统内核\" class=\"headerlink\" title=\"操作系统内核\"></a>操作系统内核</h3><ul>\n<li>两大功能<ul>\n<li>支撑功能<ul>\n<li>中断管理</li>\n<li>时钟管理</li>\n<li>原语操作<ul>\n<li>进程的管理，由若干原语（primitive）来执行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>资源管理功能<ul>\n<li>进程管理</li>\n<li>存储器管理</li>\n<li>设备管理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>状态<ul>\n<li>系统态，管态，内核态</li>\n<li>用户态，目态</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进程的创建\"><a href=\"#进程的创建\" class=\"headerlink\" title=\"进程的创建\"></a>进程的创建</h3><ul>\n<li>进程的层次结构<ul>\n<li>父进程</li>\n<li>子进程</li>\n</ul>\n</li>\n<li>引起创建进程的事件<ul>\n<li>用户登录</li>\n<li>作业调度</li>\n<li>提供服务</li>\n<li>应用请求</li>\n</ul>\n</li>\n<li>进程的创建过程<ul>\n<li>1.申请空白PCB</li>\n<li>2.为新进程分配其运行所需的资源</li>\n<li>3.初始化进程块PCB</li>\n<li>4.如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列</li>\n</ul>\n</li>\n<li>进程的终止<ul>\n<li>引起进程终止的事件<ul>\n<li>1.正常结束</li>\n<li>2.异常结束</li>\n<li>3.外界干预</li>\n</ul>\n</li>\n<li>进程的终止过程<ul>\n<li>1.根据被终止进程的标识符</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>进程的阻塞与唤醒<ul>\n<li>引起进程阻塞和唤醒的事件<ul>\n<li>请求系统服务而未满足</li>\n<li>启动某种操作而阻塞当前进程</li>\n<li>新数据尚未到达</li>\n<li>无新工作可做：系统进程</li>\n</ul>\n</li>\n<li>进程阻塞过程(自己阻塞自己)</li>\n<li>进程唤醒过程(系统或其他进程唤醒自己)</li>\n</ul>\n</li>\n<li>进程的挂起与激活<ul>\n<li>suspend</li>\n<li>active</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进程同步\"><a href=\"#进程同步\" class=\"headerlink\" title=\"进程同步\"></a>进程同步</h3><ul>\n<li>基本概念<ul>\n<li>两种形式的制约关系<ul>\n<li>间接相互制约关系<ul>\n<li>互斥——竞争</li>\n</ul>\n</li>\n<li>直接相互制约关系<ul>\n<li>同步——协作</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>临界资源</li>\n<li>分区<ul>\n<li>进入区enter section</li>\n<li>临界区critical section</li>\n<li>退出区exit section</li>\n<li>剩余区remainder section</li>\n</ul>\n</li>\n<li>同步机制应遵循的规则<ul>\n<li>1.空闲让进</li>\n<li>2.忙则等待</li>\n<li>3.有限等待</li>\n<li>4.让权等待</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>进程同步机制<ul>\n<li>软件同步机制:都没有解决让权等待，而且部分方法还会产生死锁的情况</li>\n<li>硬件同步机制<ul>\n<li>关中断</li>\n<li>利用Test-and-Set指令实现互斥</li>\n<li>利用swap指令实现进程互斥</li>\n</ul>\n</li>\n<li>信号量机制<ul>\n<li>整型信号量</li>\n<li>记录型信号量<ul>\n<li>由于整型信号量没有遵循让权等待原则，记录型允许负数，即阻塞链表</li>\n</ul>\n</li>\n<li>AND型信号量</li>\n<li>信号量集<ul>\n<li>理解:AND型号量的wait和signal仅能对信号施以加1或减1操作，意味着每次只能对某类临界资源进行一个单位的申请或释放。当一次需要N个单位时，便要进行N次wait操作，这显然是低效的，甚至会增加死锁的概率。此外，在有些情况下，为确保系统的安全性，当所申请的资源数量低于某一下限值时，还必须进行管制，不予以分配。因此，当进程申请某类临界资源时，在每次分配前，都必须测试资源数量，判断是否大于可分配的下限值，决定是否予以分配</li>\n<li>操作<ul>\n<li>Swait(S1，t1，d1…Sn，tn，dn)</li>\n<li>Ssignal(S1，d1…Sn，dn)</li>\n</ul>\n</li>\n<li>特殊情况</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>经典进程的同步问题<ul>\n<li>生产者–消费者问题</li>\n<li>哲学家进餐问题</li>\n<li>读者–写者问题</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h2><h3 id=\"进程通信是指进程之间的信息交换，又称低级进程通信\"><a href=\"#进程通信是指进程之间的信息交换，又称低级进程通信\" class=\"headerlink\" title=\"进程通信是指进程之间的信息交换，又称低级进程通信\"></a>进程通信是指进程之间的信息交换，又称低级进程通信</h3><h3 id=\"进程通信的类型\"><a href=\"#进程通信的类型\" class=\"headerlink\" title=\"进程通信的类型\"></a>进程通信的类型</h3><ul>\n<li>共享存储器系统<ul>\n<li>基于共享数据结构的通信方式<ul>\n<li>生产者和消费者</li>\n</ul>\n</li>\n<li>基于共享存储区的通信方式<ul>\n<li>高级通信</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>管道通信系统(pipe)<ul>\n<li>高级通信</li>\n</ul>\n</li>\n<li>消息传递系统<ul>\n<li>高级通信</li>\n<li>方式分类<ul>\n<li>直接通信</li>\n<li>间接通信</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>客服机–服务器系统</li>\n</ul>\n<h3 id=\"消息传递通信的实现方式\"><a href=\"#消息传递通信的实现方式\" class=\"headerlink\" title=\"消息传递通信的实现方式\"></a>消息传递通信的实现方式</h3><ul>\n<li>直接消息传递系统</li>\n<li>信箱通信</li>\n</ul>\n<h2 id=\"线程的基本概念\"><a href=\"#线程的基本概念\" class=\"headerlink\" title=\"线程的基本概念\"></a>线程的基本概念</h2><h3 id=\"线程的引入\"><a href=\"#线程的引入\" class=\"headerlink\" title=\"线程的引入\"></a>线程的引入</h3><ul>\n<li>线程的引入正是为了简化线程间的通信，以小的开销来提高进程内的并发程度</li>\n<li>多线程并发的不足<ul>\n<li>进程的两个基本属性<ul>\n<li>一个拥有资源的独立单位，可独立分配系统资源</li>\n<li>一个可独立调度和分派的基本单位，PCB</li>\n</ul>\n</li>\n<li>程序并发执行所需付出的时空开销<ul>\n<li>创建进程</li>\n<li>撤销进程</li>\n<li>进程切换</li>\n</ul>\n</li>\n<li>进程间通信效率低</li>\n<li>将分配资源和调度两个属性分开</li>\n</ul>\n</li>\n<li>线程——作为调度和分派的基本单位<ul>\n<li>进程是系统资源分配的单位，线程是处理器调度的单位</li>\n<li>线程表示进程的一个控制点，可以执行一系列的指令。通常，和应用程序的一个函数相对应</li>\n<li>进程分解为线程还可以有效利用多处理器和多核计算机</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程与进程的比较\"><a href=\"#线程与进程的比较\" class=\"headerlink\" title=\"线程与进程的比较\"></a>线程与进程的比较</h3><ul>\n<li>不同点<ul>\n<li>调度的基本单位</li>\n<li>并发性</li>\n</ul>\n</li>\n<li>相似点<ul>\n<li>状态：运行、阻塞、就绪</li>\n<li>线程具有一定的生命期</li>\n<li>进程可创建线程，一个线程可创建另一个子线程</li>\n<li>多个线程并发执行时仍然存在互斥与同步</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程的实现\"><a href=\"#线程的实现\" class=\"headerlink\" title=\"线程的实现\"></a>线程的实现</h3><ul>\n<li>线程的实现方式<ul>\n<li>内核支持线程KST</li>\n<li>用户级线程ULT</li>\n<li>组合方式</li>\n</ul>\n</li>\n<li>多线程OS中的进程属性<ul>\n<li>进程是一个可拥有资源的基本单位</li>\n<li>多个线程可并发执行</li>\n<li>进程已不是可执行的实体</li>\n</ul>\n</li>\n<li>线程的状态和线程控制块<ul>\n<li>线程运行的三个状态<ul>\n<li>执行状态</li>\n<li>就绪状态</li>\n<li>阻塞状态</li>\n</ul>\n</li>\n<li>线程控制块TCB</li>\n</ul>\n</li>\n</ul>\n"},{"_content":"# 第三章:处理机调度与死锁\n## 处理机调度算法的目标\n### 处理机调度算法的共同目标\n* 资源利用率:CPU的利用率=CPU有效工作时间/(CPU有效工作时间+CPU空闲等待时间)\n* 公平性\n* 平衡性\n* 策略强制执行\n### 批处理系统的目标\n* 平均周转时间短\n* 系统吞吐量高\n* 处理机利用率高\n### 分时系统的目标\n* 响应时间快\n* 均衡性\n### 实时系统目标\n* 截止时间的保证\n* 可预测性\n### 处理机调度的层次\n* 高级调度（作业调度）\n    * 分时系统无需作业调度，因为需要交互\n    * 批处理系统需要作业调度\n* 中级调度（和挂起有关）\n* 低级调度（进程调度）\n    * 进程调度是最基本的调度，任何操作系统都有进程调度。\n    * 低级调度的三个基本机制\n        * 排队器\n        * 分派器\n        * 上下文切换\n    * 进程调度方式\n        * 非抢占方式\n        * 抢占方式\n            * 优先权原则\n            * 短进程优先原则\n            * 时间片原则\n    * 进程调度的任务\n        * 保存处理机的现场信息\n        * 按某种算法选取进程\n        * 把处理器分配给进程\n    * 进程调度的算法\n        * 优先级调度算法\n            * 优先级调度算法的类型\n                * 非抢占式优先级调度算法\n                    * 等当前进程执行完以后，再执行另一个优先权最高的进程\n                    * 这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。 \n                * 抢占式优先级调度算法\n                    * 不等当前进程结束，直接抢处理机\n                    * 常用于要求比较严格的实时系统中， 以及对性能要求较高的批处理和分时系统中。\n            * 优先级的类型\n                * 静态优先级\n                    * 优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，例如，0~7或0~255中的某一整数， 又把该整数称为优先数。\n                    * 可以参考BIOS系统中设置boot的优先级\n                * 动态优先级\n                    * 在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。\n        * 轮转调度算法\n            * 基本原理:在轮转(RR)法中，系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并可设置每隔一定时间间隔(如30ms)即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其执行\n            * 进程切换时机\n                * 时间片未用完，进程完成\n                * 时间片到，进程未完成\n            * 时间片大小的确定\n                * 太小利于短作业，增加系统切换开销\n                * 太长就退化为FCFS算法\n                * 一般选择: q略大于一次交互所需要的时间，使大多数进程在一个时间片内完成\n            * 一般来说，平均周转时间将比SJF长，但是有较好的响应时间\n        * 多队列调度算法\n        * 多级反馈队列调度算法\n            * 调度机制\n                * 设置多个就绪队列\n                * 每个队列都采用FCFS算法\n                * 按照队列优先级调度，在第n队列中采取按时间片轮转的方式运行\n            * 调度算法的性能\n                * 对于终端型用户，由于作业小，感觉满意\n                * 对于短批处理作业用户，周转时间也较小\n                * 长批处理作业用户，也能够得到执行\n        * 基于公平原则的调度算法\n            * 保证调度算法\n            * 公平分享调度算法\n## 作业与作业调度\n### 作业\n* 作业不仅包含程序和数据，还配有一份作业说明书，系统根据说明书对程序的运行进行控制。批处理系统是以作业为单位从外存掉入内存的。\n### 作业控制块JCB\n* 为每个作业设置一个JCB，保存了对作业管理调度的全部信息。是作业存在的标志。\n### 作业步\n* 作业步，每个作业都必须经过若干相对独立，有相互关联的顺序步骤才能得到结果。每一个步骤就是一个作业步。\n### 作业运行的三个阶段\n* 收容阶段\n* 运行阶段\n* 完成阶段\n### 作业运行的三个状态\n* 后备状态\n* 运行状态\n* 完成状态\n### 作业调度的主要任务\n* 接纳多少个作业\n* 接纳哪些作业\n### 先来先服务(first–come first–served，FCFS)调度算法\n* 比较有利于长作业，而不利于短作业。\n* 有利于CPU繁忙的作业，而不利于I/O繁忙的作业。\n### 短作业优先(short job first，SJF)的调度算法\n* 优点\n    * 比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；\n    * 提高系统的吞吐量；\n* 缺点\n    * 必须预知作业的运行时间\n    * 对长作业非常不利，长作业的周转时间会明显地增长\n    * 在采用SJF算法时，人–机无法实现交互\n    * 该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理\n### 优先级调度算法(priority–scheduling algorithm，PSA)\n### 高响应比优先调度算法(Highest Response Ratio Next,HRRN)\n* 原理\n    * 在每次选择作业投入运行时，先计算此时后备作业队列中每个作业的响应比RP然后选择其值最大的作业投入运行\n    * 优先权=(等待时间+要求服务时间)/要求服务时间=响应时间/要求服务时间=1+等待时间/要求服务时间\n* 特点\n    * 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而类似于SJF算法，有利于短作业\n    * 当要求服务的时间相同时，作业的优先权又决定于其等待时间，因而该算法又类似于FCFS算法\n    * 对于长时间的优先级，可以为随等待时间的增加而提高，当等待时间足够长时，也可获得处理机\n## 实时调度(HRT和SRT任务)\n### 实现实时调度的基本条件\n* 提供必要信息\n    * 就绪时间\n    * 开始截止时间和完成截止时间\n    * 处理时间\n    * 资源要求\n    * 优先级\n* 系统处理能力强\n    * ∑(Ci/Pi)≤1\n    * N个处理机:∑(Ci/Pi)≤N\n* 采用抢占式调度机制\n* 具有快速切换机制\n    * 对中断的快速响应能力\n    * 快速的任务分派能力\n### 实时调度算法的分类\n* 非抢占式调度算法\n    * 非抢占式轮转调度算法\n    * 非抢占式优先调度算法\n* 抢占式调度算法\n    * 基于时钟中断的抢占式优先级调度算法\n    * 立即抢占的优先级调度算法\n### 最早截止时间优先EDF(Earliest Deadline First)算法\n* 根据任务的开始截至时间来确定任务的优先级\n    * 截至时间越早，优先级越高\n* 非抢占式调度方式用于非周期实时任务\n* 抢占式调度方式用于周期实时任务\n### 最低松弛度优先LLF(Least Laxity First)算法\n* 类似EDF\n* 算法根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高， 以使之优先执行。\n* 松弛度例子\n    * 例如，一个任务在200ms时必须完成，而它本身所需的运行时间就有100ms，因此，调度程序必须在100 ms之前调度执行，该任务的紧急程度(松弛程度)为100 ms\n### 优先级倒置(Priority inversion problem)\n* 优先级倒置的形成\n    * 高优先级进程被低优先级进程延迟或阻塞。\n* 优先级倒置的解决方法\n    * 简单的:假如进程P3在进入临界区后P3所占用的处理机就不允许被抢占\n    * 实用的:建立在动态优先级继承基础上的\n## 死锁概述\n### 资源问题\n* 可重用性资源\n    * 计算机外设\n* 消耗性资源\n    * 数据，消息\n* 可抢占性资源\n    *  不引起死锁\n    * CPU，内存 \n* 不可抢占性资源\n    * 光驱，打印机\n### 计算机系统中的死锁\n* 竞争不可抢占性资源引起死锁\n* 竞争可消耗资源引起死锁\n* 进程推进顺序不当引起死锁\n### 死锁的定义，必要条件和处理方法\n* 定义:如果一组进程中的每一个进程都在等待仅由该进程中的其他进程才能引发的事件，那么该组进程是死锁的\n* 产生死锁的必要条件\n    * 互斥条件\n    * 请求和保存条件\n    * 不可抢占条件\n    * 循环等待条件\n        * 如果每个资源只有一个实例，则环路等待条件是死锁存在的充分必要条件\n* 处理死锁的方法\n    * 预防死锁\n        * 静态方法，在进程执行前采取的措施，通过设置某些限制条件，去破坏产生死锁的四个条件之一，防止发生死锁。\n        * 预防死锁的策略\n            * 破坏\"请求和保存\"条件\n                * 第一种协议\n                    * 所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源\n                    * 优点:简单，易行，安全\n                    * 缺点\n                        * 资源被严重浪费，严重地恶化了资源的利用率\n                        * 使进程经常会发生饥饿现象\n                * 第二种协议\n                    * 它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的，且已用毕的全部资源，然后再请求新的所需资源\n            * 破坏\"不可抢占\"条件\n                * 当一个已经保存了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请\n            * 破坏\"循环等待\"条件\n                * 对系统所以资源类型进行线性排序，并赋予不同的序号\n                * 例如令输入机的序号为1，打印机序号为2，磁盘机序号为3等。所有进程对资源的请求必须严格按资源序号递增的次序提出。\n    * 避免死锁\n        * 动态的方法，在进程执行过程中采取的措施，不需事先采取限制措施破坏产生死锁的必要条件，而是在进程申请资源时用某种方法去防止系统进入不安全状态，从而避免发生死锁。如银行家算法\n        * 避免死锁的策略\n            * 系统安全状态\n                * 安全状态\n                    * 某时刻，对于并发执行的n个进程，若系统能够按照某种顺序如<p1,p2…pn>来为每个进程分配所需资源，直至最大需求，从而使每个进程都可顺利完成，则认为该时刻系统处于安全状态，这样的序列为安全序列\n                * 安全状态之例\n                * 由安全状态向不安全状态的转换\n            * 利用银行家算法避免死锁\n                * 含义:每一个新进程在进入系统时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给它，否则让进程等待\n                * 银行家算法中的数据结构\n                    * 可用资源向量 Available[m]：m为系统中资源种类数，Available[j]=k表示系统中第j类资源数为k个。\n                    * 最大需求矩阵 Max[n,m]：n为系统中进程数，Max[i,j]=k表示进程i对j类资源的最大需求数为中k。\n                    * 分配矩阵 Allocation[n，m]:它定义了系统中每一类资源当前已分配给每一进程资源数，   Allocation[i,j] = k表示进程i已分得j类资源的数目为k个。\n                    * 需求矩阵 Need[n,m]：它表示每个进程尚需的各类资源数，Need[i,j]=k 表示进程i   还需要j类资源k个。Need[i,j]=Max[i,j] - Allocation[i,j]\n                * 银行家算法\n                * 安全性算法\n                * 银行家算法之例\n                * 解题\n                    * 矩阵\n                    * 列表\n    * 检测死锁\n        * 死锁的检测与解除\n            * 死锁的检测\n                * 资源分配图\n                    * 简化步骤\n                        * 选择一个没有阻塞的进程p\n                        * 将p移走，包括它的所有请求边和分配边\n                        * 重复步骤1，2，直至不能继续下去\n                * 死锁定理\n                    * 若一系列简化以后不能使所有的进程节点都成为孤立节点\n                * 检测时机\n                    *  当进程等待时检测死锁 （其缺点是系统的开销大）\n                    *  定时检测\n                    *  系统资源利用率下降时检测死锁\n                * 死锁检测中的数据结构\n            * 死锁的解除\n                * 抢占资源\n                * 终止(或撤销)进程\n                * 终止进程的方法\n                    * 终止所有死锁进程\n                    * 逐个终止进程\n                        * 代价最小\n                            * 进程的优先级的大小\n                            * 进程已执行了多少时间，还需时间\n                            * 进程在运行中已经使用资源的多少，还需多少资源\n                            * 进程的性质是交互式还是批处理的\n                * 付出代价最小的死锁解除算法\n                    * 是使用一个有效的挂起和解除机构来挂起一些死锁的进程\n    * 解除死锁\n","source":"_posts/2023-06-14-3-处理机调度与死锁.md","raw":"# 第三章:处理机调度与死锁\n## 处理机调度算法的目标\n### 处理机调度算法的共同目标\n* 资源利用率:CPU的利用率=CPU有效工作时间/(CPU有效工作时间+CPU空闲等待时间)\n* 公平性\n* 平衡性\n* 策略强制执行\n### 批处理系统的目标\n* 平均周转时间短\n* 系统吞吐量高\n* 处理机利用率高\n### 分时系统的目标\n* 响应时间快\n* 均衡性\n### 实时系统目标\n* 截止时间的保证\n* 可预测性\n### 处理机调度的层次\n* 高级调度（作业调度）\n    * 分时系统无需作业调度，因为需要交互\n    * 批处理系统需要作业调度\n* 中级调度（和挂起有关）\n* 低级调度（进程调度）\n    * 进程调度是最基本的调度，任何操作系统都有进程调度。\n    * 低级调度的三个基本机制\n        * 排队器\n        * 分派器\n        * 上下文切换\n    * 进程调度方式\n        * 非抢占方式\n        * 抢占方式\n            * 优先权原则\n            * 短进程优先原则\n            * 时间片原则\n    * 进程调度的任务\n        * 保存处理机的现场信息\n        * 按某种算法选取进程\n        * 把处理器分配给进程\n    * 进程调度的算法\n        * 优先级调度算法\n            * 优先级调度算法的类型\n                * 非抢占式优先级调度算法\n                    * 等当前进程执行完以后，再执行另一个优先权最高的进程\n                    * 这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。 \n                * 抢占式优先级调度算法\n                    * 不等当前进程结束，直接抢处理机\n                    * 常用于要求比较严格的实时系统中， 以及对性能要求较高的批处理和分时系统中。\n            * 优先级的类型\n                * 静态优先级\n                    * 优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，例如，0~7或0~255中的某一整数， 又把该整数称为优先数。\n                    * 可以参考BIOS系统中设置boot的优先级\n                * 动态优先级\n                    * 在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。\n        * 轮转调度算法\n            * 基本原理:在轮转(RR)法中，系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并可设置每隔一定时间间隔(如30ms)即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其执行\n            * 进程切换时机\n                * 时间片未用完，进程完成\n                * 时间片到，进程未完成\n            * 时间片大小的确定\n                * 太小利于短作业，增加系统切换开销\n                * 太长就退化为FCFS算法\n                * 一般选择: q略大于一次交互所需要的时间，使大多数进程在一个时间片内完成\n            * 一般来说，平均周转时间将比SJF长，但是有较好的响应时间\n        * 多队列调度算法\n        * 多级反馈队列调度算法\n            * 调度机制\n                * 设置多个就绪队列\n                * 每个队列都采用FCFS算法\n                * 按照队列优先级调度，在第n队列中采取按时间片轮转的方式运行\n            * 调度算法的性能\n                * 对于终端型用户，由于作业小，感觉满意\n                * 对于短批处理作业用户，周转时间也较小\n                * 长批处理作业用户，也能够得到执行\n        * 基于公平原则的调度算法\n            * 保证调度算法\n            * 公平分享调度算法\n## 作业与作业调度\n### 作业\n* 作业不仅包含程序和数据，还配有一份作业说明书，系统根据说明书对程序的运行进行控制。批处理系统是以作业为单位从外存掉入内存的。\n### 作业控制块JCB\n* 为每个作业设置一个JCB，保存了对作业管理调度的全部信息。是作业存在的标志。\n### 作业步\n* 作业步，每个作业都必须经过若干相对独立，有相互关联的顺序步骤才能得到结果。每一个步骤就是一个作业步。\n### 作业运行的三个阶段\n* 收容阶段\n* 运行阶段\n* 完成阶段\n### 作业运行的三个状态\n* 后备状态\n* 运行状态\n* 完成状态\n### 作业调度的主要任务\n* 接纳多少个作业\n* 接纳哪些作业\n### 先来先服务(first–come first–served，FCFS)调度算法\n* 比较有利于长作业，而不利于短作业。\n* 有利于CPU繁忙的作业，而不利于I/O繁忙的作业。\n### 短作业优先(short job first，SJF)的调度算法\n* 优点\n    * 比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；\n    * 提高系统的吞吐量；\n* 缺点\n    * 必须预知作业的运行时间\n    * 对长作业非常不利，长作业的周转时间会明显地增长\n    * 在采用SJF算法时，人–机无法实现交互\n    * 该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理\n### 优先级调度算法(priority–scheduling algorithm，PSA)\n### 高响应比优先调度算法(Highest Response Ratio Next,HRRN)\n* 原理\n    * 在每次选择作业投入运行时，先计算此时后备作业队列中每个作业的响应比RP然后选择其值最大的作业投入运行\n    * 优先权=(等待时间+要求服务时间)/要求服务时间=响应时间/要求服务时间=1+等待时间/要求服务时间\n* 特点\n    * 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而类似于SJF算法，有利于短作业\n    * 当要求服务的时间相同时，作业的优先权又决定于其等待时间，因而该算法又类似于FCFS算法\n    * 对于长时间的优先级，可以为随等待时间的增加而提高，当等待时间足够长时，也可获得处理机\n## 实时调度(HRT和SRT任务)\n### 实现实时调度的基本条件\n* 提供必要信息\n    * 就绪时间\n    * 开始截止时间和完成截止时间\n    * 处理时间\n    * 资源要求\n    * 优先级\n* 系统处理能力强\n    * ∑(Ci/Pi)≤1\n    * N个处理机:∑(Ci/Pi)≤N\n* 采用抢占式调度机制\n* 具有快速切换机制\n    * 对中断的快速响应能力\n    * 快速的任务分派能力\n### 实时调度算法的分类\n* 非抢占式调度算法\n    * 非抢占式轮转调度算法\n    * 非抢占式优先调度算法\n* 抢占式调度算法\n    * 基于时钟中断的抢占式优先级调度算法\n    * 立即抢占的优先级调度算法\n### 最早截止时间优先EDF(Earliest Deadline First)算法\n* 根据任务的开始截至时间来确定任务的优先级\n    * 截至时间越早，优先级越高\n* 非抢占式调度方式用于非周期实时任务\n* 抢占式调度方式用于周期实时任务\n### 最低松弛度优先LLF(Least Laxity First)算法\n* 类似EDF\n* 算法根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高， 以使之优先执行。\n* 松弛度例子\n    * 例如，一个任务在200ms时必须完成，而它本身所需的运行时间就有100ms，因此，调度程序必须在100 ms之前调度执行，该任务的紧急程度(松弛程度)为100 ms\n### 优先级倒置(Priority inversion problem)\n* 优先级倒置的形成\n    * 高优先级进程被低优先级进程延迟或阻塞。\n* 优先级倒置的解决方法\n    * 简单的:假如进程P3在进入临界区后P3所占用的处理机就不允许被抢占\n    * 实用的:建立在动态优先级继承基础上的\n## 死锁概述\n### 资源问题\n* 可重用性资源\n    * 计算机外设\n* 消耗性资源\n    * 数据，消息\n* 可抢占性资源\n    *  不引起死锁\n    * CPU，内存 \n* 不可抢占性资源\n    * 光驱，打印机\n### 计算机系统中的死锁\n* 竞争不可抢占性资源引起死锁\n* 竞争可消耗资源引起死锁\n* 进程推进顺序不当引起死锁\n### 死锁的定义，必要条件和处理方法\n* 定义:如果一组进程中的每一个进程都在等待仅由该进程中的其他进程才能引发的事件，那么该组进程是死锁的\n* 产生死锁的必要条件\n    * 互斥条件\n    * 请求和保存条件\n    * 不可抢占条件\n    * 循环等待条件\n        * 如果每个资源只有一个实例，则环路等待条件是死锁存在的充分必要条件\n* 处理死锁的方法\n    * 预防死锁\n        * 静态方法，在进程执行前采取的措施，通过设置某些限制条件，去破坏产生死锁的四个条件之一，防止发生死锁。\n        * 预防死锁的策略\n            * 破坏\"请求和保存\"条件\n                * 第一种协议\n                    * 所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源\n                    * 优点:简单，易行，安全\n                    * 缺点\n                        * 资源被严重浪费，严重地恶化了资源的利用率\n                        * 使进程经常会发生饥饿现象\n                * 第二种协议\n                    * 它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的，且已用毕的全部资源，然后再请求新的所需资源\n            * 破坏\"不可抢占\"条件\n                * 当一个已经保存了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请\n            * 破坏\"循环等待\"条件\n                * 对系统所以资源类型进行线性排序，并赋予不同的序号\n                * 例如令输入机的序号为1，打印机序号为2，磁盘机序号为3等。所有进程对资源的请求必须严格按资源序号递增的次序提出。\n    * 避免死锁\n        * 动态的方法，在进程执行过程中采取的措施，不需事先采取限制措施破坏产生死锁的必要条件，而是在进程申请资源时用某种方法去防止系统进入不安全状态，从而避免发生死锁。如银行家算法\n        * 避免死锁的策略\n            * 系统安全状态\n                * 安全状态\n                    * 某时刻，对于并发执行的n个进程，若系统能够按照某种顺序如<p1,p2…pn>来为每个进程分配所需资源，直至最大需求，从而使每个进程都可顺利完成，则认为该时刻系统处于安全状态，这样的序列为安全序列\n                * 安全状态之例\n                * 由安全状态向不安全状态的转换\n            * 利用银行家算法避免死锁\n                * 含义:每一个新进程在进入系统时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给它，否则让进程等待\n                * 银行家算法中的数据结构\n                    * 可用资源向量 Available[m]：m为系统中资源种类数，Available[j]=k表示系统中第j类资源数为k个。\n                    * 最大需求矩阵 Max[n,m]：n为系统中进程数，Max[i,j]=k表示进程i对j类资源的最大需求数为中k。\n                    * 分配矩阵 Allocation[n，m]:它定义了系统中每一类资源当前已分配给每一进程资源数，   Allocation[i,j] = k表示进程i已分得j类资源的数目为k个。\n                    * 需求矩阵 Need[n,m]：它表示每个进程尚需的各类资源数，Need[i,j]=k 表示进程i   还需要j类资源k个。Need[i,j]=Max[i,j] - Allocation[i,j]\n                * 银行家算法\n                * 安全性算法\n                * 银行家算法之例\n                * 解题\n                    * 矩阵\n                    * 列表\n    * 检测死锁\n        * 死锁的检测与解除\n            * 死锁的检测\n                * 资源分配图\n                    * 简化步骤\n                        * 选择一个没有阻塞的进程p\n                        * 将p移走，包括它的所有请求边和分配边\n                        * 重复步骤1，2，直至不能继续下去\n                * 死锁定理\n                    * 若一系列简化以后不能使所有的进程节点都成为孤立节点\n                * 检测时机\n                    *  当进程等待时检测死锁 （其缺点是系统的开销大）\n                    *  定时检测\n                    *  系统资源利用率下降时检测死锁\n                * 死锁检测中的数据结构\n            * 死锁的解除\n                * 抢占资源\n                * 终止(或撤销)进程\n                * 终止进程的方法\n                    * 终止所有死锁进程\n                    * 逐个终止进程\n                        * 代价最小\n                            * 进程的优先级的大小\n                            * 进程已执行了多少时间，还需时间\n                            * 进程在运行中已经使用资源的多少，还需多少资源\n                            * 进程的性质是交互式还是批处理的\n                * 付出代价最小的死锁解除算法\n                    * 是使用一个有效的挂起和解除机构来挂起一些死锁的进程\n    * 解除死锁\n","slug":"2023-06-14-3-处理机调度与死锁","published":1,"date":"2023-12-15T02:31:42.031Z","updated":"2023-12-15T02:31:42.039Z","_id":"clq60joqp00034zgsdqxde7s9","title":"","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"第三章-处理机调度与死锁\"><a href=\"#第三章-处理机调度与死锁\" class=\"headerlink\" title=\"第三章:处理机调度与死锁\"></a>第三章:处理机调度与死锁</h1><h2 id=\"处理机调度算法的目标\"><a href=\"#处理机调度算法的目标\" class=\"headerlink\" title=\"处理机调度算法的目标\"></a>处理机调度算法的目标</h2><h3 id=\"处理机调度算法的共同目标\"><a href=\"#处理机调度算法的共同目标\" class=\"headerlink\" title=\"处理机调度算法的共同目标\"></a>处理机调度算法的共同目标</h3><ul>\n<li>资源利用率:CPU的利用率&#x3D;CPU有效工作时间&#x2F;(CPU有效工作时间+CPU空闲等待时间)</li>\n<li>公平性</li>\n<li>平衡性</li>\n<li>策略强制执行</li>\n</ul>\n<h3 id=\"批处理系统的目标\"><a href=\"#批处理系统的目标\" class=\"headerlink\" title=\"批处理系统的目标\"></a>批处理系统的目标</h3><ul>\n<li>平均周转时间短</li>\n<li>系统吞吐量高</li>\n<li>处理机利用率高</li>\n</ul>\n<h3 id=\"分时系统的目标\"><a href=\"#分时系统的目标\" class=\"headerlink\" title=\"分时系统的目标\"></a>分时系统的目标</h3><ul>\n<li>响应时间快</li>\n<li>均衡性</li>\n</ul>\n<h3 id=\"实时系统目标\"><a href=\"#实时系统目标\" class=\"headerlink\" title=\"实时系统目标\"></a>实时系统目标</h3><ul>\n<li>截止时间的保证</li>\n<li>可预测性</li>\n</ul>\n<h3 id=\"处理机调度的层次\"><a href=\"#处理机调度的层次\" class=\"headerlink\" title=\"处理机调度的层次\"></a>处理机调度的层次</h3><ul>\n<li>高级调度（作业调度）<ul>\n<li>分时系统无需作业调度，因为需要交互</li>\n<li>批处理系统需要作业调度</li>\n</ul>\n</li>\n<li>中级调度（和挂起有关）</li>\n<li>低级调度（进程调度）<ul>\n<li>进程调度是最基本的调度，任何操作系统都有进程调度。</li>\n<li>低级调度的三个基本机制<ul>\n<li>排队器</li>\n<li>分派器</li>\n<li>上下文切换</li>\n</ul>\n</li>\n<li>进程调度方式<ul>\n<li>非抢占方式</li>\n<li>抢占方式<ul>\n<li>优先权原则</li>\n<li>短进程优先原则</li>\n<li>时间片原则</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>进程调度的任务<ul>\n<li>保存处理机的现场信息</li>\n<li>按某种算法选取进程</li>\n<li>把处理器分配给进程</li>\n</ul>\n</li>\n<li>进程调度的算法<ul>\n<li>优先级调度算法<ul>\n<li>优先级调度算法的类型<ul>\n<li>非抢占式优先级调度算法<ul>\n<li>等当前进程执行完以后，再执行另一个优先权最高的进程</li>\n<li>这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</li>\n</ul>\n</li>\n<li>抢占式优先级调度算法<ul>\n<li>不等当前进程结束，直接抢处理机</li>\n<li>常用于要求比较严格的实时系统中， 以及对性能要求较高的批处理和分时系统中。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>优先级的类型<ul>\n<li>静态优先级<ul>\n<li>优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，例如，0<del>7或0</del>255中的某一整数， 又把该整数称为优先数。</li>\n<li>可以参考BIOS系统中设置boot的优先级</li>\n</ul>\n</li>\n<li>动态优先级<ul>\n<li>在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>轮转调度算法<ul>\n<li>基本原理:在轮转(RR)法中，系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并可设置每隔一定时间间隔(如30ms)即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其执行</li>\n<li>进程切换时机<ul>\n<li>时间片未用完，进程完成</li>\n<li>时间片到，进程未完成</li>\n</ul>\n</li>\n<li>时间片大小的确定<ul>\n<li>太小利于短作业，增加系统切换开销</li>\n<li>太长就退化为FCFS算法</li>\n<li>一般选择: q略大于一次交互所需要的时间，使大多数进程在一个时间片内完成</li>\n</ul>\n</li>\n<li>一般来说，平均周转时间将比SJF长，但是有较好的响应时间</li>\n</ul>\n</li>\n<li>多队列调度算法</li>\n<li>多级反馈队列调度算法<ul>\n<li>调度机制<ul>\n<li>设置多个就绪队列</li>\n<li>每个队列都采用FCFS算法</li>\n<li>按照队列优先级调度，在第n队列中采取按时间片轮转的方式运行</li>\n</ul>\n</li>\n<li>调度算法的性能<ul>\n<li>对于终端型用户，由于作业小，感觉满意</li>\n<li>对于短批处理作业用户，周转时间也较小</li>\n<li>长批处理作业用户，也能够得到执行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>基于公平原则的调度算法<ul>\n<li>保证调度算法</li>\n<li>公平分享调度算法</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"作业与作业调度\"><a href=\"#作业与作业调度\" class=\"headerlink\" title=\"作业与作业调度\"></a>作业与作业调度</h2><h3 id=\"作业\"><a href=\"#作业\" class=\"headerlink\" title=\"作业\"></a>作业</h3><ul>\n<li>作业不仅包含程序和数据，还配有一份作业说明书，系统根据说明书对程序的运行进行控制。批处理系统是以作业为单位从外存掉入内存的。</li>\n</ul>\n<h3 id=\"作业控制块JCB\"><a href=\"#作业控制块JCB\" class=\"headerlink\" title=\"作业控制块JCB\"></a>作业控制块JCB</h3><ul>\n<li>为每个作业设置一个JCB，保存了对作业管理调度的全部信息。是作业存在的标志。</li>\n</ul>\n<h3 id=\"作业步\"><a href=\"#作业步\" class=\"headerlink\" title=\"作业步\"></a>作业步</h3><ul>\n<li>作业步，每个作业都必须经过若干相对独立，有相互关联的顺序步骤才能得到结果。每一个步骤就是一个作业步。</li>\n</ul>\n<h3 id=\"作业运行的三个阶段\"><a href=\"#作业运行的三个阶段\" class=\"headerlink\" title=\"作业运行的三个阶段\"></a>作业运行的三个阶段</h3><ul>\n<li>收容阶段</li>\n<li>运行阶段</li>\n<li>完成阶段</li>\n</ul>\n<h3 id=\"作业运行的三个状态\"><a href=\"#作业运行的三个状态\" class=\"headerlink\" title=\"作业运行的三个状态\"></a>作业运行的三个状态</h3><ul>\n<li>后备状态</li>\n<li>运行状态</li>\n<li>完成状态</li>\n</ul>\n<h3 id=\"作业调度的主要任务\"><a href=\"#作业调度的主要任务\" class=\"headerlink\" title=\"作业调度的主要任务\"></a>作业调度的主要任务</h3><ul>\n<li>接纳多少个作业</li>\n<li>接纳哪些作业</li>\n</ul>\n<h3 id=\"先来先服务-first–come-first–served，FCFS-调度算法\"><a href=\"#先来先服务-first–come-first–served，FCFS-调度算法\" class=\"headerlink\" title=\"先来先服务(first–come first–served，FCFS)调度算法\"></a>先来先服务(first–come first–served，FCFS)调度算法</h3><ul>\n<li>比较有利于长作业，而不利于短作业。</li>\n<li>有利于CPU繁忙的作业，而不利于I&#x2F;O繁忙的作业。</li>\n</ul>\n<h3 id=\"短作业优先-short-job-first，SJF-的调度算法\"><a href=\"#短作业优先-short-job-first，SJF-的调度算法\" class=\"headerlink\" title=\"短作业优先(short job first，SJF)的调度算法\"></a>短作业优先(short job first，SJF)的调度算法</h3><ul>\n<li>优点<ul>\n<li>比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；</li>\n<li>提高系统的吞吐量；</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>必须预知作业的运行时间</li>\n<li>对长作业非常不利，长作业的周转时间会明显地增长</li>\n<li>在采用SJF算法时，人–机无法实现交互</li>\n<li>该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"优先级调度算法-priority–scheduling-algorithm，PSA\"><a href=\"#优先级调度算法-priority–scheduling-algorithm，PSA\" class=\"headerlink\" title=\"优先级调度算法(priority–scheduling algorithm，PSA)\"></a>优先级调度算法(priority–scheduling algorithm，PSA)</h3><h3 id=\"高响应比优先调度算法-Highest-Response-Ratio-Next-HRRN\"><a href=\"#高响应比优先调度算法-Highest-Response-Ratio-Next-HRRN\" class=\"headerlink\" title=\"高响应比优先调度算法(Highest Response Ratio Next,HRRN)\"></a>高响应比优先调度算法(Highest Response Ratio Next,HRRN)</h3><ul>\n<li>原理<ul>\n<li>在每次选择作业投入运行时，先计算此时后备作业队列中每个作业的响应比RP然后选择其值最大的作业投入运行</li>\n<li>优先权&#x3D;(等待时间+要求服务时间)&#x2F;要求服务时间&#x3D;响应时间&#x2F;要求服务时间&#x3D;1+等待时间&#x2F;要求服务时间</li>\n</ul>\n</li>\n<li>特点<ul>\n<li>如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而类似于SJF算法，有利于短作业</li>\n<li>当要求服务的时间相同时，作业的优先权又决定于其等待时间，因而该算法又类似于FCFS算法</li>\n<li>对于长时间的优先级，可以为随等待时间的增加而提高，当等待时间足够长时，也可获得处理机</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"实时调度-HRT和SRT任务\"><a href=\"#实时调度-HRT和SRT任务\" class=\"headerlink\" title=\"实时调度(HRT和SRT任务)\"></a>实时调度(HRT和SRT任务)</h2><h3 id=\"实现实时调度的基本条件\"><a href=\"#实现实时调度的基本条件\" class=\"headerlink\" title=\"实现实时调度的基本条件\"></a>实现实时调度的基本条件</h3><ul>\n<li>提供必要信息<ul>\n<li>就绪时间</li>\n<li>开始截止时间和完成截止时间</li>\n<li>处理时间</li>\n<li>资源要求</li>\n<li>优先级</li>\n</ul>\n</li>\n<li>系统处理能力强<ul>\n<li>∑(Ci&#x2F;Pi)≤1</li>\n<li>N个处理机:∑(Ci&#x2F;Pi)≤N</li>\n</ul>\n</li>\n<li>采用抢占式调度机制</li>\n<li>具有快速切换机制<ul>\n<li>对中断的快速响应能力</li>\n<li>快速的任务分派能力</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"实时调度算法的分类\"><a href=\"#实时调度算法的分类\" class=\"headerlink\" title=\"实时调度算法的分类\"></a>实时调度算法的分类</h3><ul>\n<li>非抢占式调度算法<ul>\n<li>非抢占式轮转调度算法</li>\n<li>非抢占式优先调度算法</li>\n</ul>\n</li>\n<li>抢占式调度算法<ul>\n<li>基于时钟中断的抢占式优先级调度算法</li>\n<li>立即抢占的优先级调度算法</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"最早截止时间优先EDF-Earliest-Deadline-First-算法\"><a href=\"#最早截止时间优先EDF-Earliest-Deadline-First-算法\" class=\"headerlink\" title=\"最早截止时间优先EDF(Earliest Deadline First)算法\"></a>最早截止时间优先EDF(Earliest Deadline First)算法</h3><ul>\n<li>根据任务的开始截至时间来确定任务的优先级<ul>\n<li>截至时间越早，优先级越高</li>\n</ul>\n</li>\n<li>非抢占式调度方式用于非周期实时任务</li>\n<li>抢占式调度方式用于周期实时任务</li>\n</ul>\n<h3 id=\"最低松弛度优先LLF-Least-Laxity-First-算法\"><a href=\"#最低松弛度优先LLF-Least-Laxity-First-算法\" class=\"headerlink\" title=\"最低松弛度优先LLF(Least Laxity First)算法\"></a>最低松弛度优先LLF(Least Laxity First)算法</h3><ul>\n<li>类似EDF</li>\n<li>算法根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高， 以使之优先执行。</li>\n<li>松弛度例子<ul>\n<li>例如，一个任务在200ms时必须完成，而它本身所需的运行时间就有100ms，因此，调度程序必须在100 ms之前调度执行，该任务的紧急程度(松弛程度)为100 ms</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"优先级倒置-Priority-inversion-problem\"><a href=\"#优先级倒置-Priority-inversion-problem\" class=\"headerlink\" title=\"优先级倒置(Priority inversion problem)\"></a>优先级倒置(Priority inversion problem)</h3><ul>\n<li>优先级倒置的形成<ul>\n<li>高优先级进程被低优先级进程延迟或阻塞。</li>\n</ul>\n</li>\n<li>优先级倒置的解决方法<ul>\n<li>简单的:假如进程P3在进入临界区后P3所占用的处理机就不允许被抢占</li>\n<li>实用的:建立在动态优先级继承基础上的</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"死锁概述\"><a href=\"#死锁概述\" class=\"headerlink\" title=\"死锁概述\"></a>死锁概述</h2><h3 id=\"资源问题\"><a href=\"#资源问题\" class=\"headerlink\" title=\"资源问题\"></a>资源问题</h3><ul>\n<li>可重用性资源<ul>\n<li>计算机外设</li>\n</ul>\n</li>\n<li>消耗性资源<ul>\n<li>数据，消息</li>\n</ul>\n</li>\n<li>可抢占性资源<ul>\n<li>不引起死锁</li>\n<li>CPU，内存</li>\n</ul>\n</li>\n<li>不可抢占性资源<ul>\n<li>光驱，打印机</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"计算机系统中的死锁\"><a href=\"#计算机系统中的死锁\" class=\"headerlink\" title=\"计算机系统中的死锁\"></a>计算机系统中的死锁</h3><ul>\n<li>竞争不可抢占性资源引起死锁</li>\n<li>竞争可消耗资源引起死锁</li>\n<li>进程推进顺序不当引起死锁</li>\n</ul>\n<h3 id=\"死锁的定义，必要条件和处理方法\"><a href=\"#死锁的定义，必要条件和处理方法\" class=\"headerlink\" title=\"死锁的定义，必要条件和处理方法\"></a>死锁的定义，必要条件和处理方法</h3><ul>\n<li>定义:如果一组进程中的每一个进程都在等待仅由该进程中的其他进程才能引发的事件，那么该组进程是死锁的</li>\n<li>产生死锁的必要条件<ul>\n<li>互斥条件</li>\n<li>请求和保存条件</li>\n<li>不可抢占条件</li>\n<li>循环等待条件<ul>\n<li>如果每个资源只有一个实例，则环路等待条件是死锁存在的充分必要条件</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>处理死锁的方法<ul>\n<li>预防死锁<ul>\n<li>静态方法，在进程执行前采取的措施，通过设置某些限制条件，去破坏产生死锁的四个条件之一，防止发生死锁。</li>\n<li>预防死锁的策略<ul>\n<li>破坏”请求和保存”条件<ul>\n<li>第一种协议<ul>\n<li>所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源</li>\n<li>优点:简单，易行，安全</li>\n<li>缺点<ul>\n<li>资源被严重浪费，严重地恶化了资源的利用率</li>\n<li>使进程经常会发生饥饿现象</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>第二种协议<ul>\n<li>它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的，且已用毕的全部资源，然后再请求新的所需资源</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>破坏”不可抢占”条件<ul>\n<li>当一个已经保存了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请</li>\n</ul>\n</li>\n<li>破坏”循环等待”条件<ul>\n<li>对系统所以资源类型进行线性排序，并赋予不同的序号</li>\n<li>例如令输入机的序号为1，打印机序号为2，磁盘机序号为3等。所有进程对资源的请求必须严格按资源序号递增的次序提出。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>避免死锁<ul>\n<li>动态的方法，在进程执行过程中采取的措施，不需事先采取限制措施破坏产生死锁的必要条件，而是在进程申请资源时用某种方法去防止系统进入不安全状态，从而避免发生死锁。如银行家算法</li>\n<li>避免死锁的策略<ul>\n<li>系统安全状态<ul>\n<li>安全状态<ul>\n<li>某时刻，对于并发执行的n个进程，若系统能够按照某种顺序如&lt;p1,p2…pn&gt;来为每个进程分配所需资源，直至最大需求，从而使每个进程都可顺利完成，则认为该时刻系统处于安全状态，这样的序列为安全序列</li>\n</ul>\n</li>\n<li>安全状态之例</li>\n<li>由安全状态向不安全状态的转换</li>\n</ul>\n</li>\n<li>利用银行家算法避免死锁<ul>\n<li>含义:每一个新进程在进入系统时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给它，否则让进程等待</li>\n<li>银行家算法中的数据结构<ul>\n<li>可用资源向量 Available[m]：m为系统中资源种类数，Available[j]&#x3D;k表示系统中第j类资源数为k个。</li>\n<li>最大需求矩阵 Max[n,m]：n为系统中进程数，Max[i,j]&#x3D;k表示进程i对j类资源的最大需求数为中k。</li>\n<li>分配矩阵 Allocation[n，m]:它定义了系统中每一类资源当前已分配给每一进程资源数，   Allocation[i,j] &#x3D; k表示进程i已分得j类资源的数目为k个。</li>\n<li>需求矩阵 Need[n,m]：它表示每个进程尚需的各类资源数，Need[i,j]&#x3D;k 表示进程i   还需要j类资源k个。Need[i,j]&#x3D;Max[i,j] - Allocation[i,j]</li>\n</ul>\n</li>\n<li>银行家算法</li>\n<li>安全性算法</li>\n<li>银行家算法之例</li>\n<li>解题<ul>\n<li>矩阵</li>\n<li>列表</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>检测死锁<ul>\n<li>死锁的检测与解除<ul>\n<li>死锁的检测<ul>\n<li>资源分配图<ul>\n<li>简化步骤<ul>\n<li>选择一个没有阻塞的进程p</li>\n<li>将p移走，包括它的所有请求边和分配边</li>\n<li>重复步骤1，2，直至不能继续下去</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>死锁定理<ul>\n<li>若一系列简化以后不能使所有的进程节点都成为孤立节点</li>\n</ul>\n</li>\n<li>检测时机<ul>\n<li>当进程等待时检测死锁 （其缺点是系统的开销大）</li>\n<li>定时检测</li>\n<li>系统资源利用率下降时检测死锁</li>\n</ul>\n</li>\n<li>死锁检测中的数据结构</li>\n</ul>\n</li>\n<li>死锁的解除<ul>\n<li>抢占资源</li>\n<li>终止(或撤销)进程</li>\n<li>终止进程的方法<ul>\n<li>终止所有死锁进程</li>\n<li>逐个终止进程<ul>\n<li>代价最小<ul>\n<li>进程的优先级的大小</li>\n<li>进程已执行了多少时间，还需时间</li>\n<li>进程在运行中已经使用资源的多少，还需多少资源</li>\n<li>进程的性质是交互式还是批处理的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>付出代价最小的死锁解除算法<ul>\n<li>是使用一个有效的挂起和解除机构来挂起一些死锁的进程</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>解除死锁</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"第三章-处理机调度与死锁\"><a href=\"#第三章-处理机调度与死锁\" class=\"headerlink\" title=\"第三章:处理机调度与死锁\"></a>第三章:处理机调度与死锁</h1><h2 id=\"处理机调度算法的目标\"><a href=\"#处理机调度算法的目标\" class=\"headerlink\" title=\"处理机调度算法的目标\"></a>处理机调度算法的目标</h2><h3 id=\"处理机调度算法的共同目标\"><a href=\"#处理机调度算法的共同目标\" class=\"headerlink\" title=\"处理机调度算法的共同目标\"></a>处理机调度算法的共同目标</h3><ul>\n<li>资源利用率:CPU的利用率&#x3D;CPU有效工作时间&#x2F;(CPU有效工作时间+CPU空闲等待时间)</li>\n<li>公平性</li>\n<li>平衡性</li>\n<li>策略强制执行</li>\n</ul>\n<h3 id=\"批处理系统的目标\"><a href=\"#批处理系统的目标\" class=\"headerlink\" title=\"批处理系统的目标\"></a>批处理系统的目标</h3><ul>\n<li>平均周转时间短</li>\n<li>系统吞吐量高</li>\n<li>处理机利用率高</li>\n</ul>\n<h3 id=\"分时系统的目标\"><a href=\"#分时系统的目标\" class=\"headerlink\" title=\"分时系统的目标\"></a>分时系统的目标</h3><ul>\n<li>响应时间快</li>\n<li>均衡性</li>\n</ul>\n<h3 id=\"实时系统目标\"><a href=\"#实时系统目标\" class=\"headerlink\" title=\"实时系统目标\"></a>实时系统目标</h3><ul>\n<li>截止时间的保证</li>\n<li>可预测性</li>\n</ul>\n<h3 id=\"处理机调度的层次\"><a href=\"#处理机调度的层次\" class=\"headerlink\" title=\"处理机调度的层次\"></a>处理机调度的层次</h3><ul>\n<li>高级调度（作业调度）<ul>\n<li>分时系统无需作业调度，因为需要交互</li>\n<li>批处理系统需要作业调度</li>\n</ul>\n</li>\n<li>中级调度（和挂起有关）</li>\n<li>低级调度（进程调度）<ul>\n<li>进程调度是最基本的调度，任何操作系统都有进程调度。</li>\n<li>低级调度的三个基本机制<ul>\n<li>排队器</li>\n<li>分派器</li>\n<li>上下文切换</li>\n</ul>\n</li>\n<li>进程调度方式<ul>\n<li>非抢占方式</li>\n<li>抢占方式<ul>\n<li>优先权原则</li>\n<li>短进程优先原则</li>\n<li>时间片原则</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>进程调度的任务<ul>\n<li>保存处理机的现场信息</li>\n<li>按某种算法选取进程</li>\n<li>把处理器分配给进程</li>\n</ul>\n</li>\n<li>进程调度的算法<ul>\n<li>优先级调度算法<ul>\n<li>优先级调度算法的类型<ul>\n<li>非抢占式优先级调度算法<ul>\n<li>等当前进程执行完以后，再执行另一个优先权最高的进程</li>\n<li>这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</li>\n</ul>\n</li>\n<li>抢占式优先级调度算法<ul>\n<li>不等当前进程结束，直接抢处理机</li>\n<li>常用于要求比较严格的实时系统中， 以及对性能要求较高的批处理和分时系统中。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>优先级的类型<ul>\n<li>静态优先级<ul>\n<li>优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，例如，0<del>7或0</del>255中的某一整数， 又把该整数称为优先数。</li>\n<li>可以参考BIOS系统中设置boot的优先级</li>\n</ul>\n</li>\n<li>动态优先级<ul>\n<li>在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>轮转调度算法<ul>\n<li>基本原理:在轮转(RR)法中，系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并可设置每隔一定时间间隔(如30ms)即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其执行</li>\n<li>进程切换时机<ul>\n<li>时间片未用完，进程完成</li>\n<li>时间片到，进程未完成</li>\n</ul>\n</li>\n<li>时间片大小的确定<ul>\n<li>太小利于短作业，增加系统切换开销</li>\n<li>太长就退化为FCFS算法</li>\n<li>一般选择: q略大于一次交互所需要的时间，使大多数进程在一个时间片内完成</li>\n</ul>\n</li>\n<li>一般来说，平均周转时间将比SJF长，但是有较好的响应时间</li>\n</ul>\n</li>\n<li>多队列调度算法</li>\n<li>多级反馈队列调度算法<ul>\n<li>调度机制<ul>\n<li>设置多个就绪队列</li>\n<li>每个队列都采用FCFS算法</li>\n<li>按照队列优先级调度，在第n队列中采取按时间片轮转的方式运行</li>\n</ul>\n</li>\n<li>调度算法的性能<ul>\n<li>对于终端型用户，由于作业小，感觉满意</li>\n<li>对于短批处理作业用户，周转时间也较小</li>\n<li>长批处理作业用户，也能够得到执行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>基于公平原则的调度算法<ul>\n<li>保证调度算法</li>\n<li>公平分享调度算法</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"作业与作业调度\"><a href=\"#作业与作业调度\" class=\"headerlink\" title=\"作业与作业调度\"></a>作业与作业调度</h2><h3 id=\"作业\"><a href=\"#作业\" class=\"headerlink\" title=\"作业\"></a>作业</h3><ul>\n<li>作业不仅包含程序和数据，还配有一份作业说明书，系统根据说明书对程序的运行进行控制。批处理系统是以作业为单位从外存掉入内存的。</li>\n</ul>\n<h3 id=\"作业控制块JCB\"><a href=\"#作业控制块JCB\" class=\"headerlink\" title=\"作业控制块JCB\"></a>作业控制块JCB</h3><ul>\n<li>为每个作业设置一个JCB，保存了对作业管理调度的全部信息。是作业存在的标志。</li>\n</ul>\n<h3 id=\"作业步\"><a href=\"#作业步\" class=\"headerlink\" title=\"作业步\"></a>作业步</h3><ul>\n<li>作业步，每个作业都必须经过若干相对独立，有相互关联的顺序步骤才能得到结果。每一个步骤就是一个作业步。</li>\n</ul>\n<h3 id=\"作业运行的三个阶段\"><a href=\"#作业运行的三个阶段\" class=\"headerlink\" title=\"作业运行的三个阶段\"></a>作业运行的三个阶段</h3><ul>\n<li>收容阶段</li>\n<li>运行阶段</li>\n<li>完成阶段</li>\n</ul>\n<h3 id=\"作业运行的三个状态\"><a href=\"#作业运行的三个状态\" class=\"headerlink\" title=\"作业运行的三个状态\"></a>作业运行的三个状态</h3><ul>\n<li>后备状态</li>\n<li>运行状态</li>\n<li>完成状态</li>\n</ul>\n<h3 id=\"作业调度的主要任务\"><a href=\"#作业调度的主要任务\" class=\"headerlink\" title=\"作业调度的主要任务\"></a>作业调度的主要任务</h3><ul>\n<li>接纳多少个作业</li>\n<li>接纳哪些作业</li>\n</ul>\n<h3 id=\"先来先服务-first–come-first–served，FCFS-调度算法\"><a href=\"#先来先服务-first–come-first–served，FCFS-调度算法\" class=\"headerlink\" title=\"先来先服务(first–come first–served，FCFS)调度算法\"></a>先来先服务(first–come first–served，FCFS)调度算法</h3><ul>\n<li>比较有利于长作业，而不利于短作业。</li>\n<li>有利于CPU繁忙的作业，而不利于I&#x2F;O繁忙的作业。</li>\n</ul>\n<h3 id=\"短作业优先-short-job-first，SJF-的调度算法\"><a href=\"#短作业优先-short-job-first，SJF-的调度算法\" class=\"headerlink\" title=\"短作业优先(short job first，SJF)的调度算法\"></a>短作业优先(short job first，SJF)的调度算法</h3><ul>\n<li>优点<ul>\n<li>比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；</li>\n<li>提高系统的吞吐量；</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>必须预知作业的运行时间</li>\n<li>对长作业非常不利，长作业的周转时间会明显地增长</li>\n<li>在采用SJF算法时，人–机无法实现交互</li>\n<li>该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"优先级调度算法-priority–scheduling-algorithm，PSA\"><a href=\"#优先级调度算法-priority–scheduling-algorithm，PSA\" class=\"headerlink\" title=\"优先级调度算法(priority–scheduling algorithm，PSA)\"></a>优先级调度算法(priority–scheduling algorithm，PSA)</h3><h3 id=\"高响应比优先调度算法-Highest-Response-Ratio-Next-HRRN\"><a href=\"#高响应比优先调度算法-Highest-Response-Ratio-Next-HRRN\" class=\"headerlink\" title=\"高响应比优先调度算法(Highest Response Ratio Next,HRRN)\"></a>高响应比优先调度算法(Highest Response Ratio Next,HRRN)</h3><ul>\n<li>原理<ul>\n<li>在每次选择作业投入运行时，先计算此时后备作业队列中每个作业的响应比RP然后选择其值最大的作业投入运行</li>\n<li>优先权&#x3D;(等待时间+要求服务时间)&#x2F;要求服务时间&#x3D;响应时间&#x2F;要求服务时间&#x3D;1+等待时间&#x2F;要求服务时间</li>\n</ul>\n</li>\n<li>特点<ul>\n<li>如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而类似于SJF算法，有利于短作业</li>\n<li>当要求服务的时间相同时，作业的优先权又决定于其等待时间，因而该算法又类似于FCFS算法</li>\n<li>对于长时间的优先级，可以为随等待时间的增加而提高，当等待时间足够长时，也可获得处理机</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"实时调度-HRT和SRT任务\"><a href=\"#实时调度-HRT和SRT任务\" class=\"headerlink\" title=\"实时调度(HRT和SRT任务)\"></a>实时调度(HRT和SRT任务)</h2><h3 id=\"实现实时调度的基本条件\"><a href=\"#实现实时调度的基本条件\" class=\"headerlink\" title=\"实现实时调度的基本条件\"></a>实现实时调度的基本条件</h3><ul>\n<li>提供必要信息<ul>\n<li>就绪时间</li>\n<li>开始截止时间和完成截止时间</li>\n<li>处理时间</li>\n<li>资源要求</li>\n<li>优先级</li>\n</ul>\n</li>\n<li>系统处理能力强<ul>\n<li>∑(Ci&#x2F;Pi)≤1</li>\n<li>N个处理机:∑(Ci&#x2F;Pi)≤N</li>\n</ul>\n</li>\n<li>采用抢占式调度机制</li>\n<li>具有快速切换机制<ul>\n<li>对中断的快速响应能力</li>\n<li>快速的任务分派能力</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"实时调度算法的分类\"><a href=\"#实时调度算法的分类\" class=\"headerlink\" title=\"实时调度算法的分类\"></a>实时调度算法的分类</h3><ul>\n<li>非抢占式调度算法<ul>\n<li>非抢占式轮转调度算法</li>\n<li>非抢占式优先调度算法</li>\n</ul>\n</li>\n<li>抢占式调度算法<ul>\n<li>基于时钟中断的抢占式优先级调度算法</li>\n<li>立即抢占的优先级调度算法</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"最早截止时间优先EDF-Earliest-Deadline-First-算法\"><a href=\"#最早截止时间优先EDF-Earliest-Deadline-First-算法\" class=\"headerlink\" title=\"最早截止时间优先EDF(Earliest Deadline First)算法\"></a>最早截止时间优先EDF(Earliest Deadline First)算法</h3><ul>\n<li>根据任务的开始截至时间来确定任务的优先级<ul>\n<li>截至时间越早，优先级越高</li>\n</ul>\n</li>\n<li>非抢占式调度方式用于非周期实时任务</li>\n<li>抢占式调度方式用于周期实时任务</li>\n</ul>\n<h3 id=\"最低松弛度优先LLF-Least-Laxity-First-算法\"><a href=\"#最低松弛度优先LLF-Least-Laxity-First-算法\" class=\"headerlink\" title=\"最低松弛度优先LLF(Least Laxity First)算法\"></a>最低松弛度优先LLF(Least Laxity First)算法</h3><ul>\n<li>类似EDF</li>\n<li>算法根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高， 以使之优先执行。</li>\n<li>松弛度例子<ul>\n<li>例如，一个任务在200ms时必须完成，而它本身所需的运行时间就有100ms，因此，调度程序必须在100 ms之前调度执行，该任务的紧急程度(松弛程度)为100 ms</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"优先级倒置-Priority-inversion-problem\"><a href=\"#优先级倒置-Priority-inversion-problem\" class=\"headerlink\" title=\"优先级倒置(Priority inversion problem)\"></a>优先级倒置(Priority inversion problem)</h3><ul>\n<li>优先级倒置的形成<ul>\n<li>高优先级进程被低优先级进程延迟或阻塞。</li>\n</ul>\n</li>\n<li>优先级倒置的解决方法<ul>\n<li>简单的:假如进程P3在进入临界区后P3所占用的处理机就不允许被抢占</li>\n<li>实用的:建立在动态优先级继承基础上的</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"死锁概述\"><a href=\"#死锁概述\" class=\"headerlink\" title=\"死锁概述\"></a>死锁概述</h2><h3 id=\"资源问题\"><a href=\"#资源问题\" class=\"headerlink\" title=\"资源问题\"></a>资源问题</h3><ul>\n<li>可重用性资源<ul>\n<li>计算机外设</li>\n</ul>\n</li>\n<li>消耗性资源<ul>\n<li>数据，消息</li>\n</ul>\n</li>\n<li>可抢占性资源<ul>\n<li>不引起死锁</li>\n<li>CPU，内存</li>\n</ul>\n</li>\n<li>不可抢占性资源<ul>\n<li>光驱，打印机</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"计算机系统中的死锁\"><a href=\"#计算机系统中的死锁\" class=\"headerlink\" title=\"计算机系统中的死锁\"></a>计算机系统中的死锁</h3><ul>\n<li>竞争不可抢占性资源引起死锁</li>\n<li>竞争可消耗资源引起死锁</li>\n<li>进程推进顺序不当引起死锁</li>\n</ul>\n<h3 id=\"死锁的定义，必要条件和处理方法\"><a href=\"#死锁的定义，必要条件和处理方法\" class=\"headerlink\" title=\"死锁的定义，必要条件和处理方法\"></a>死锁的定义，必要条件和处理方法</h3><ul>\n<li>定义:如果一组进程中的每一个进程都在等待仅由该进程中的其他进程才能引发的事件，那么该组进程是死锁的</li>\n<li>产生死锁的必要条件<ul>\n<li>互斥条件</li>\n<li>请求和保存条件</li>\n<li>不可抢占条件</li>\n<li>循环等待条件<ul>\n<li>如果每个资源只有一个实例，则环路等待条件是死锁存在的充分必要条件</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>处理死锁的方法<ul>\n<li>预防死锁<ul>\n<li>静态方法，在进程执行前采取的措施，通过设置某些限制条件，去破坏产生死锁的四个条件之一，防止发生死锁。</li>\n<li>预防死锁的策略<ul>\n<li>破坏”请求和保存”条件<ul>\n<li>第一种协议<ul>\n<li>所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源</li>\n<li>优点:简单，易行，安全</li>\n<li>缺点<ul>\n<li>资源被严重浪费，严重地恶化了资源的利用率</li>\n<li>使进程经常会发生饥饿现象</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>第二种协议<ul>\n<li>它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的，且已用毕的全部资源，然后再请求新的所需资源</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>破坏”不可抢占”条件<ul>\n<li>当一个已经保存了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请</li>\n</ul>\n</li>\n<li>破坏”循环等待”条件<ul>\n<li>对系统所以资源类型进行线性排序，并赋予不同的序号</li>\n<li>例如令输入机的序号为1，打印机序号为2，磁盘机序号为3等。所有进程对资源的请求必须严格按资源序号递增的次序提出。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>避免死锁<ul>\n<li>动态的方法，在进程执行过程中采取的措施，不需事先采取限制措施破坏产生死锁的必要条件，而是在进程申请资源时用某种方法去防止系统进入不安全状态，从而避免发生死锁。如银行家算法</li>\n<li>避免死锁的策略<ul>\n<li>系统安全状态<ul>\n<li>安全状态<ul>\n<li>某时刻，对于并发执行的n个进程，若系统能够按照某种顺序如&lt;p1,p2…pn&gt;来为每个进程分配所需资源，直至最大需求，从而使每个进程都可顺利完成，则认为该时刻系统处于安全状态，这样的序列为安全序列</li>\n</ul>\n</li>\n<li>安全状态之例</li>\n<li>由安全状态向不安全状态的转换</li>\n</ul>\n</li>\n<li>利用银行家算法避免死锁<ul>\n<li>含义:每一个新进程在进入系统时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给它，否则让进程等待</li>\n<li>银行家算法中的数据结构<ul>\n<li>可用资源向量 Available[m]：m为系统中资源种类数，Available[j]&#x3D;k表示系统中第j类资源数为k个。</li>\n<li>最大需求矩阵 Max[n,m]：n为系统中进程数，Max[i,j]&#x3D;k表示进程i对j类资源的最大需求数为中k。</li>\n<li>分配矩阵 Allocation[n，m]:它定义了系统中每一类资源当前已分配给每一进程资源数，   Allocation[i,j] &#x3D; k表示进程i已分得j类资源的数目为k个。</li>\n<li>需求矩阵 Need[n,m]：它表示每个进程尚需的各类资源数，Need[i,j]&#x3D;k 表示进程i   还需要j类资源k个。Need[i,j]&#x3D;Max[i,j] - Allocation[i,j]</li>\n</ul>\n</li>\n<li>银行家算法</li>\n<li>安全性算法</li>\n<li>银行家算法之例</li>\n<li>解题<ul>\n<li>矩阵</li>\n<li>列表</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>检测死锁<ul>\n<li>死锁的检测与解除<ul>\n<li>死锁的检测<ul>\n<li>资源分配图<ul>\n<li>简化步骤<ul>\n<li>选择一个没有阻塞的进程p</li>\n<li>将p移走，包括它的所有请求边和分配边</li>\n<li>重复步骤1，2，直至不能继续下去</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>死锁定理<ul>\n<li>若一系列简化以后不能使所有的进程节点都成为孤立节点</li>\n</ul>\n</li>\n<li>检测时机<ul>\n<li>当进程等待时检测死锁 （其缺点是系统的开销大）</li>\n<li>定时检测</li>\n<li>系统资源利用率下降时检测死锁</li>\n</ul>\n</li>\n<li>死锁检测中的数据结构</li>\n</ul>\n</li>\n<li>死锁的解除<ul>\n<li>抢占资源</li>\n<li>终止(或撤销)进程</li>\n<li>终止进程的方法<ul>\n<li>终止所有死锁进程</li>\n<li>逐个终止进程<ul>\n<li>代价最小<ul>\n<li>进程的优先级的大小</li>\n<li>进程已执行了多少时间，还需时间</li>\n<li>进程在运行中已经使用资源的多少，还需多少资源</li>\n<li>进程的性质是交互式还是批处理的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>付出代价最小的死锁解除算法<ul>\n<li>是使用一个有效的挂起和解除机构来挂起一些死锁的进程</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>解除死锁</li>\n</ul>\n</li>\n</ul>\n"},{"_content":"# 第四章:存储器管理\n## 存储器的层次结构\n### 多层结构的存储系统\n* 存储器的多层结构\n    * CPU寄存器\n    * 主存\n    * 辅存\n* 可执行存储器\n    * 寄存器和主存的总称\n    * 访问速度快，进程可以在很少的时钟周期内用一条load或store指令完成存取。\n### 主存储器与寄存器\n### 高速缓存和磁盘缓存\n## 程序的装入和链接\n### 步骤\n* 编译\n    * 源程序 ->目标模块（Object modules）--------Compiler\n        * 由编译程序对用户源程序进行编译，形成若干个目标模块\n* 链接\n    * 一组目标模块 ->装入模块 （Load Module）----------Linker\n        * 由链接程序将编译后形成的一组目标模板以及它们所需要的库函数链接在一起，形成一个完整的装入模块\n* 装入\n    * 装入模块 ->内存  --------Loader\n        * 由装入程序将装入模块装入内存\n### 程序的装入\n* 绝对装入方式\n    * 在编译时，如果知道程序将驻留在内存中指定的位置。编译程序将产生绝对地址的目标代码。\n* 可重定位装入方式\n    * 在可执行文件中，列出各个需要重定位的地址单元和相对地址值。当用户程序被装入内存时，一次性实现逻辑地址到物理地址的转换，以后不再转换(一般在装入内存时由软件完成)。\n    * 优点：不需硬件支持，可以装入有限多道程序。\n    * 缺点：一个程序通常需要占用连续的内存空间，程序装入内存后不能移动。不易实现共享。\n* 动态运行时的装入方式\n    * 动态运行时的装入程序在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换为物理地址，而是把这种地址转换推迟到程序真正要执行时才进行\n    * 优点：\n        * OS可以将一个程序分散存放于不连续的内存空间，可以移动程序，有利用实现共享。\n        * 能够支持程序执行中产生的地址引用，如指针变量（而不仅是生成可执行文件时的地址引用）。\n    * 缺点：需要硬件支持，OS实现较复杂。\n    * 它是虚拟存储的基础。\n### 程序的链接\n* 静态链接方式(lib)\n* 装入时动态链接\n* 运行时动态链接(dll)\n## 连续分配存储管理方式\n### 连续分配\n* 单一连续分配(DOS)\n* 固定分区分配(浪费很多空间)\n* 动态分区分配\n### 地址映射和存储保护措施\n* 基址寄存器：程序的最小物理地址\n* 界限寄存器：程序的逻辑地址范围\n* 物理地址 = 逻辑地址 + 基址\n### 内碎片：占用分区之内未被利用的空间\n### 外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）\n### 把内存划分为若干个固定大小的连续分区。固定式分区又称为静态分区。\n* 分区大小相等：只适合于多个相同程序的并发执行（处理多个类型相同的对象）。\n* 分区大小不等：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。\n* 优点：无外碎片、易实现、开销小。\n* 缺点：\n    * 存在内碎片，造成浪费\n    * 分区总数固定，限制了并发执行的程序数目。\n    * 通用Os很少采用，部分控制系统中采用\n### 动态创建分区：指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。可变式分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。\n* 基于顺序搜索的动态分区分配算法\n    * 首次适应算法（first fit,FF）\n        * 顺序找，找到一个满足的就分配，但是可能存在浪费\n        * 这种方法目的在于减少查找时间。\n        * 空闲分区表（空闲区链）中的空闲分区要按地址由低到高进行排序\n    * 循环首次适应算法（next fit，NF）\n        * 相对上面那种，不是顺序，类似哈希算法中左右交叉排序\n        * 空闲分区分布得更均匀，查找开销小\n        * 从上次找到的空闲区的下一个空闲区开始查找，直到找到第一个能满足要求的的空闲区为止，并从中划出一块与请求大小相等的内存空间分配给作业。\n    * 最佳适应算法（best fit，BF）\n        * 找到最合适的，但是大区域的访问次数减少\n        * 这种方法能使外碎片尽量小。\n        * 空闲分区表（空闲区链）中的空闲分区要按大小从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。\n    * 最坏适应算法（worst fit，WF）\n        * 相对于最好而言，找最大的区域下手，导致最大的区域可能很少，也造成许多碎片\n        * 空闲分区按大小由大到小排序\n* 基于索引搜索的动态分区分配算法\n    * 快速适应算法（quick fit）\n    * 伙伴系统（buddy system）\n    * 哈希算法\n* 动态可重定位分区分配\n    * 紧凑\n    * 动态重定位\n        * 动态运行时装入，地址转化在指令执行时进行，需获得硬件地址变换机制的支持\n        * 内存地址=相对地址+起始地址\n    * 动态重定位分区分配算法\n        * 1、在某个分区被释放后立即进行紧凑，系统总是只有一个连续的分区而无碎片，此法很花费机时。\n        * 2、当“请求分配模块”找不到足够大的自由分区分给用户时再进行紧凑，这样紧缩的次数比上种方法少得多，但管理复杂。采用此法的动态重定位分区分配算法框图如下：\n* 优点：没有内碎片。\n* 缺点：外碎片。\n## 对换（了解）\n### 系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。\n## 基本分页存储管理方式\n### 分页存储管理的基本方式\n* 页面\n    * 将一个进程的逻辑地址空间分成若干个大小相等的片\n* 页框（frame）\n    * 内存空间分成与页面相同大小的存储块\n* 由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”\n* 地址结构\n    * 页号P+位移量W(0-31)\n* 页表\n    * 在分页系统中，允许将进程的各个页离散地存储在内存在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每一个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表\n    * 页表的作用是实现从页面号到物理块号的地址映射\n### 地址变换机构\n* 基本的地址变换机构\n    * 要访问两次内存\n    * 页表大都驻留在内存中\n    * 为了实现地址变换功能，在系统中设置页表寄存器（PTR），用来存放页表的始址和页表的长度。\n    * 在进程未执行时，每个进程对应的页表的始址和长度存放在进程的PCB中，当该进程被调度时，就将它们装入页表寄存器。\n* 具有快表的地址变换机构\n    * 提高了效率，此处会有计算题\n    * 如果页表存放在内存中，则每次访问内存时，都要先访问内存中的页表，然后根据所形成的物理地址再访问内存。这样CPU存一个数据必须访问两次内存，从而使计算机的处理速度降低了1/2。\n    * 为了提高地址变换的速度，在地址变换机构中增设了一个具有并行查询功能的特殊的高速缓冲存储器，称为“联想存储器”或“快表”，用以存放当前访问的那些页表项。\n    * 地址变换过程为：\n        * 1、CPU给出有效地址\n        * 2、地址变换机构自动地将页号送入高速缓存，确定所需要的页是否在快表中。\n        * 3、若是，则直接读出该页所对应的物理块号，送入物理地址寄存器；\n        * 4、若快表中未找到对应的页表项，则需再访问内存中的页表\n        * 5、找到后，把从页表中读出的页表项存入快表中的一个寄存器单元中，以取代一个旧的页表项。\n### 两级和多级页表\n* 主要是有的时候页表太多了，要化简\n* 格式：外层页号P1+外层页内地址P2+页内地址d\n* 基本方法：将页表进行分页，每个页面的大小与内存物理块的大小相同，并为它们进行编号，可以离散地将各个页面分别存放在不同的物理块中。\n### 反置页表\n* 反置页表为每一个物理块（页框）设置一个页表项，并按物理块排序，其内容则是页号和其所属进程的标识。\n### 优点：\n* 没有外碎片，每个内碎片不超过页大小。\n* 一个程序不必连续存放。\n* 便于改变程序占用空间的大小。即随着程序运行而动态生成的数据增多，地址空间可相应增长。\n### 缺点：程序全部装入内存。\n## 分段存储管理方式\n### 引入\n* 方便编程\n* 信息共享\n* 动态增长\n* 动态链接\n### 在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。\n### 内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定\n### 分段系统的基本原理\n* 分段\n    * 格式：段号+段内地址\n* 段表\n    * 段表实现了从逻辑段到物理内存区的映射。\n* 地址变换机构\n### 和分页的区别\n* 页是信息的物理单位\n* 页的大小固定且由系统固定\n* 分页的用户程序地址空间是一维的\n* 通常段比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。\n* 分页是系统管理的需要，分段是用户应用的需要。一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。\n### 信息共享\n* 这是分段最重要的优点\n### 段页式存储管理方式\n* 基本原理\n    * 格式：段号（S）+段内页号（P）+页内地址（W）\n* 地址变换过程\n    * 需要三次访问过程\n* 在段页式系统中，为了获得一条指令或数据，需三次访问内存：第一次访问内存中的段表，从中取得页表始址；第二次访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正根据所得的物理地址取出指令或数据。\n","source":"_posts/2023-06-14-4-存储器管理.md","raw":"# 第四章:存储器管理\n## 存储器的层次结构\n### 多层结构的存储系统\n* 存储器的多层结构\n    * CPU寄存器\n    * 主存\n    * 辅存\n* 可执行存储器\n    * 寄存器和主存的总称\n    * 访问速度快，进程可以在很少的时钟周期内用一条load或store指令完成存取。\n### 主存储器与寄存器\n### 高速缓存和磁盘缓存\n## 程序的装入和链接\n### 步骤\n* 编译\n    * 源程序 ->目标模块（Object modules）--------Compiler\n        * 由编译程序对用户源程序进行编译，形成若干个目标模块\n* 链接\n    * 一组目标模块 ->装入模块 （Load Module）----------Linker\n        * 由链接程序将编译后形成的一组目标模板以及它们所需要的库函数链接在一起，形成一个完整的装入模块\n* 装入\n    * 装入模块 ->内存  --------Loader\n        * 由装入程序将装入模块装入内存\n### 程序的装入\n* 绝对装入方式\n    * 在编译时，如果知道程序将驻留在内存中指定的位置。编译程序将产生绝对地址的目标代码。\n* 可重定位装入方式\n    * 在可执行文件中，列出各个需要重定位的地址单元和相对地址值。当用户程序被装入内存时，一次性实现逻辑地址到物理地址的转换，以后不再转换(一般在装入内存时由软件完成)。\n    * 优点：不需硬件支持，可以装入有限多道程序。\n    * 缺点：一个程序通常需要占用连续的内存空间，程序装入内存后不能移动。不易实现共享。\n* 动态运行时的装入方式\n    * 动态运行时的装入程序在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换为物理地址，而是把这种地址转换推迟到程序真正要执行时才进行\n    * 优点：\n        * OS可以将一个程序分散存放于不连续的内存空间，可以移动程序，有利用实现共享。\n        * 能够支持程序执行中产生的地址引用，如指针变量（而不仅是生成可执行文件时的地址引用）。\n    * 缺点：需要硬件支持，OS实现较复杂。\n    * 它是虚拟存储的基础。\n### 程序的链接\n* 静态链接方式(lib)\n* 装入时动态链接\n* 运行时动态链接(dll)\n## 连续分配存储管理方式\n### 连续分配\n* 单一连续分配(DOS)\n* 固定分区分配(浪费很多空间)\n* 动态分区分配\n### 地址映射和存储保护措施\n* 基址寄存器：程序的最小物理地址\n* 界限寄存器：程序的逻辑地址范围\n* 物理地址 = 逻辑地址 + 基址\n### 内碎片：占用分区之内未被利用的空间\n### 外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）\n### 把内存划分为若干个固定大小的连续分区。固定式分区又称为静态分区。\n* 分区大小相等：只适合于多个相同程序的并发执行（处理多个类型相同的对象）。\n* 分区大小不等：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。\n* 优点：无外碎片、易实现、开销小。\n* 缺点：\n    * 存在内碎片，造成浪费\n    * 分区总数固定，限制了并发执行的程序数目。\n    * 通用Os很少采用，部分控制系统中采用\n### 动态创建分区：指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。可变式分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。\n* 基于顺序搜索的动态分区分配算法\n    * 首次适应算法（first fit,FF）\n        * 顺序找，找到一个满足的就分配，但是可能存在浪费\n        * 这种方法目的在于减少查找时间。\n        * 空闲分区表（空闲区链）中的空闲分区要按地址由低到高进行排序\n    * 循环首次适应算法（next fit，NF）\n        * 相对上面那种，不是顺序，类似哈希算法中左右交叉排序\n        * 空闲分区分布得更均匀，查找开销小\n        * 从上次找到的空闲区的下一个空闲区开始查找，直到找到第一个能满足要求的的空闲区为止，并从中划出一块与请求大小相等的内存空间分配给作业。\n    * 最佳适应算法（best fit，BF）\n        * 找到最合适的，但是大区域的访问次数减少\n        * 这种方法能使外碎片尽量小。\n        * 空闲分区表（空闲区链）中的空闲分区要按大小从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。\n    * 最坏适应算法（worst fit，WF）\n        * 相对于最好而言，找最大的区域下手，导致最大的区域可能很少，也造成许多碎片\n        * 空闲分区按大小由大到小排序\n* 基于索引搜索的动态分区分配算法\n    * 快速适应算法（quick fit）\n    * 伙伴系统（buddy system）\n    * 哈希算法\n* 动态可重定位分区分配\n    * 紧凑\n    * 动态重定位\n        * 动态运行时装入，地址转化在指令执行时进行，需获得硬件地址变换机制的支持\n        * 内存地址=相对地址+起始地址\n    * 动态重定位分区分配算法\n        * 1、在某个分区被释放后立即进行紧凑，系统总是只有一个连续的分区而无碎片，此法很花费机时。\n        * 2、当“请求分配模块”找不到足够大的自由分区分给用户时再进行紧凑，这样紧缩的次数比上种方法少得多，但管理复杂。采用此法的动态重定位分区分配算法框图如下：\n* 优点：没有内碎片。\n* 缺点：外碎片。\n## 对换（了解）\n### 系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。\n## 基本分页存储管理方式\n### 分页存储管理的基本方式\n* 页面\n    * 将一个进程的逻辑地址空间分成若干个大小相等的片\n* 页框（frame）\n    * 内存空间分成与页面相同大小的存储块\n* 由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”\n* 地址结构\n    * 页号P+位移量W(0-31)\n* 页表\n    * 在分页系统中，允许将进程的各个页离散地存储在内存在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每一个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表\n    * 页表的作用是实现从页面号到物理块号的地址映射\n### 地址变换机构\n* 基本的地址变换机构\n    * 要访问两次内存\n    * 页表大都驻留在内存中\n    * 为了实现地址变换功能，在系统中设置页表寄存器（PTR），用来存放页表的始址和页表的长度。\n    * 在进程未执行时，每个进程对应的页表的始址和长度存放在进程的PCB中，当该进程被调度时，就将它们装入页表寄存器。\n* 具有快表的地址变换机构\n    * 提高了效率，此处会有计算题\n    * 如果页表存放在内存中，则每次访问内存时，都要先访问内存中的页表，然后根据所形成的物理地址再访问内存。这样CPU存一个数据必须访问两次内存，从而使计算机的处理速度降低了1/2。\n    * 为了提高地址变换的速度，在地址变换机构中增设了一个具有并行查询功能的特殊的高速缓冲存储器，称为“联想存储器”或“快表”，用以存放当前访问的那些页表项。\n    * 地址变换过程为：\n        * 1、CPU给出有效地址\n        * 2、地址变换机构自动地将页号送入高速缓存，确定所需要的页是否在快表中。\n        * 3、若是，则直接读出该页所对应的物理块号，送入物理地址寄存器；\n        * 4、若快表中未找到对应的页表项，则需再访问内存中的页表\n        * 5、找到后，把从页表中读出的页表项存入快表中的一个寄存器单元中，以取代一个旧的页表项。\n### 两级和多级页表\n* 主要是有的时候页表太多了，要化简\n* 格式：外层页号P1+外层页内地址P2+页内地址d\n* 基本方法：将页表进行分页，每个页面的大小与内存物理块的大小相同，并为它们进行编号，可以离散地将各个页面分别存放在不同的物理块中。\n### 反置页表\n* 反置页表为每一个物理块（页框）设置一个页表项，并按物理块排序，其内容则是页号和其所属进程的标识。\n### 优点：\n* 没有外碎片，每个内碎片不超过页大小。\n* 一个程序不必连续存放。\n* 便于改变程序占用空间的大小。即随着程序运行而动态生成的数据增多，地址空间可相应增长。\n### 缺点：程序全部装入内存。\n## 分段存储管理方式\n### 引入\n* 方便编程\n* 信息共享\n* 动态增长\n* 动态链接\n### 在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。\n### 内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定\n### 分段系统的基本原理\n* 分段\n    * 格式：段号+段内地址\n* 段表\n    * 段表实现了从逻辑段到物理内存区的映射。\n* 地址变换机构\n### 和分页的区别\n* 页是信息的物理单位\n* 页的大小固定且由系统固定\n* 分页的用户程序地址空间是一维的\n* 通常段比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。\n* 分页是系统管理的需要，分段是用户应用的需要。一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。\n### 信息共享\n* 这是分段最重要的优点\n### 段页式存储管理方式\n* 基本原理\n    * 格式：段号（S）+段内页号（P）+页内地址（W）\n* 地址变换过程\n    * 需要三次访问过程\n* 在段页式系统中，为了获得一条指令或数据，需三次访问内存：第一次访问内存中的段表，从中取得页表始址；第二次访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正根据所得的物理地址取出指令或数据。\n","slug":"2023-06-14-4-存储器管理","published":1,"date":"2023-12-15T02:31:42.059Z","updated":"2023-12-15T02:31:42.083Z","_id":"clq60jord00044zgsb2wj3r90","title":"","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"第四章-存储器管理\"><a href=\"#第四章-存储器管理\" class=\"headerlink\" title=\"第四章:存储器管理\"></a>第四章:存储器管理</h1><h2 id=\"存储器的层次结构\"><a href=\"#存储器的层次结构\" class=\"headerlink\" title=\"存储器的层次结构\"></a>存储器的层次结构</h2><h3 id=\"多层结构的存储系统\"><a href=\"#多层结构的存储系统\" class=\"headerlink\" title=\"多层结构的存储系统\"></a>多层结构的存储系统</h3><ul>\n<li>存储器的多层结构<ul>\n<li>CPU寄存器</li>\n<li>主存</li>\n<li>辅存</li>\n</ul>\n</li>\n<li>可执行存储器<ul>\n<li>寄存器和主存的总称</li>\n<li>访问速度快，进程可以在很少的时钟周期内用一条load或store指令完成存取。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"主存储器与寄存器\"><a href=\"#主存储器与寄存器\" class=\"headerlink\" title=\"主存储器与寄存器\"></a>主存储器与寄存器</h3><h3 id=\"高速缓存和磁盘缓存\"><a href=\"#高速缓存和磁盘缓存\" class=\"headerlink\" title=\"高速缓存和磁盘缓存\"></a>高速缓存和磁盘缓存</h3><h2 id=\"程序的装入和链接\"><a href=\"#程序的装入和链接\" class=\"headerlink\" title=\"程序的装入和链接\"></a>程序的装入和链接</h2><h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><ul>\n<li>编译<ul>\n<li>源程序 -&gt;目标模块（Object modules）——–Compiler<ul>\n<li>由编译程序对用户源程序进行编译，形成若干个目标模块</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>链接<ul>\n<li>一组目标模块 -&gt;装入模块 （Load Module）———-Linker<ul>\n<li>由链接程序将编译后形成的一组目标模板以及它们所需要的库函数链接在一起，形成一个完整的装入模块</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>装入<ul>\n<li>装入模块 -&gt;内存  ——–Loader<ul>\n<li>由装入程序将装入模块装入内存</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"程序的装入\"><a href=\"#程序的装入\" class=\"headerlink\" title=\"程序的装入\"></a>程序的装入</h3><ul>\n<li>绝对装入方式<ul>\n<li>在编译时，如果知道程序将驻留在内存中指定的位置。编译程序将产生绝对地址的目标代码。</li>\n</ul>\n</li>\n<li>可重定位装入方式<ul>\n<li>在可执行文件中，列出各个需要重定位的地址单元和相对地址值。当用户程序被装入内存时，一次性实现逻辑地址到物理地址的转换，以后不再转换(一般在装入内存时由软件完成)。</li>\n<li>优点：不需硬件支持，可以装入有限多道程序。</li>\n<li>缺点：一个程序通常需要占用连续的内存空间，程序装入内存后不能移动。不易实现共享。</li>\n</ul>\n</li>\n<li>动态运行时的装入方式<ul>\n<li>动态运行时的装入程序在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换为物理地址，而是把这种地址转换推迟到程序真正要执行时才进行</li>\n<li>优点：<ul>\n<li>OS可以将一个程序分散存放于不连续的内存空间，可以移动程序，有利用实现共享。</li>\n<li>能够支持程序执行中产生的地址引用，如指针变量（而不仅是生成可执行文件时的地址引用）。</li>\n</ul>\n</li>\n<li>缺点：需要硬件支持，OS实现较复杂。</li>\n<li>它是虚拟存储的基础。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"程序的链接\"><a href=\"#程序的链接\" class=\"headerlink\" title=\"程序的链接\"></a>程序的链接</h3><ul>\n<li>静态链接方式(lib)</li>\n<li>装入时动态链接</li>\n<li>运行时动态链接(dll)</li>\n</ul>\n<h2 id=\"连续分配存储管理方式\"><a href=\"#连续分配存储管理方式\" class=\"headerlink\" title=\"连续分配存储管理方式\"></a>连续分配存储管理方式</h2><h3 id=\"连续分配\"><a href=\"#连续分配\" class=\"headerlink\" title=\"连续分配\"></a>连续分配</h3><ul>\n<li>单一连续分配(DOS)</li>\n<li>固定分区分配(浪费很多空间)</li>\n<li>动态分区分配</li>\n</ul>\n<h3 id=\"地址映射和存储保护措施\"><a href=\"#地址映射和存储保护措施\" class=\"headerlink\" title=\"地址映射和存储保护措施\"></a>地址映射和存储保护措施</h3><ul>\n<li>基址寄存器：程序的最小物理地址</li>\n<li>界限寄存器：程序的逻辑地址范围</li>\n<li>物理地址 &#x3D; 逻辑地址 + 基址</li>\n</ul>\n<h3 id=\"内碎片：占用分区之内未被利用的空间\"><a href=\"#内碎片：占用分区之内未被利用的空间\" class=\"headerlink\" title=\"内碎片：占用分区之内未被利用的空间\"></a>内碎片：占用分区之内未被利用的空间</h3><h3 id=\"外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）\"><a href=\"#外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）\" class=\"headerlink\" title=\"外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）\"></a>外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）</h3><h3 id=\"把内存划分为若干个固定大小的连续分区。固定式分区又称为静态分区。\"><a href=\"#把内存划分为若干个固定大小的连续分区。固定式分区又称为静态分区。\" class=\"headerlink\" title=\"把内存划分为若干个固定大小的连续分区。固定式分区又称为静态分区。\"></a>把内存划分为若干个固定大小的连续分区。固定式分区又称为静态分区。</h3><ul>\n<li>分区大小相等：只适合于多个相同程序的并发执行（处理多个类型相同的对象）。</li>\n<li>分区大小不等：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。</li>\n<li>优点：无外碎片、易实现、开销小。</li>\n<li>缺点：<ul>\n<li>存在内碎片，造成浪费</li>\n<li>分区总数固定，限制了并发执行的程序数目。</li>\n<li>通用Os很少采用，部分控制系统中采用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"动态创建分区：指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。可变式分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。\"><a href=\"#动态创建分区：指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。可变式分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。\" class=\"headerlink\" title=\"动态创建分区：指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。可变式分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。\"></a>动态创建分区：指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。可变式分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。</h3><ul>\n<li>基于顺序搜索的动态分区分配算法<ul>\n<li>首次适应算法（first fit,FF）<ul>\n<li>顺序找，找到一个满足的就分配，但是可能存在浪费</li>\n<li>这种方法目的在于减少查找时间。</li>\n<li>空闲分区表（空闲区链）中的空闲分区要按地址由低到高进行排序</li>\n</ul>\n</li>\n<li>循环首次适应算法（next fit，NF）<ul>\n<li>相对上面那种，不是顺序，类似哈希算法中左右交叉排序</li>\n<li>空闲分区分布得更均匀，查找开销小</li>\n<li>从上次找到的空闲区的下一个空闲区开始查找，直到找到第一个能满足要求的的空闲区为止，并从中划出一块与请求大小相等的内存空间分配给作业。</li>\n</ul>\n</li>\n<li>最佳适应算法（best fit，BF）<ul>\n<li>找到最合适的，但是大区域的访问次数减少</li>\n<li>这种方法能使外碎片尽量小。</li>\n<li>空闲分区表（空闲区链）中的空闲分区要按大小从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。</li>\n</ul>\n</li>\n<li>最坏适应算法（worst fit，WF）<ul>\n<li>相对于最好而言，找最大的区域下手，导致最大的区域可能很少，也造成许多碎片</li>\n<li>空闲分区按大小由大到小排序</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>基于索引搜索的动态分区分配算法<ul>\n<li>快速适应算法（quick fit）</li>\n<li>伙伴系统（buddy system）</li>\n<li>哈希算法</li>\n</ul>\n</li>\n<li>动态可重定位分区分配<ul>\n<li>紧凑</li>\n<li>动态重定位<ul>\n<li>动态运行时装入，地址转化在指令执行时进行，需获得硬件地址变换机制的支持</li>\n<li>内存地址&#x3D;相对地址+起始地址</li>\n</ul>\n</li>\n<li>动态重定位分区分配算法<ul>\n<li>1、在某个分区被释放后立即进行紧凑，系统总是只有一个连续的分区而无碎片，此法很花费机时。</li>\n<li>2、当“请求分配模块”找不到足够大的自由分区分给用户时再进行紧凑，这样紧缩的次数比上种方法少得多，但管理复杂。采用此法的动态重定位分区分配算法框图如下：</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>优点：没有内碎片。</li>\n<li>缺点：外碎片。</li>\n</ul>\n<h2 id=\"对换（了解）\"><a href=\"#对换（了解）\" class=\"headerlink\" title=\"对换（了解）\"></a>对换（了解）</h2><h3 id=\"系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。\"><a href=\"#系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。\" class=\"headerlink\" title=\"系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。\"></a>系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。</h3><h2 id=\"基本分页存储管理方式\"><a href=\"#基本分页存储管理方式\" class=\"headerlink\" title=\"基本分页存储管理方式\"></a>基本分页存储管理方式</h2><h3 id=\"分页存储管理的基本方式\"><a href=\"#分页存储管理的基本方式\" class=\"headerlink\" title=\"分页存储管理的基本方式\"></a>分页存储管理的基本方式</h3><ul>\n<li>页面<ul>\n<li>将一个进程的逻辑地址空间分成若干个大小相等的片</li>\n</ul>\n</li>\n<li>页框（frame）<ul>\n<li>内存空间分成与页面相同大小的存储块</li>\n</ul>\n</li>\n<li>由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”</li>\n<li>地址结构<ul>\n<li>页号P+位移量W(0-31)</li>\n</ul>\n</li>\n<li>页表<ul>\n<li>在分页系统中，允许将进程的各个页离散地存储在内存在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每一个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表</li>\n<li>页表的作用是实现从页面号到物理块号的地址映射</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"地址变换机构\"><a href=\"#地址变换机构\" class=\"headerlink\" title=\"地址变换机构\"></a>地址变换机构</h3><ul>\n<li>基本的地址变换机构<ul>\n<li>要访问两次内存</li>\n<li>页表大都驻留在内存中</li>\n<li>为了实现地址变换功能，在系统中设置页表寄存器（PTR），用来存放页表的始址和页表的长度。</li>\n<li>在进程未执行时，每个进程对应的页表的始址和长度存放在进程的PCB中，当该进程被调度时，就将它们装入页表寄存器。</li>\n</ul>\n</li>\n<li>具有快表的地址变换机构<ul>\n<li>提高了效率，此处会有计算题</li>\n<li>如果页表存放在内存中，则每次访问内存时，都要先访问内存中的页表，然后根据所形成的物理地址再访问内存。这样CPU存一个数据必须访问两次内存，从而使计算机的处理速度降低了1&#x2F;2。</li>\n<li>为了提高地址变换的速度，在地址变换机构中增设了一个具有并行查询功能的特殊的高速缓冲存储器，称为“联想存储器”或“快表”，用以存放当前访问的那些页表项。</li>\n<li>地址变换过程为：<ul>\n<li>1、CPU给出有效地址</li>\n<li>2、地址变换机构自动地将页号送入高速缓存，确定所需要的页是否在快表中。</li>\n<li>3、若是，则直接读出该页所对应的物理块号，送入物理地址寄存器；</li>\n<li>4、若快表中未找到对应的页表项，则需再访问内存中的页表</li>\n<li>5、找到后，把从页表中读出的页表项存入快表中的一个寄存器单元中，以取代一个旧的页表项。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"两级和多级页表\"><a href=\"#两级和多级页表\" class=\"headerlink\" title=\"两级和多级页表\"></a>两级和多级页表</h3><ul>\n<li>主要是有的时候页表太多了，要化简</li>\n<li>格式：外层页号P1+外层页内地址P2+页内地址d</li>\n<li>基本方法：将页表进行分页，每个页面的大小与内存物理块的大小相同，并为它们进行编号，可以离散地将各个页面分别存放在不同的物理块中。</li>\n</ul>\n<h3 id=\"反置页表\"><a href=\"#反置页表\" class=\"headerlink\" title=\"反置页表\"></a>反置页表</h3><ul>\n<li>反置页表为每一个物理块（页框）设置一个页表项，并按物理块排序，其内容则是页号和其所属进程的标识。</li>\n</ul>\n<h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>没有外碎片，每个内碎片不超过页大小。</li>\n<li>一个程序不必连续存放。</li>\n<li>便于改变程序占用空间的大小。即随着程序运行而动态生成的数据增多，地址空间可相应增长。</li>\n</ul>\n<h3 id=\"缺点：程序全部装入内存。\"><a href=\"#缺点：程序全部装入内存。\" class=\"headerlink\" title=\"缺点：程序全部装入内存。\"></a>缺点：程序全部装入内存。</h3><h2 id=\"分段存储管理方式\"><a href=\"#分段存储管理方式\" class=\"headerlink\" title=\"分段存储管理方式\"></a>分段存储管理方式</h2><h3 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h3><ul>\n<li>方便编程</li>\n<li>信息共享</li>\n<li>动态增长</li>\n<li>动态链接</li>\n</ul>\n<h3 id=\"在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。\"><a href=\"#在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。\" class=\"headerlink\" title=\"在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。\"></a>在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。</h3><h3 id=\"内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定\"><a href=\"#内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定\" class=\"headerlink\" title=\"内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定\"></a>内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定</h3><h3 id=\"分段系统的基本原理\"><a href=\"#分段系统的基本原理\" class=\"headerlink\" title=\"分段系统的基本原理\"></a>分段系统的基本原理</h3><ul>\n<li>分段<ul>\n<li>格式：段号+段内地址</li>\n</ul>\n</li>\n<li>段表<ul>\n<li>段表实现了从逻辑段到物理内存区的映射。</li>\n</ul>\n</li>\n<li>地址变换机构</li>\n</ul>\n<h3 id=\"和分页的区别\"><a href=\"#和分页的区别\" class=\"headerlink\" title=\"和分页的区别\"></a>和分页的区别</h3><ul>\n<li>页是信息的物理单位</li>\n<li>页的大小固定且由系统固定</li>\n<li>分页的用户程序地址空间是一维的</li>\n<li>通常段比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。</li>\n<li>分页是系统管理的需要，分段是用户应用的需要。一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。</li>\n</ul>\n<h3 id=\"信息共享\"><a href=\"#信息共享\" class=\"headerlink\" title=\"信息共享\"></a>信息共享</h3><ul>\n<li>这是分段最重要的优点</li>\n</ul>\n<h3 id=\"段页式存储管理方式\"><a href=\"#段页式存储管理方式\" class=\"headerlink\" title=\"段页式存储管理方式\"></a>段页式存储管理方式</h3><ul>\n<li>基本原理<ul>\n<li>格式：段号（S）+段内页号（P）+页内地址（W）</li>\n</ul>\n</li>\n<li>地址变换过程<ul>\n<li>需要三次访问过程</li>\n</ul>\n</li>\n<li>在段页式系统中，为了获得一条指令或数据，需三次访问内存：第一次访问内存中的段表，从中取得页表始址；第二次访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正根据所得的物理地址取出指令或数据。</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"第四章-存储器管理\"><a href=\"#第四章-存储器管理\" class=\"headerlink\" title=\"第四章:存储器管理\"></a>第四章:存储器管理</h1><h2 id=\"存储器的层次结构\"><a href=\"#存储器的层次结构\" class=\"headerlink\" title=\"存储器的层次结构\"></a>存储器的层次结构</h2><h3 id=\"多层结构的存储系统\"><a href=\"#多层结构的存储系统\" class=\"headerlink\" title=\"多层结构的存储系统\"></a>多层结构的存储系统</h3><ul>\n<li>存储器的多层结构<ul>\n<li>CPU寄存器</li>\n<li>主存</li>\n<li>辅存</li>\n</ul>\n</li>\n<li>可执行存储器<ul>\n<li>寄存器和主存的总称</li>\n<li>访问速度快，进程可以在很少的时钟周期内用一条load或store指令完成存取。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"主存储器与寄存器\"><a href=\"#主存储器与寄存器\" class=\"headerlink\" title=\"主存储器与寄存器\"></a>主存储器与寄存器</h3><h3 id=\"高速缓存和磁盘缓存\"><a href=\"#高速缓存和磁盘缓存\" class=\"headerlink\" title=\"高速缓存和磁盘缓存\"></a>高速缓存和磁盘缓存</h3><h2 id=\"程序的装入和链接\"><a href=\"#程序的装入和链接\" class=\"headerlink\" title=\"程序的装入和链接\"></a>程序的装入和链接</h2><h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><ul>\n<li>编译<ul>\n<li>源程序 -&gt;目标模块（Object modules）——–Compiler<ul>\n<li>由编译程序对用户源程序进行编译，形成若干个目标模块</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>链接<ul>\n<li>一组目标模块 -&gt;装入模块 （Load Module）———-Linker<ul>\n<li>由链接程序将编译后形成的一组目标模板以及它们所需要的库函数链接在一起，形成一个完整的装入模块</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>装入<ul>\n<li>装入模块 -&gt;内存  ——–Loader<ul>\n<li>由装入程序将装入模块装入内存</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"程序的装入\"><a href=\"#程序的装入\" class=\"headerlink\" title=\"程序的装入\"></a>程序的装入</h3><ul>\n<li>绝对装入方式<ul>\n<li>在编译时，如果知道程序将驻留在内存中指定的位置。编译程序将产生绝对地址的目标代码。</li>\n</ul>\n</li>\n<li>可重定位装入方式<ul>\n<li>在可执行文件中，列出各个需要重定位的地址单元和相对地址值。当用户程序被装入内存时，一次性实现逻辑地址到物理地址的转换，以后不再转换(一般在装入内存时由软件完成)。</li>\n<li>优点：不需硬件支持，可以装入有限多道程序。</li>\n<li>缺点：一个程序通常需要占用连续的内存空间，程序装入内存后不能移动。不易实现共享。</li>\n</ul>\n</li>\n<li>动态运行时的装入方式<ul>\n<li>动态运行时的装入程序在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换为物理地址，而是把这种地址转换推迟到程序真正要执行时才进行</li>\n<li>优点：<ul>\n<li>OS可以将一个程序分散存放于不连续的内存空间，可以移动程序，有利用实现共享。</li>\n<li>能够支持程序执行中产生的地址引用，如指针变量（而不仅是生成可执行文件时的地址引用）。</li>\n</ul>\n</li>\n<li>缺点：需要硬件支持，OS实现较复杂。</li>\n<li>它是虚拟存储的基础。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"程序的链接\"><a href=\"#程序的链接\" class=\"headerlink\" title=\"程序的链接\"></a>程序的链接</h3><ul>\n<li>静态链接方式(lib)</li>\n<li>装入时动态链接</li>\n<li>运行时动态链接(dll)</li>\n</ul>\n<h2 id=\"连续分配存储管理方式\"><a href=\"#连续分配存储管理方式\" class=\"headerlink\" title=\"连续分配存储管理方式\"></a>连续分配存储管理方式</h2><h3 id=\"连续分配\"><a href=\"#连续分配\" class=\"headerlink\" title=\"连续分配\"></a>连续分配</h3><ul>\n<li>单一连续分配(DOS)</li>\n<li>固定分区分配(浪费很多空间)</li>\n<li>动态分区分配</li>\n</ul>\n<h3 id=\"地址映射和存储保护措施\"><a href=\"#地址映射和存储保护措施\" class=\"headerlink\" title=\"地址映射和存储保护措施\"></a>地址映射和存储保护措施</h3><ul>\n<li>基址寄存器：程序的最小物理地址</li>\n<li>界限寄存器：程序的逻辑地址范围</li>\n<li>物理地址 &#x3D; 逻辑地址 + 基址</li>\n</ul>\n<h3 id=\"内碎片：占用分区之内未被利用的空间\"><a href=\"#内碎片：占用分区之内未被利用的空间\" class=\"headerlink\" title=\"内碎片：占用分区之内未被利用的空间\"></a>内碎片：占用分区之内未被利用的空间</h3><h3 id=\"外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）\"><a href=\"#外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）\" class=\"headerlink\" title=\"外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）\"></a>外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）</h3><h3 id=\"把内存划分为若干个固定大小的连续分区。固定式分区又称为静态分区。\"><a href=\"#把内存划分为若干个固定大小的连续分区。固定式分区又称为静态分区。\" class=\"headerlink\" title=\"把内存划分为若干个固定大小的连续分区。固定式分区又称为静态分区。\"></a>把内存划分为若干个固定大小的连续分区。固定式分区又称为静态分区。</h3><ul>\n<li>分区大小相等：只适合于多个相同程序的并发执行（处理多个类型相同的对象）。</li>\n<li>分区大小不等：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。</li>\n<li>优点：无外碎片、易实现、开销小。</li>\n<li>缺点：<ul>\n<li>存在内碎片，造成浪费</li>\n<li>分区总数固定，限制了并发执行的程序数目。</li>\n<li>通用Os很少采用，部分控制系统中采用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"动态创建分区：指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。可变式分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。\"><a href=\"#动态创建分区：指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。可变式分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。\" class=\"headerlink\" title=\"动态创建分区：指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。可变式分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。\"></a>动态创建分区：指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。可变式分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。</h3><ul>\n<li>基于顺序搜索的动态分区分配算法<ul>\n<li>首次适应算法（first fit,FF）<ul>\n<li>顺序找，找到一个满足的就分配，但是可能存在浪费</li>\n<li>这种方法目的在于减少查找时间。</li>\n<li>空闲分区表（空闲区链）中的空闲分区要按地址由低到高进行排序</li>\n</ul>\n</li>\n<li>循环首次适应算法（next fit，NF）<ul>\n<li>相对上面那种，不是顺序，类似哈希算法中左右交叉排序</li>\n<li>空闲分区分布得更均匀，查找开销小</li>\n<li>从上次找到的空闲区的下一个空闲区开始查找，直到找到第一个能满足要求的的空闲区为止，并从中划出一块与请求大小相等的内存空间分配给作业。</li>\n</ul>\n</li>\n<li>最佳适应算法（best fit，BF）<ul>\n<li>找到最合适的，但是大区域的访问次数减少</li>\n<li>这种方法能使外碎片尽量小。</li>\n<li>空闲分区表（空闲区链）中的空闲分区要按大小从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。</li>\n</ul>\n</li>\n<li>最坏适应算法（worst fit，WF）<ul>\n<li>相对于最好而言，找最大的区域下手，导致最大的区域可能很少，也造成许多碎片</li>\n<li>空闲分区按大小由大到小排序</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>基于索引搜索的动态分区分配算法<ul>\n<li>快速适应算法（quick fit）</li>\n<li>伙伴系统（buddy system）</li>\n<li>哈希算法</li>\n</ul>\n</li>\n<li>动态可重定位分区分配<ul>\n<li>紧凑</li>\n<li>动态重定位<ul>\n<li>动态运行时装入，地址转化在指令执行时进行，需获得硬件地址变换机制的支持</li>\n<li>内存地址&#x3D;相对地址+起始地址</li>\n</ul>\n</li>\n<li>动态重定位分区分配算法<ul>\n<li>1、在某个分区被释放后立即进行紧凑，系统总是只有一个连续的分区而无碎片，此法很花费机时。</li>\n<li>2、当“请求分配模块”找不到足够大的自由分区分给用户时再进行紧凑，这样紧缩的次数比上种方法少得多，但管理复杂。采用此法的动态重定位分区分配算法框图如下：</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>优点：没有内碎片。</li>\n<li>缺点：外碎片。</li>\n</ul>\n<h2 id=\"对换（了解）\"><a href=\"#对换（了解）\" class=\"headerlink\" title=\"对换（了解）\"></a>对换（了解）</h2><h3 id=\"系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。\"><a href=\"#系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。\" class=\"headerlink\" title=\"系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。\"></a>系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。</h3><h2 id=\"基本分页存储管理方式\"><a href=\"#基本分页存储管理方式\" class=\"headerlink\" title=\"基本分页存储管理方式\"></a>基本分页存储管理方式</h2><h3 id=\"分页存储管理的基本方式\"><a href=\"#分页存储管理的基本方式\" class=\"headerlink\" title=\"分页存储管理的基本方式\"></a>分页存储管理的基本方式</h3><ul>\n<li>页面<ul>\n<li>将一个进程的逻辑地址空间分成若干个大小相等的片</li>\n</ul>\n</li>\n<li>页框（frame）<ul>\n<li>内存空间分成与页面相同大小的存储块</li>\n</ul>\n</li>\n<li>由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”</li>\n<li>地址结构<ul>\n<li>页号P+位移量W(0-31)</li>\n</ul>\n</li>\n<li>页表<ul>\n<li>在分页系统中，允许将进程的各个页离散地存储在内存在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每一个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表</li>\n<li>页表的作用是实现从页面号到物理块号的地址映射</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"地址变换机构\"><a href=\"#地址变换机构\" class=\"headerlink\" title=\"地址变换机构\"></a>地址变换机构</h3><ul>\n<li>基本的地址变换机构<ul>\n<li>要访问两次内存</li>\n<li>页表大都驻留在内存中</li>\n<li>为了实现地址变换功能，在系统中设置页表寄存器（PTR），用来存放页表的始址和页表的长度。</li>\n<li>在进程未执行时，每个进程对应的页表的始址和长度存放在进程的PCB中，当该进程被调度时，就将它们装入页表寄存器。</li>\n</ul>\n</li>\n<li>具有快表的地址变换机构<ul>\n<li>提高了效率，此处会有计算题</li>\n<li>如果页表存放在内存中，则每次访问内存时，都要先访问内存中的页表，然后根据所形成的物理地址再访问内存。这样CPU存一个数据必须访问两次内存，从而使计算机的处理速度降低了1&#x2F;2。</li>\n<li>为了提高地址变换的速度，在地址变换机构中增设了一个具有并行查询功能的特殊的高速缓冲存储器，称为“联想存储器”或“快表”，用以存放当前访问的那些页表项。</li>\n<li>地址变换过程为：<ul>\n<li>1、CPU给出有效地址</li>\n<li>2、地址变换机构自动地将页号送入高速缓存，确定所需要的页是否在快表中。</li>\n<li>3、若是，则直接读出该页所对应的物理块号，送入物理地址寄存器；</li>\n<li>4、若快表中未找到对应的页表项，则需再访问内存中的页表</li>\n<li>5、找到后，把从页表中读出的页表项存入快表中的一个寄存器单元中，以取代一个旧的页表项。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"两级和多级页表\"><a href=\"#两级和多级页表\" class=\"headerlink\" title=\"两级和多级页表\"></a>两级和多级页表</h3><ul>\n<li>主要是有的时候页表太多了，要化简</li>\n<li>格式：外层页号P1+外层页内地址P2+页内地址d</li>\n<li>基本方法：将页表进行分页，每个页面的大小与内存物理块的大小相同，并为它们进行编号，可以离散地将各个页面分别存放在不同的物理块中。</li>\n</ul>\n<h3 id=\"反置页表\"><a href=\"#反置页表\" class=\"headerlink\" title=\"反置页表\"></a>反置页表</h3><ul>\n<li>反置页表为每一个物理块（页框）设置一个页表项，并按物理块排序，其内容则是页号和其所属进程的标识。</li>\n</ul>\n<h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ul>\n<li>没有外碎片，每个内碎片不超过页大小。</li>\n<li>一个程序不必连续存放。</li>\n<li>便于改变程序占用空间的大小。即随着程序运行而动态生成的数据增多，地址空间可相应增长。</li>\n</ul>\n<h3 id=\"缺点：程序全部装入内存。\"><a href=\"#缺点：程序全部装入内存。\" class=\"headerlink\" title=\"缺点：程序全部装入内存。\"></a>缺点：程序全部装入内存。</h3><h2 id=\"分段存储管理方式\"><a href=\"#分段存储管理方式\" class=\"headerlink\" title=\"分段存储管理方式\"></a>分段存储管理方式</h2><h3 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h3><ul>\n<li>方便编程</li>\n<li>信息共享</li>\n<li>动态增长</li>\n<li>动态链接</li>\n</ul>\n<h3 id=\"在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。\"><a href=\"#在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。\" class=\"headerlink\" title=\"在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。\"></a>在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。</h3><h3 id=\"内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定\"><a href=\"#内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定\" class=\"headerlink\" title=\"内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定\"></a>内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定</h3><h3 id=\"分段系统的基本原理\"><a href=\"#分段系统的基本原理\" class=\"headerlink\" title=\"分段系统的基本原理\"></a>分段系统的基本原理</h3><ul>\n<li>分段<ul>\n<li>格式：段号+段内地址</li>\n</ul>\n</li>\n<li>段表<ul>\n<li>段表实现了从逻辑段到物理内存区的映射。</li>\n</ul>\n</li>\n<li>地址变换机构</li>\n</ul>\n<h3 id=\"和分页的区别\"><a href=\"#和分页的区别\" class=\"headerlink\" title=\"和分页的区别\"></a>和分页的区别</h3><ul>\n<li>页是信息的物理单位</li>\n<li>页的大小固定且由系统固定</li>\n<li>分页的用户程序地址空间是一维的</li>\n<li>通常段比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。</li>\n<li>分页是系统管理的需要，分段是用户应用的需要。一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。</li>\n</ul>\n<h3 id=\"信息共享\"><a href=\"#信息共享\" class=\"headerlink\" title=\"信息共享\"></a>信息共享</h3><ul>\n<li>这是分段最重要的优点</li>\n</ul>\n<h3 id=\"段页式存储管理方式\"><a href=\"#段页式存储管理方式\" class=\"headerlink\" title=\"段页式存储管理方式\"></a>段页式存储管理方式</h3><ul>\n<li>基本原理<ul>\n<li>格式：段号（S）+段内页号（P）+页内地址（W）</li>\n</ul>\n</li>\n<li>地址变换过程<ul>\n<li>需要三次访问过程</li>\n</ul>\n</li>\n<li>在段页式系统中，为了获得一条指令或数据，需三次访问内存：第一次访问内存中的段表，从中取得页表始址；第二次访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正根据所得的物理地址取出指令或数据。</li>\n</ul>\n"},{"_content":"# 第五章：虚拟存储器\n## 常规存储管理方式的特征\n### 一次性\n### 驻留性\n## 局部性原理\n### 程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域\n### 时间局限性\n* 如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环操作\n### 空间局限性\n* 一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。\n## 定义\n### 指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统\n## 优点\n### 大程序：可在较小的可用内存中执行较大的用户程序；\n### 大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存(real memory)\n### 并发：可在内存中容纳更多程序并发执行；\n### 易于开发：不必影响编程时的程序结构\n### 以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术\n## 特征\n### 离散性\n* 指在内存分配时采用离散的分配方式，它是虚拟存储器的实现的基础\n### 多次性\n* 指一个作业被分成多次调入内存运行，即在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可。多次性是虚拟存储器最重要的特征\n### 对换性\n* 指允许在作业的运行过程中在内存和外存的对换区之间换进、换出。\n### 虚拟性\n* 指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。\n## 虚拟存储器的实现方式\n### 请求分页存储管理方式\n* 硬件\n    * 请求页表机制\n        * 格式：页号+物理块号+状态位P+访问字段A+修改位M+外存地址\n    * 缺页中断机构\n    * 地址变换机构（过程图很关键）\n* 请求分页中的内存分配\n    * 最小物理块数\n        * 即能保证进程正常运行所需的最小物理块数\n    * 内存分配策略\n        * 固定分配局部置换（国王的大儿子）\n        * 可变分配全局置换（国王的二儿子）\n        * 可变分配局部置换（国王的小儿子）\n* 物理块分配算法\n    * 平均分配算法\n    * 按比例分配算法\n    * 考虑优先权的分配算法\n* 页面调入策略\n    * 系统应在何时调入所需页面\n        * 预调页策略（不能实现）\n        * 请求调页策略（需要才给）\n    * 系统应该从何处调入这些页面\n        * 对换区\n        * 文件区\n    * 页面调入过程\n    * 缺页率（出计算题）\n### 请求分段系统\n* 硬件\n    * 请求分段的段表机构\n    * 缺段中断机构\n    * 地址变换机构\n## 页面置换算法\n### 抖动的概念\n* 即刚被换出的页很快又要被访问，需要将它重新调入，此时又需要再选一页调出\n### 最佳置换算法(需要预知后面进程，所以不能实现)\n### 先进先出页面置换算法（FIFO）\n* 选择在内存中驻留时间最久的页面予以淘汰\n### 最近最久未使用置换算法（LRU）Recently\n* 寄存器支持\n* 特殊的栈结构\n### 最少使用置换算法（LFU）Frequently\n### clock置换算法（对访问位A的判断）\n* 改进型——增加对修改位M思维判断\n### 页面缓冲算法（PBA,page buffering algorithm）\n* 空闲页面链表\n* 修改页面链表\n","source":"_posts/2023-06-14-5-虚拟存储器.md","raw":"# 第五章：虚拟存储器\n## 常规存储管理方式的特征\n### 一次性\n### 驻留性\n## 局部性原理\n### 程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域\n### 时间局限性\n* 如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环操作\n### 空间局限性\n* 一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。\n## 定义\n### 指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统\n## 优点\n### 大程序：可在较小的可用内存中执行较大的用户程序；\n### 大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存(real memory)\n### 并发：可在内存中容纳更多程序并发执行；\n### 易于开发：不必影响编程时的程序结构\n### 以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术\n## 特征\n### 离散性\n* 指在内存分配时采用离散的分配方式，它是虚拟存储器的实现的基础\n### 多次性\n* 指一个作业被分成多次调入内存运行，即在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可。多次性是虚拟存储器最重要的特征\n### 对换性\n* 指允许在作业的运行过程中在内存和外存的对换区之间换进、换出。\n### 虚拟性\n* 指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。\n## 虚拟存储器的实现方式\n### 请求分页存储管理方式\n* 硬件\n    * 请求页表机制\n        * 格式：页号+物理块号+状态位P+访问字段A+修改位M+外存地址\n    * 缺页中断机构\n    * 地址变换机构（过程图很关键）\n* 请求分页中的内存分配\n    * 最小物理块数\n        * 即能保证进程正常运行所需的最小物理块数\n    * 内存分配策略\n        * 固定分配局部置换（国王的大儿子）\n        * 可变分配全局置换（国王的二儿子）\n        * 可变分配局部置换（国王的小儿子）\n* 物理块分配算法\n    * 平均分配算法\n    * 按比例分配算法\n    * 考虑优先权的分配算法\n* 页面调入策略\n    * 系统应在何时调入所需页面\n        * 预调页策略（不能实现）\n        * 请求调页策略（需要才给）\n    * 系统应该从何处调入这些页面\n        * 对换区\n        * 文件区\n    * 页面调入过程\n    * 缺页率（出计算题）\n### 请求分段系统\n* 硬件\n    * 请求分段的段表机构\n    * 缺段中断机构\n    * 地址变换机构\n## 页面置换算法\n### 抖动的概念\n* 即刚被换出的页很快又要被访问，需要将它重新调入，此时又需要再选一页调出\n### 最佳置换算法(需要预知后面进程，所以不能实现)\n### 先进先出页面置换算法（FIFO）\n* 选择在内存中驻留时间最久的页面予以淘汰\n### 最近最久未使用置换算法（LRU）Recently\n* 寄存器支持\n* 特殊的栈结构\n### 最少使用置换算法（LFU）Frequently\n### clock置换算法（对访问位A的判断）\n* 改进型——增加对修改位M思维判断\n### 页面缓冲算法（PBA,page buffering algorithm）\n* 空闲页面链表\n* 修改页面链表\n","slug":"2023-06-14-5-虚拟存储器","published":1,"date":"2023-12-15T02:31:42.099Z","updated":"2023-12-15T02:31:42.107Z","_id":"clq60josk00054zgs6wqq5ca2","title":"","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"第五章：虚拟存储器\"><a href=\"#第五章：虚拟存储器\" class=\"headerlink\" title=\"第五章：虚拟存储器\"></a>第五章：虚拟存储器</h1><h2 id=\"常规存储管理方式的特征\"><a href=\"#常规存储管理方式的特征\" class=\"headerlink\" title=\"常规存储管理方式的特征\"></a>常规存储管理方式的特征</h2><h3 id=\"一次性\"><a href=\"#一次性\" class=\"headerlink\" title=\"一次性\"></a>一次性</h3><h3 id=\"驻留性\"><a href=\"#驻留性\" class=\"headerlink\" title=\"驻留性\"></a>驻留性</h3><h2 id=\"局部性原理\"><a href=\"#局部性原理\" class=\"headerlink\" title=\"局部性原理\"></a>局部性原理</h2><h3 id=\"程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域\"><a href=\"#程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域\" class=\"headerlink\" title=\"程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域\"></a>程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域</h3><h3 id=\"时间局限性\"><a href=\"#时间局限性\" class=\"headerlink\" title=\"时间局限性\"></a>时间局限性</h3><ul>\n<li>如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环操作</li>\n</ul>\n<h3 id=\"空间局限性\"><a href=\"#空间局限性\" class=\"headerlink\" title=\"空间局限性\"></a>空间局限性</h3><ul>\n<li>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。</li>\n</ul>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><h3 id=\"指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统\"><a href=\"#指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统\" class=\"headerlink\" title=\"指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统\"></a>指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统</h3><h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><h3 id=\"大程序：可在较小的可用内存中执行较大的用户程序；\"><a href=\"#大程序：可在较小的可用内存中执行较大的用户程序；\" class=\"headerlink\" title=\"大程序：可在较小的可用内存中执行较大的用户程序；\"></a>大程序：可在较小的可用内存中执行较大的用户程序；</h3><h3 id=\"大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存-real-memory\"><a href=\"#大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存-real-memory\" class=\"headerlink\" title=\"大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存(real memory)\"></a>大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存(real memory)</h3><h3 id=\"并发：可在内存中容纳更多程序并发执行；\"><a href=\"#并发：可在内存中容纳更多程序并发执行；\" class=\"headerlink\" title=\"并发：可在内存中容纳更多程序并发执行；\"></a>并发：可在内存中容纳更多程序并发执行；</h3><h3 id=\"易于开发：不必影响编程时的程序结构\"><a href=\"#易于开发：不必影响编程时的程序结构\" class=\"headerlink\" title=\"易于开发：不必影响编程时的程序结构\"></a>易于开发：不必影响编程时的程序结构</h3><h3 id=\"以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术\"><a href=\"#以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术\" class=\"headerlink\" title=\"以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术\"></a>以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术</h3><h2 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h2><h3 id=\"离散性\"><a href=\"#离散性\" class=\"headerlink\" title=\"离散性\"></a>离散性</h3><ul>\n<li>指在内存分配时采用离散的分配方式，它是虚拟存储器的实现的基础</li>\n</ul>\n<h3 id=\"多次性\"><a href=\"#多次性\" class=\"headerlink\" title=\"多次性\"></a>多次性</h3><ul>\n<li>指一个作业被分成多次调入内存运行，即在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可。多次性是虚拟存储器最重要的特征</li>\n</ul>\n<h3 id=\"对换性\"><a href=\"#对换性\" class=\"headerlink\" title=\"对换性\"></a>对换性</h3><ul>\n<li>指允许在作业的运行过程中在内存和外存的对换区之间换进、换出。</li>\n</ul>\n<h3 id=\"虚拟性\"><a href=\"#虚拟性\" class=\"headerlink\" title=\"虚拟性\"></a>虚拟性</h3><ul>\n<li>指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</li>\n</ul>\n<h2 id=\"虚拟存储器的实现方式\"><a href=\"#虚拟存储器的实现方式\" class=\"headerlink\" title=\"虚拟存储器的实现方式\"></a>虚拟存储器的实现方式</h2><h3 id=\"请求分页存储管理方式\"><a href=\"#请求分页存储管理方式\" class=\"headerlink\" title=\"请求分页存储管理方式\"></a>请求分页存储管理方式</h3><ul>\n<li>硬件<ul>\n<li>请求页表机制<ul>\n<li>格式：页号+物理块号+状态位P+访问字段A+修改位M+外存地址</li>\n</ul>\n</li>\n<li>缺页中断机构</li>\n<li>地址变换机构（过程图很关键）</li>\n</ul>\n</li>\n<li>请求分页中的内存分配<ul>\n<li>最小物理块数<ul>\n<li>即能保证进程正常运行所需的最小物理块数</li>\n</ul>\n</li>\n<li>内存分配策略<ul>\n<li>固定分配局部置换（国王的大儿子）</li>\n<li>可变分配全局置换（国王的二儿子）</li>\n<li>可变分配局部置换（国王的小儿子）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>物理块分配算法<ul>\n<li>平均分配算法</li>\n<li>按比例分配算法</li>\n<li>考虑优先权的分配算法</li>\n</ul>\n</li>\n<li>页面调入策略<ul>\n<li>系统应在何时调入所需页面<ul>\n<li>预调页策略（不能实现）</li>\n<li>请求调页策略（需要才给）</li>\n</ul>\n</li>\n<li>系统应该从何处调入这些页面<ul>\n<li>对换区</li>\n<li>文件区</li>\n</ul>\n</li>\n<li>页面调入过程</li>\n<li>缺页率（出计算题）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"请求分段系统\"><a href=\"#请求分段系统\" class=\"headerlink\" title=\"请求分段系统\"></a>请求分段系统</h3><ul>\n<li>硬件<ul>\n<li>请求分段的段表机构</li>\n<li>缺段中断机构</li>\n<li>地址变换机构</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"页面置换算法\"><a href=\"#页面置换算法\" class=\"headerlink\" title=\"页面置换算法\"></a>页面置换算法</h2><h3 id=\"抖动的概念\"><a href=\"#抖动的概念\" class=\"headerlink\" title=\"抖动的概念\"></a>抖动的概念</h3><ul>\n<li>即刚被换出的页很快又要被访问，需要将它重新调入，此时又需要再选一页调出</li>\n</ul>\n<h3 id=\"最佳置换算法-需要预知后面进程，所以不能实现\"><a href=\"#最佳置换算法-需要预知后面进程，所以不能实现\" class=\"headerlink\" title=\"最佳置换算法(需要预知后面进程，所以不能实现)\"></a>最佳置换算法(需要预知后面进程，所以不能实现)</h3><h3 id=\"先进先出页面置换算法（FIFO）\"><a href=\"#先进先出页面置换算法（FIFO）\" class=\"headerlink\" title=\"先进先出页面置换算法（FIFO）\"></a>先进先出页面置换算法（FIFO）</h3><ul>\n<li>选择在内存中驻留时间最久的页面予以淘汰</li>\n</ul>\n<h3 id=\"最近最久未使用置换算法（LRU）Recently\"><a href=\"#最近最久未使用置换算法（LRU）Recently\" class=\"headerlink\" title=\"最近最久未使用置换算法（LRU）Recently\"></a>最近最久未使用置换算法（LRU）Recently</h3><ul>\n<li>寄存器支持</li>\n<li>特殊的栈结构</li>\n</ul>\n<h3 id=\"最少使用置换算法（LFU）Frequently\"><a href=\"#最少使用置换算法（LFU）Frequently\" class=\"headerlink\" title=\"最少使用置换算法（LFU）Frequently\"></a>最少使用置换算法（LFU）Frequently</h3><h3 id=\"clock置换算法（对访问位A的判断）\"><a href=\"#clock置换算法（对访问位A的判断）\" class=\"headerlink\" title=\"clock置换算法（对访问位A的判断）\"></a>clock置换算法（对访问位A的判断）</h3><ul>\n<li>改进型——增加对修改位M思维判断</li>\n</ul>\n<h3 id=\"页面缓冲算法（PBA-page-buffering-algorithm）\"><a href=\"#页面缓冲算法（PBA-page-buffering-algorithm）\" class=\"headerlink\" title=\"页面缓冲算法（PBA,page buffering algorithm）\"></a>页面缓冲算法（PBA,page buffering algorithm）</h3><ul>\n<li>空闲页面链表</li>\n<li>修改页面链表</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"第五章：虚拟存储器\"><a href=\"#第五章：虚拟存储器\" class=\"headerlink\" title=\"第五章：虚拟存储器\"></a>第五章：虚拟存储器</h1><h2 id=\"常规存储管理方式的特征\"><a href=\"#常规存储管理方式的特征\" class=\"headerlink\" title=\"常规存储管理方式的特征\"></a>常规存储管理方式的特征</h2><h3 id=\"一次性\"><a href=\"#一次性\" class=\"headerlink\" title=\"一次性\"></a>一次性</h3><h3 id=\"驻留性\"><a href=\"#驻留性\" class=\"headerlink\" title=\"驻留性\"></a>驻留性</h3><h2 id=\"局部性原理\"><a href=\"#局部性原理\" class=\"headerlink\" title=\"局部性原理\"></a>局部性原理</h2><h3 id=\"程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域\"><a href=\"#程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域\" class=\"headerlink\" title=\"程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域\"></a>程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域</h3><h3 id=\"时间局限性\"><a href=\"#时间局限性\" class=\"headerlink\" title=\"时间局限性\"></a>时间局限性</h3><ul>\n<li>如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环操作</li>\n</ul>\n<h3 id=\"空间局限性\"><a href=\"#空间局限性\" class=\"headerlink\" title=\"空间局限性\"></a>空间局限性</h3><ul>\n<li>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。</li>\n</ul>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><h3 id=\"指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统\"><a href=\"#指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统\" class=\"headerlink\" title=\"指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统\"></a>指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统</h3><h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><h3 id=\"大程序：可在较小的可用内存中执行较大的用户程序；\"><a href=\"#大程序：可在较小的可用内存中执行较大的用户程序；\" class=\"headerlink\" title=\"大程序：可在较小的可用内存中执行较大的用户程序；\"></a>大程序：可在较小的可用内存中执行较大的用户程序；</h3><h3 id=\"大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存-real-memory\"><a href=\"#大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存-real-memory\" class=\"headerlink\" title=\"大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存(real memory)\"></a>大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存(real memory)</h3><h3 id=\"并发：可在内存中容纳更多程序并发执行；\"><a href=\"#并发：可在内存中容纳更多程序并发执行；\" class=\"headerlink\" title=\"并发：可在内存中容纳更多程序并发执行；\"></a>并发：可在内存中容纳更多程序并发执行；</h3><h3 id=\"易于开发：不必影响编程时的程序结构\"><a href=\"#易于开发：不必影响编程时的程序结构\" class=\"headerlink\" title=\"易于开发：不必影响编程时的程序结构\"></a>易于开发：不必影响编程时的程序结构</h3><h3 id=\"以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术\"><a href=\"#以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术\" class=\"headerlink\" title=\"以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术\"></a>以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术</h3><h2 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h2><h3 id=\"离散性\"><a href=\"#离散性\" class=\"headerlink\" title=\"离散性\"></a>离散性</h3><ul>\n<li>指在内存分配时采用离散的分配方式，它是虚拟存储器的实现的基础</li>\n</ul>\n<h3 id=\"多次性\"><a href=\"#多次性\" class=\"headerlink\" title=\"多次性\"></a>多次性</h3><ul>\n<li>指一个作业被分成多次调入内存运行，即在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可。多次性是虚拟存储器最重要的特征</li>\n</ul>\n<h3 id=\"对换性\"><a href=\"#对换性\" class=\"headerlink\" title=\"对换性\"></a>对换性</h3><ul>\n<li>指允许在作业的运行过程中在内存和外存的对换区之间换进、换出。</li>\n</ul>\n<h3 id=\"虚拟性\"><a href=\"#虚拟性\" class=\"headerlink\" title=\"虚拟性\"></a>虚拟性</h3><ul>\n<li>指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</li>\n</ul>\n<h2 id=\"虚拟存储器的实现方式\"><a href=\"#虚拟存储器的实现方式\" class=\"headerlink\" title=\"虚拟存储器的实现方式\"></a>虚拟存储器的实现方式</h2><h3 id=\"请求分页存储管理方式\"><a href=\"#请求分页存储管理方式\" class=\"headerlink\" title=\"请求分页存储管理方式\"></a>请求分页存储管理方式</h3><ul>\n<li>硬件<ul>\n<li>请求页表机制<ul>\n<li>格式：页号+物理块号+状态位P+访问字段A+修改位M+外存地址</li>\n</ul>\n</li>\n<li>缺页中断机构</li>\n<li>地址变换机构（过程图很关键）</li>\n</ul>\n</li>\n<li>请求分页中的内存分配<ul>\n<li>最小物理块数<ul>\n<li>即能保证进程正常运行所需的最小物理块数</li>\n</ul>\n</li>\n<li>内存分配策略<ul>\n<li>固定分配局部置换（国王的大儿子）</li>\n<li>可变分配全局置换（国王的二儿子）</li>\n<li>可变分配局部置换（国王的小儿子）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>物理块分配算法<ul>\n<li>平均分配算法</li>\n<li>按比例分配算法</li>\n<li>考虑优先权的分配算法</li>\n</ul>\n</li>\n<li>页面调入策略<ul>\n<li>系统应在何时调入所需页面<ul>\n<li>预调页策略（不能实现）</li>\n<li>请求调页策略（需要才给）</li>\n</ul>\n</li>\n<li>系统应该从何处调入这些页面<ul>\n<li>对换区</li>\n<li>文件区</li>\n</ul>\n</li>\n<li>页面调入过程</li>\n<li>缺页率（出计算题）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"请求分段系统\"><a href=\"#请求分段系统\" class=\"headerlink\" title=\"请求分段系统\"></a>请求分段系统</h3><ul>\n<li>硬件<ul>\n<li>请求分段的段表机构</li>\n<li>缺段中断机构</li>\n<li>地址变换机构</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"页面置换算法\"><a href=\"#页面置换算法\" class=\"headerlink\" title=\"页面置换算法\"></a>页面置换算法</h2><h3 id=\"抖动的概念\"><a href=\"#抖动的概念\" class=\"headerlink\" title=\"抖动的概念\"></a>抖动的概念</h3><ul>\n<li>即刚被换出的页很快又要被访问，需要将它重新调入，此时又需要再选一页调出</li>\n</ul>\n<h3 id=\"最佳置换算法-需要预知后面进程，所以不能实现\"><a href=\"#最佳置换算法-需要预知后面进程，所以不能实现\" class=\"headerlink\" title=\"最佳置换算法(需要预知后面进程，所以不能实现)\"></a>最佳置换算法(需要预知后面进程，所以不能实现)</h3><h3 id=\"先进先出页面置换算法（FIFO）\"><a href=\"#先进先出页面置换算法（FIFO）\" class=\"headerlink\" title=\"先进先出页面置换算法（FIFO）\"></a>先进先出页面置换算法（FIFO）</h3><ul>\n<li>选择在内存中驻留时间最久的页面予以淘汰</li>\n</ul>\n<h3 id=\"最近最久未使用置换算法（LRU）Recently\"><a href=\"#最近最久未使用置换算法（LRU）Recently\" class=\"headerlink\" title=\"最近最久未使用置换算法（LRU）Recently\"></a>最近最久未使用置换算法（LRU）Recently</h3><ul>\n<li>寄存器支持</li>\n<li>特殊的栈结构</li>\n</ul>\n<h3 id=\"最少使用置换算法（LFU）Frequently\"><a href=\"#最少使用置换算法（LFU）Frequently\" class=\"headerlink\" title=\"最少使用置换算法（LFU）Frequently\"></a>最少使用置换算法（LFU）Frequently</h3><h3 id=\"clock置换算法（对访问位A的判断）\"><a href=\"#clock置换算法（对访问位A的判断）\" class=\"headerlink\" title=\"clock置换算法（对访问位A的判断）\"></a>clock置换算法（对访问位A的判断）</h3><ul>\n<li>改进型——增加对修改位M思维判断</li>\n</ul>\n<h3 id=\"页面缓冲算法（PBA-page-buffering-algorithm）\"><a href=\"#页面缓冲算法（PBA-page-buffering-algorithm）\" class=\"headerlink\" title=\"页面缓冲算法（PBA,page buffering algorithm）\"></a>页面缓冲算法（PBA,page buffering algorithm）</h3><ul>\n<li>空闲页面链表</li>\n<li>修改页面链表</li>\n</ul>\n"},{"_content":"# 第六章：输入输出系统\n## I/O系统的功能，模型和接口\n### I/O系统管理的对象是I/O设备和相应的设备控制器。\n### I/O系统的基本功能\n* 隐藏物理设备的细节\n* 与设备的无关性\n* 提高处理机和I/O设备的利用率\n* 对I/O设备进行控制\n* 确保对设备的正确共享\n* 错误处理\n### I/O软件的层次结构\n* 用户层I/O软件\n* 设备独立性软件\n* 设备驱动程序（厂家开发）\n* 中断处理程序\n* 硬件\n### I/O系统的分层\n* 中断处理程序\n* 设备驱动程序\n* 设备独立性软件\n### I/O系统接口\n* 块设备接口\n    * 指以数据块为单位来组织和传送数据信息的设备\n    * 典型的块设备是磁盘、光盘\n    * 块设备的基本特征\n        * ①传输速率较高，通常每秒钟为几兆位；\n        * ②它是可寻址的，即可随机地读/写任意一块；\n        * ③磁盘设备的I/O采用DMA方式。\n* 流设备接口\n    * 又称字符设备指以单个字符为单位来传送数据信息的设备\n    * 这类设备一般用于数据的输入和输出，有交互式终端、打印机\n    * 字符设备的基本特征\n        * ①传输速率较低；\n        * ②不可寻址，即不能指定输入时的源地址或输出时的目标地址；\n        * ③字符设备的I/O常采用中断驱动方式。\n* 网络通信接口\n    * 提供网络接入功能，使计算机能通过网络与其他计算机进行通信或上网浏览。\n## I/O设备和设备控制器\n### 分类\n* 使用特性分\n    * 存储设备\n    * I/O设备\n* 传输速率分\n    * 低速设备（几字节——几百字节）\n        * 典型的设备有键盘、鼠标、语音的输入\n    * 中速设备（数千——数万字节）\n        * 典型的设备有行式打印机、激光打印机\n    * 高速设备（数十万——千兆字节）\n        * 典型的设备有磁带机、磁盘机、光盘机\n### 设备并不是直接与CPU进行通信，而是与设备控制器通信。在设备与设备控制器之间应该有一个接口。\n* 数据信号：控制器 ←  设备 ←  控制器\n    * 传送数据信号，输入、输出bit\n* 控制信号: 控制器  →  设备\n    * 执行读、写操作的信号\n* 状态信号：设备当前使用状态\n### 设备控制器\n* 主要功能：控制一个或多个I/O设备，以实现I/O设备和计算机之间的数据交换\n* 基本功能\n    * 接收和识别命令\n        * 控制寄存器、命令译码器\n    * 数据交换\n        * 实现CPU与控制器，控制器与设备间的数据交换\n    * 标识和报告设备的状态\n    * 地址识别\n        * 配置地址译码器，识别不同的设备\n    * 数据缓冲区\n    * 差错控制\n* 设备控制器的组成\n    * 设备控制器与处理机（CPU）的接口\n        * 实现CPU与设备控制器之间的通信\n    * 设备控制器与设备的接口\n        * 控制器可连接多个设备\n    * I/O逻辑\n        * 实现对设备的控制\n        * CPU利用该逻辑向控制器发送I/O命令\n        * 命令、地址译码\n### 内存映像I/O\n* 驱动程序将抽象I/O命令转换出的一系列具体的命令，参数等数据装入设备控制器的相应寄存器，由控制器来执行这些命令，具体实施对I/O设备的操作\n### I/O通道\n* 目的：建立独立的I/O操作(组织, 管理和结束)，使由CPU处理的I/O工作转由通道完成（解放CPU，实现并行）\n\n* 什么是I/O通道？\n    *  是一种特殊的处理机，具有通过执行通道程序完成I/O操作的指令\n    *  特点：指令单一(局限于与I/O操作相关的指令)，与CPU共享内存\n* 基本过程：\n    * CPU向通道发出I/O指令->通道接收指令->从内存取出通道程序处理I/O->向CPU发出中断\n* 通道类型\n    * 字节多路通道\n        * 低中速连接子通道时间片轮转方式共享主通道\n        * 字节多路通道不适于连接高速设备，这推动了按数组方式进行数据传送的数组选择通道的形成。\n    * 数组选择通道\n        * 这种通道可以连接多台高速设备，但只含有一个分配型子通道，在一段时间内只能执行一道通道程序， 控制一台设备进行数据传送， 直至该设备传送完毕释放该通道。这种通道的利用率很低。\n    * 数组多路通道\n        * 含有多个非分配型子通道，前两种通道的组合，通道利用率较好\n* 瓶颈问题\n    * 原因;通道不足\n    * 解决办法：增加设备到主机间的通路，而不增加通道（结果类似RS触发器）\n## 中断机构和中断处理程序\n### 中断\n* 分类\n    * 中断（外部触发）\n        * 对外部I/O设备发出的中断信号的响应\n    * 陷入（内部原因：除0）\n        * 由CPU内部事件引起的中断\n* 中断向量表（类比51单片机）\n    * 中断程序的入口地址表\n* 中断优先级\n    * 对紧急程度不同的中断处理方式\n* 对多中断源的处理方式\n    * 屏蔽中断\n    * 嵌套中断\n### 中断处理程序\n* 测定是否有未响应的中断信号\n* 保护被中断进程的CPU环境\n* 转入相应的设备处理程序\n* 中断处理\n* 恢复CPU 的现场并退出中断\n## 设备驱动程序\n### 是I/O进程与设备控制器之间的通信程序，又由于它常以进程的形式存在，故以后就简称为设备驱动进程\n### 主要任务是接受来自它上一层的与设备无关软件的抽象请求，并执行这个请求。\n### 功能\n* 1) 接收由I/O进程发来的命令和参数， 并将命令中的抽象要求转换为具体要求。例如，将磁盘块号转换为磁盘的盘面、 磁道号及扇区号。\n* 2) 检查用户I/O请求的合法性，了解I/O设备的状态，传递有关参数，设置设备的工作方式。 \n* 3) 发出I/O命令，如果设备空闲，便立即启动I/O设备去完成指定的I/O操作；如果设备处于忙碌状态，则将请求者的请求块挂在设备队列上等待。\n* 4) 及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。\n* 5) 对于设置有通道的计算机系统，驱动程序还应能够根据用户的I/O请求，自动地构成通道程序。 \n### 设备驱动程序的处理过程\n* 将用户和上层软件对设备控制的抽象要求转换成对设备的具体要求，如对抽象要求的盘块号转换为磁盘的盘面、磁道及扇区。\n* 检查I/O请求的合理性。\n* 读出和检查设备的状态，确保设备处于就绪态。\n* 传送必要的参数，如传送的字节数，数据在主存的首址等。\n* 工作方式的设置。\n* 启动I/O设备，并检查启动是否成功，如成功则将控制返回给I/O控制系统，在I/O设备忙于传送数据时，该用户进程把自己阻塞，直至中断到来才将它唤醒，而CPU可干别的事。\n### 对I/O设备的控制方式\n* I/O控制的宗旨\n    * 减少CPU对I/O控制的干预\n    * 充分利用CPU完成数据处理工作\n* I/O 控制方式\n    * 轮询的可编程I/O方式\n    * 中断驱动I/O方式\n    * DMA控制方式\n    * I/O通道控制方式\n### DMA控制器组成\n* 主机与DMA控制器的接口\n* DMA控制器与块设备的接口\n* I/O控制逻辑\n## 与设备无关的I/O软件\n### 基本概念\n* 含义： 应用程序独立于具体使用的物理设备。\n* 驱动程序是一个与硬件(或设备)紧密相关的软件。为实现设备独立性，须在驱动程序上设置一层软件，称为设备独立性软件。\n* 设备独立性(Device Independence)的优点\n    * 以物理设备名使用设备\n    * 引入了逻辑设备名\n    * 逻辑设备名称到物理设备名称的转换（易于实现I/O重定向）\n### 与设备无关的软件\n* 设备驱动程序的统一接口\n* 缓存管理\n* 差错控制\n* 对独立设备的分配与回收\n* 独立于设备的逻辑数据块\n### 设备分配中的数据结构\n* 设备控制表DCT\n* 控制器控制表COCT\n* 通道控制表CHCT\n* 显然，在有通道的系统中，一个进程只有获得了通道，控制器和所需设备三者之后，才具备了进行I/O操作的物理条件\n* 系统设备表SDT\n* 逻辑设备表LUT\n* 分配的流程，从资源多的到资源紧张的:LUT->SDT->DCT->COCT->CHCT\n* 在申请设备的过程中，根据用户请求的I/O设备的逻辑名，查找逻辑设备和物理设备的映射表；以物理设备为索引，查找SDT，找到该设备所连接的DCT；继续查找与该设备连接的COCT和CHCT，就找到了一条通路。\n## 用户层的I/O软件\n### 系统调用与库函数\n* OS向用户提供的所有功能，用户进程都必须通过系统调用来获取\n* 在C语言以及UNIX系统中，系统调用（如read）与各系统调用所使用的库函数（如read）之间几乎是一一对应的。而微软的叫Win32API\n### 假脱机系统（spooling）\n* spooling技术是对脱机输入/输出系统的模拟\n* 主要组成\n    * 输入/输出井\n    * 输入/输出缓冲区\n    * 输入/输出进程\n    * 井管理程序\n* 特点（体现操作系统的虚拟性）\n    * 提高了I/O的速度\n        * 对数据所进行的I/O操作，已从对低速设备演变为对输入井或输出井中的数据存取。\n    * 将独占设备改造为共享设备\n        * 实际分给用户进程的不是打印设备，而是共享输出井中的存储区域 \n    * 实现了虚拟设备功能\n        * 将独占设备变成多台独占的虚拟设备。\n## 缓冲区管理\n### 缓冲的引入（原因）\n* 缓和CPU与I/O设备间速度不匹配的矛盾\n* 减少对CPU的中断频率，放宽对CPU中断响应时间的限制\n* 提高CPU和I/O设备之间的并行性\n* 解决数据粒度不匹配的问题\n### 单缓冲区\n* 即在CPU计算的时候，将数据数据输入到缓冲区(大小取决与T和C的大小)\n### 双缓冲区\n* 即允许CPU连续工作（T不断）\n### 环形缓冲区（专为生产者和消费者打造）\n* 组成\n    * 多个缓冲区\n    * 多个指针\n* 使用\n    * Getbuf过程\n    * Releasebuf过程\n* 同步问题\n### 缓冲池(理解为更大的缓冲区)\n* 组成\n    * 空白缓冲队列（emq）\n        * 由空缓冲区链接而成F(emq)，L(emq)分别指向该队列首尾缓冲区\n    * 输入队列（inq）\n        * 由装满输入数据的缓冲区链接而成F(inq)，L(inq)分别指向该队列首尾缓冲区\n    * 输出队列（outq）\n        * 由装满输出数据的缓冲区链接而成F(outq)， L(outq)分别指向该队列首尾缓冲\n* Getbuf和Putbuf过程\n    * 收容：缓冲池接收外界数据\n    * 提取：外界从缓冲池获得数据\n* 缓冲区工作方式（从缓冲区的角度来看）\n    * 收容输入\n    * 提取输入\n    * 收容输出\n    * 提取输出\n## 磁盘存储器的性能和调度\n### 数据的组织和格式\n### 磁盘的类型\n* 固定头磁盘（贵）\n* 移动头磁盘\n### 磁盘访问的时间（关键）\n* 寻道时间Ts=m*n+s\n* 旋转延迟时间Tr\n* 传输时间Tt=b/rN\n* 总时间Ta=Ts+1/2r+b/rN\n### 磁盘的调度算法（掌握图表）\n* 先来先服务（FCFS）\n    * 优点：公平，简单\n    * 缺点：可能导致某些进程的请求长期得不到满足\n* 最短寻道时间优先（SSTF）\n    * 说明：要求访问的磁道和当前磁头所在的磁道距离最近，以使每次的寻道时间最短\n* 扫描算法（SCAN）\n    * 扫描算法不仅考虑到欲访问的磁道与当前磁道间的距离，更优先考虑的是磁道当前的移动方向\n    * 联想电梯的运行\n    * 可防止低优先级进程出现“饥饿”的现象\n* 循环扫描算法（CSCAN）\n    * 算法规定磁头单向移动，例如，只是自里向外移动，当磁头移到最外的磁道并访问后，磁头立即返回到最里的欲访问磁道，亦即将最小磁道号紧接着最大磁道号构成循环，进行循环扫描\n* NStepScan算法\n    * N步SCAN算法是将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次这些子队列。\n* FSCAN算法\n    * 是Nstepscan算法的简化，将磁盘请求队列分成两个子队列\n","source":"_posts/2023-06-14-6-输入输出系统.md","raw":"# 第六章：输入输出系统\n## I/O系统的功能，模型和接口\n### I/O系统管理的对象是I/O设备和相应的设备控制器。\n### I/O系统的基本功能\n* 隐藏物理设备的细节\n* 与设备的无关性\n* 提高处理机和I/O设备的利用率\n* 对I/O设备进行控制\n* 确保对设备的正确共享\n* 错误处理\n### I/O软件的层次结构\n* 用户层I/O软件\n* 设备独立性软件\n* 设备驱动程序（厂家开发）\n* 中断处理程序\n* 硬件\n### I/O系统的分层\n* 中断处理程序\n* 设备驱动程序\n* 设备独立性软件\n### I/O系统接口\n* 块设备接口\n    * 指以数据块为单位来组织和传送数据信息的设备\n    * 典型的块设备是磁盘、光盘\n    * 块设备的基本特征\n        * ①传输速率较高，通常每秒钟为几兆位；\n        * ②它是可寻址的，即可随机地读/写任意一块；\n        * ③磁盘设备的I/O采用DMA方式。\n* 流设备接口\n    * 又称字符设备指以单个字符为单位来传送数据信息的设备\n    * 这类设备一般用于数据的输入和输出，有交互式终端、打印机\n    * 字符设备的基本特征\n        * ①传输速率较低；\n        * ②不可寻址，即不能指定输入时的源地址或输出时的目标地址；\n        * ③字符设备的I/O常采用中断驱动方式。\n* 网络通信接口\n    * 提供网络接入功能，使计算机能通过网络与其他计算机进行通信或上网浏览。\n## I/O设备和设备控制器\n### 分类\n* 使用特性分\n    * 存储设备\n    * I/O设备\n* 传输速率分\n    * 低速设备（几字节——几百字节）\n        * 典型的设备有键盘、鼠标、语音的输入\n    * 中速设备（数千——数万字节）\n        * 典型的设备有行式打印机、激光打印机\n    * 高速设备（数十万——千兆字节）\n        * 典型的设备有磁带机、磁盘机、光盘机\n### 设备并不是直接与CPU进行通信，而是与设备控制器通信。在设备与设备控制器之间应该有一个接口。\n* 数据信号：控制器 ←  设备 ←  控制器\n    * 传送数据信号，输入、输出bit\n* 控制信号: 控制器  →  设备\n    * 执行读、写操作的信号\n* 状态信号：设备当前使用状态\n### 设备控制器\n* 主要功能：控制一个或多个I/O设备，以实现I/O设备和计算机之间的数据交换\n* 基本功能\n    * 接收和识别命令\n        * 控制寄存器、命令译码器\n    * 数据交换\n        * 实现CPU与控制器，控制器与设备间的数据交换\n    * 标识和报告设备的状态\n    * 地址识别\n        * 配置地址译码器，识别不同的设备\n    * 数据缓冲区\n    * 差错控制\n* 设备控制器的组成\n    * 设备控制器与处理机（CPU）的接口\n        * 实现CPU与设备控制器之间的通信\n    * 设备控制器与设备的接口\n        * 控制器可连接多个设备\n    * I/O逻辑\n        * 实现对设备的控制\n        * CPU利用该逻辑向控制器发送I/O命令\n        * 命令、地址译码\n### 内存映像I/O\n* 驱动程序将抽象I/O命令转换出的一系列具体的命令，参数等数据装入设备控制器的相应寄存器，由控制器来执行这些命令，具体实施对I/O设备的操作\n### I/O通道\n* 目的：建立独立的I/O操作(组织, 管理和结束)，使由CPU处理的I/O工作转由通道完成（解放CPU，实现并行）\n\n* 什么是I/O通道？\n    *  是一种特殊的处理机，具有通过执行通道程序完成I/O操作的指令\n    *  特点：指令单一(局限于与I/O操作相关的指令)，与CPU共享内存\n* 基本过程：\n    * CPU向通道发出I/O指令->通道接收指令->从内存取出通道程序处理I/O->向CPU发出中断\n* 通道类型\n    * 字节多路通道\n        * 低中速连接子通道时间片轮转方式共享主通道\n        * 字节多路通道不适于连接高速设备，这推动了按数组方式进行数据传送的数组选择通道的形成。\n    * 数组选择通道\n        * 这种通道可以连接多台高速设备，但只含有一个分配型子通道，在一段时间内只能执行一道通道程序， 控制一台设备进行数据传送， 直至该设备传送完毕释放该通道。这种通道的利用率很低。\n    * 数组多路通道\n        * 含有多个非分配型子通道，前两种通道的组合，通道利用率较好\n* 瓶颈问题\n    * 原因;通道不足\n    * 解决办法：增加设备到主机间的通路，而不增加通道（结果类似RS触发器）\n## 中断机构和中断处理程序\n### 中断\n* 分类\n    * 中断（外部触发）\n        * 对外部I/O设备发出的中断信号的响应\n    * 陷入（内部原因：除0）\n        * 由CPU内部事件引起的中断\n* 中断向量表（类比51单片机）\n    * 中断程序的入口地址表\n* 中断优先级\n    * 对紧急程度不同的中断处理方式\n* 对多中断源的处理方式\n    * 屏蔽中断\n    * 嵌套中断\n### 中断处理程序\n* 测定是否有未响应的中断信号\n* 保护被中断进程的CPU环境\n* 转入相应的设备处理程序\n* 中断处理\n* 恢复CPU 的现场并退出中断\n## 设备驱动程序\n### 是I/O进程与设备控制器之间的通信程序，又由于它常以进程的形式存在，故以后就简称为设备驱动进程\n### 主要任务是接受来自它上一层的与设备无关软件的抽象请求，并执行这个请求。\n### 功能\n* 1) 接收由I/O进程发来的命令和参数， 并将命令中的抽象要求转换为具体要求。例如，将磁盘块号转换为磁盘的盘面、 磁道号及扇区号。\n* 2) 检查用户I/O请求的合法性，了解I/O设备的状态，传递有关参数，设置设备的工作方式。 \n* 3) 发出I/O命令，如果设备空闲，便立即启动I/O设备去完成指定的I/O操作；如果设备处于忙碌状态，则将请求者的请求块挂在设备队列上等待。\n* 4) 及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。\n* 5) 对于设置有通道的计算机系统，驱动程序还应能够根据用户的I/O请求，自动地构成通道程序。 \n### 设备驱动程序的处理过程\n* 将用户和上层软件对设备控制的抽象要求转换成对设备的具体要求，如对抽象要求的盘块号转换为磁盘的盘面、磁道及扇区。\n* 检查I/O请求的合理性。\n* 读出和检查设备的状态，确保设备处于就绪态。\n* 传送必要的参数，如传送的字节数，数据在主存的首址等。\n* 工作方式的设置。\n* 启动I/O设备，并检查启动是否成功，如成功则将控制返回给I/O控制系统，在I/O设备忙于传送数据时，该用户进程把自己阻塞，直至中断到来才将它唤醒，而CPU可干别的事。\n### 对I/O设备的控制方式\n* I/O控制的宗旨\n    * 减少CPU对I/O控制的干预\n    * 充分利用CPU完成数据处理工作\n* I/O 控制方式\n    * 轮询的可编程I/O方式\n    * 中断驱动I/O方式\n    * DMA控制方式\n    * I/O通道控制方式\n### DMA控制器组成\n* 主机与DMA控制器的接口\n* DMA控制器与块设备的接口\n* I/O控制逻辑\n## 与设备无关的I/O软件\n### 基本概念\n* 含义： 应用程序独立于具体使用的物理设备。\n* 驱动程序是一个与硬件(或设备)紧密相关的软件。为实现设备独立性，须在驱动程序上设置一层软件，称为设备独立性软件。\n* 设备独立性(Device Independence)的优点\n    * 以物理设备名使用设备\n    * 引入了逻辑设备名\n    * 逻辑设备名称到物理设备名称的转换（易于实现I/O重定向）\n### 与设备无关的软件\n* 设备驱动程序的统一接口\n* 缓存管理\n* 差错控制\n* 对独立设备的分配与回收\n* 独立于设备的逻辑数据块\n### 设备分配中的数据结构\n* 设备控制表DCT\n* 控制器控制表COCT\n* 通道控制表CHCT\n* 显然，在有通道的系统中，一个进程只有获得了通道，控制器和所需设备三者之后，才具备了进行I/O操作的物理条件\n* 系统设备表SDT\n* 逻辑设备表LUT\n* 分配的流程，从资源多的到资源紧张的:LUT->SDT->DCT->COCT->CHCT\n* 在申请设备的过程中，根据用户请求的I/O设备的逻辑名，查找逻辑设备和物理设备的映射表；以物理设备为索引，查找SDT，找到该设备所连接的DCT；继续查找与该设备连接的COCT和CHCT，就找到了一条通路。\n## 用户层的I/O软件\n### 系统调用与库函数\n* OS向用户提供的所有功能，用户进程都必须通过系统调用来获取\n* 在C语言以及UNIX系统中，系统调用（如read）与各系统调用所使用的库函数（如read）之间几乎是一一对应的。而微软的叫Win32API\n### 假脱机系统（spooling）\n* spooling技术是对脱机输入/输出系统的模拟\n* 主要组成\n    * 输入/输出井\n    * 输入/输出缓冲区\n    * 输入/输出进程\n    * 井管理程序\n* 特点（体现操作系统的虚拟性）\n    * 提高了I/O的速度\n        * 对数据所进行的I/O操作，已从对低速设备演变为对输入井或输出井中的数据存取。\n    * 将独占设备改造为共享设备\n        * 实际分给用户进程的不是打印设备，而是共享输出井中的存储区域 \n    * 实现了虚拟设备功能\n        * 将独占设备变成多台独占的虚拟设备。\n## 缓冲区管理\n### 缓冲的引入（原因）\n* 缓和CPU与I/O设备间速度不匹配的矛盾\n* 减少对CPU的中断频率，放宽对CPU中断响应时间的限制\n* 提高CPU和I/O设备之间的并行性\n* 解决数据粒度不匹配的问题\n### 单缓冲区\n* 即在CPU计算的时候，将数据数据输入到缓冲区(大小取决与T和C的大小)\n### 双缓冲区\n* 即允许CPU连续工作（T不断）\n### 环形缓冲区（专为生产者和消费者打造）\n* 组成\n    * 多个缓冲区\n    * 多个指针\n* 使用\n    * Getbuf过程\n    * Releasebuf过程\n* 同步问题\n### 缓冲池(理解为更大的缓冲区)\n* 组成\n    * 空白缓冲队列（emq）\n        * 由空缓冲区链接而成F(emq)，L(emq)分别指向该队列首尾缓冲区\n    * 输入队列（inq）\n        * 由装满输入数据的缓冲区链接而成F(inq)，L(inq)分别指向该队列首尾缓冲区\n    * 输出队列（outq）\n        * 由装满输出数据的缓冲区链接而成F(outq)， L(outq)分别指向该队列首尾缓冲\n* Getbuf和Putbuf过程\n    * 收容：缓冲池接收外界数据\n    * 提取：外界从缓冲池获得数据\n* 缓冲区工作方式（从缓冲区的角度来看）\n    * 收容输入\n    * 提取输入\n    * 收容输出\n    * 提取输出\n## 磁盘存储器的性能和调度\n### 数据的组织和格式\n### 磁盘的类型\n* 固定头磁盘（贵）\n* 移动头磁盘\n### 磁盘访问的时间（关键）\n* 寻道时间Ts=m*n+s\n* 旋转延迟时间Tr\n* 传输时间Tt=b/rN\n* 总时间Ta=Ts+1/2r+b/rN\n### 磁盘的调度算法（掌握图表）\n* 先来先服务（FCFS）\n    * 优点：公平，简单\n    * 缺点：可能导致某些进程的请求长期得不到满足\n* 最短寻道时间优先（SSTF）\n    * 说明：要求访问的磁道和当前磁头所在的磁道距离最近，以使每次的寻道时间最短\n* 扫描算法（SCAN）\n    * 扫描算法不仅考虑到欲访问的磁道与当前磁道间的距离，更优先考虑的是磁道当前的移动方向\n    * 联想电梯的运行\n    * 可防止低优先级进程出现“饥饿”的现象\n* 循环扫描算法（CSCAN）\n    * 算法规定磁头单向移动，例如，只是自里向外移动，当磁头移到最外的磁道并访问后，磁头立即返回到最里的欲访问磁道，亦即将最小磁道号紧接着最大磁道号构成循环，进行循环扫描\n* NStepScan算法\n    * N步SCAN算法是将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次这些子队列。\n* FSCAN算法\n    * 是Nstepscan算法的简化，将磁盘请求队列分成两个子队列\n","slug":"2023-06-14-6-输入输出系统","published":1,"date":"2023-12-15T02:31:42.127Z","updated":"2023-12-15T02:31:42.139Z","_id":"clq60jotb00064zgsbxc66d5l","title":"","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"第六章：输入输出系统\"><a href=\"#第六章：输入输出系统\" class=\"headerlink\" title=\"第六章：输入输出系统\"></a>第六章：输入输出系统</h1><h2 id=\"I-O系统的功能，模型和接口\"><a href=\"#I-O系统的功能，模型和接口\" class=\"headerlink\" title=\"I&#x2F;O系统的功能，模型和接口\"></a>I&#x2F;O系统的功能，模型和接口</h2><h3 id=\"I-O系统管理的对象是I-O设备和相应的设备控制器。\"><a href=\"#I-O系统管理的对象是I-O设备和相应的设备控制器。\" class=\"headerlink\" title=\"I&#x2F;O系统管理的对象是I&#x2F;O设备和相应的设备控制器。\"></a>I&#x2F;O系统管理的对象是I&#x2F;O设备和相应的设备控制器。</h3><h3 id=\"I-O系统的基本功能\"><a href=\"#I-O系统的基本功能\" class=\"headerlink\" title=\"I&#x2F;O系统的基本功能\"></a>I&#x2F;O系统的基本功能</h3><ul>\n<li>隐藏物理设备的细节</li>\n<li>与设备的无关性</li>\n<li>提高处理机和I&#x2F;O设备的利用率</li>\n<li>对I&#x2F;O设备进行控制</li>\n<li>确保对设备的正确共享</li>\n<li>错误处理</li>\n</ul>\n<h3 id=\"I-O软件的层次结构\"><a href=\"#I-O软件的层次结构\" class=\"headerlink\" title=\"I&#x2F;O软件的层次结构\"></a>I&#x2F;O软件的层次结构</h3><ul>\n<li>用户层I&#x2F;O软件</li>\n<li>设备独立性软件</li>\n<li>设备驱动程序（厂家开发）</li>\n<li>中断处理程序</li>\n<li>硬件</li>\n</ul>\n<h3 id=\"I-O系统的分层\"><a href=\"#I-O系统的分层\" class=\"headerlink\" title=\"I&#x2F;O系统的分层\"></a>I&#x2F;O系统的分层</h3><ul>\n<li>中断处理程序</li>\n<li>设备驱动程序</li>\n<li>设备独立性软件</li>\n</ul>\n<h3 id=\"I-O系统接口\"><a href=\"#I-O系统接口\" class=\"headerlink\" title=\"I&#x2F;O系统接口\"></a>I&#x2F;O系统接口</h3><ul>\n<li>块设备接口<ul>\n<li>指以数据块为单位来组织和传送数据信息的设备</li>\n<li>典型的块设备是磁盘、光盘</li>\n<li>块设备的基本特征<ul>\n<li>①传输速率较高，通常每秒钟为几兆位；</li>\n<li>②它是可寻址的，即可随机地读&#x2F;写任意一块；</li>\n<li>③磁盘设备的I&#x2F;O采用DMA方式。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>流设备接口<ul>\n<li>又称字符设备指以单个字符为单位来传送数据信息的设备</li>\n<li>这类设备一般用于数据的输入和输出，有交互式终端、打印机</li>\n<li>字符设备的基本特征<ul>\n<li>①传输速率较低；</li>\n<li>②不可寻址，即不能指定输入时的源地址或输出时的目标地址；</li>\n<li>③字符设备的I&#x2F;O常采用中断驱动方式。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>网络通信接口<ul>\n<li>提供网络接入功能，使计算机能通过网络与其他计算机进行通信或上网浏览。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"I-O设备和设备控制器\"><a href=\"#I-O设备和设备控制器\" class=\"headerlink\" title=\"I&#x2F;O设备和设备控制器\"></a>I&#x2F;O设备和设备控制器</h2><h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><ul>\n<li>使用特性分<ul>\n<li>存储设备</li>\n<li>I&#x2F;O设备</li>\n</ul>\n</li>\n<li>传输速率分<ul>\n<li>低速设备（几字节——几百字节）<ul>\n<li>典型的设备有键盘、鼠标、语音的输入</li>\n</ul>\n</li>\n<li>中速设备（数千——数万字节）<ul>\n<li>典型的设备有行式打印机、激光打印机</li>\n</ul>\n</li>\n<li>高速设备（数十万——千兆字节）<ul>\n<li>典型的设备有磁带机、磁盘机、光盘机</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"设备并不是直接与CPU进行通信，而是与设备控制器通信。在设备与设备控制器之间应该有一个接口。\"><a href=\"#设备并不是直接与CPU进行通信，而是与设备控制器通信。在设备与设备控制器之间应该有一个接口。\" class=\"headerlink\" title=\"设备并不是直接与CPU进行通信，而是与设备控制器通信。在设备与设备控制器之间应该有一个接口。\"></a>设备并不是直接与CPU进行通信，而是与设备控制器通信。在设备与设备控制器之间应该有一个接口。</h3><ul>\n<li>数据信号：控制器 ←  设备 ←  控制器<ul>\n<li>传送数据信号，输入、输出bit</li>\n</ul>\n</li>\n<li>控制信号: 控制器  →  设备<ul>\n<li>执行读、写操作的信号</li>\n</ul>\n</li>\n<li>状态信号：设备当前使用状态</li>\n</ul>\n<h3 id=\"设备控制器\"><a href=\"#设备控制器\" class=\"headerlink\" title=\"设备控制器\"></a>设备控制器</h3><ul>\n<li>主要功能：控制一个或多个I&#x2F;O设备，以实现I&#x2F;O设备和计算机之间的数据交换</li>\n<li>基本功能<ul>\n<li>接收和识别命令<ul>\n<li>控制寄存器、命令译码器</li>\n</ul>\n</li>\n<li>数据交换<ul>\n<li>实现CPU与控制器，控制器与设备间的数据交换</li>\n</ul>\n</li>\n<li>标识和报告设备的状态</li>\n<li>地址识别<ul>\n<li>配置地址译码器，识别不同的设备</li>\n</ul>\n</li>\n<li>数据缓冲区</li>\n<li>差错控制</li>\n</ul>\n</li>\n<li>设备控制器的组成<ul>\n<li>设备控制器与处理机（CPU）的接口<ul>\n<li>实现CPU与设备控制器之间的通信</li>\n</ul>\n</li>\n<li>设备控制器与设备的接口<ul>\n<li>控制器可连接多个设备</li>\n</ul>\n</li>\n<li>I&#x2F;O逻辑<ul>\n<li>实现对设备的控制</li>\n<li>CPU利用该逻辑向控制器发送I&#x2F;O命令</li>\n<li>命令、地址译码</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"内存映像I-O\"><a href=\"#内存映像I-O\" class=\"headerlink\" title=\"内存映像I&#x2F;O\"></a>内存映像I&#x2F;O</h3><ul>\n<li>驱动程序将抽象I&#x2F;O命令转换出的一系列具体的命令，参数等数据装入设备控制器的相应寄存器，由控制器来执行这些命令，具体实施对I&#x2F;O设备的操作</li>\n</ul>\n<h3 id=\"I-O通道\"><a href=\"#I-O通道\" class=\"headerlink\" title=\"I&#x2F;O通道\"></a>I&#x2F;O通道</h3><ul>\n<li><p>目的：建立独立的I&#x2F;O操作(组织, 管理和结束)，使由CPU处理的I&#x2F;O工作转由通道完成（解放CPU，实现并行）</p>\n</li>\n<li><p>什么是I&#x2F;O通道？</p>\n<ul>\n<li>是一种特殊的处理机，具有通过执行通道程序完成I&#x2F;O操作的指令</li>\n<li>特点：指令单一(局限于与I&#x2F;O操作相关的指令)，与CPU共享内存</li>\n</ul>\n</li>\n<li><p>基本过程：</p>\n<ul>\n<li>CPU向通道发出I&#x2F;O指令-&gt;通道接收指令-&gt;从内存取出通道程序处理I&#x2F;O-&gt;向CPU发出中断</li>\n</ul>\n</li>\n<li><p>通道类型</p>\n<ul>\n<li>字节多路通道<ul>\n<li>低中速连接子通道时间片轮转方式共享主通道</li>\n<li>字节多路通道不适于连接高速设备，这推动了按数组方式进行数据传送的数组选择通道的形成。</li>\n</ul>\n</li>\n<li>数组选择通道<ul>\n<li>这种通道可以连接多台高速设备，但只含有一个分配型子通道，在一段时间内只能执行一道通道程序， 控制一台设备进行数据传送， 直至该设备传送完毕释放该通道。这种通道的利用率很低。</li>\n</ul>\n</li>\n<li>数组多路通道<ul>\n<li>含有多个非分配型子通道，前两种通道的组合，通道利用率较好</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>瓶颈问题</p>\n<ul>\n<li>原因;通道不足</li>\n<li>解决办法：增加设备到主机间的通路，而不增加通道（结果类似RS触发器）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"中断机构和中断处理程序\"><a href=\"#中断机构和中断处理程序\" class=\"headerlink\" title=\"中断机构和中断处理程序\"></a>中断机构和中断处理程序</h2><h3 id=\"中断\"><a href=\"#中断\" class=\"headerlink\" title=\"中断\"></a>中断</h3><ul>\n<li>分类<ul>\n<li>中断（外部触发）<ul>\n<li>对外部I&#x2F;O设备发出的中断信号的响应</li>\n</ul>\n</li>\n<li>陷入（内部原因：除0）<ul>\n<li>由CPU内部事件引起的中断</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>中断向量表（类比51单片机）<ul>\n<li>中断程序的入口地址表</li>\n</ul>\n</li>\n<li>中断优先级<ul>\n<li>对紧急程度不同的中断处理方式</li>\n</ul>\n</li>\n<li>对多中断源的处理方式<ul>\n<li>屏蔽中断</li>\n<li>嵌套中断</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"中断处理程序\"><a href=\"#中断处理程序\" class=\"headerlink\" title=\"中断处理程序\"></a>中断处理程序</h3><ul>\n<li>测定是否有未响应的中断信号</li>\n<li>保护被中断进程的CPU环境</li>\n<li>转入相应的设备处理程序</li>\n<li>中断处理</li>\n<li>恢复CPU 的现场并退出中断</li>\n</ul>\n<h2 id=\"设备驱动程序\"><a href=\"#设备驱动程序\" class=\"headerlink\" title=\"设备驱动程序\"></a>设备驱动程序</h2><h3 id=\"是I-O进程与设备控制器之间的通信程序，又由于它常以进程的形式存在，故以后就简称为设备驱动进程\"><a href=\"#是I-O进程与设备控制器之间的通信程序，又由于它常以进程的形式存在，故以后就简称为设备驱动进程\" class=\"headerlink\" title=\"是I&#x2F;O进程与设备控制器之间的通信程序，又由于它常以进程的形式存在，故以后就简称为设备驱动进程\"></a>是I&#x2F;O进程与设备控制器之间的通信程序，又由于它常以进程的形式存在，故以后就简称为设备驱动进程</h3><h3 id=\"主要任务是接受来自它上一层的与设备无关软件的抽象请求，并执行这个请求。\"><a href=\"#主要任务是接受来自它上一层的与设备无关软件的抽象请求，并执行这个请求。\" class=\"headerlink\" title=\"主要任务是接受来自它上一层的与设备无关软件的抽象请求，并执行这个请求。\"></a>主要任务是接受来自它上一层的与设备无关软件的抽象请求，并执行这个请求。</h3><h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><ul>\n<li><ol>\n<li>接收由I&#x2F;O进程发来的命令和参数， 并将命令中的抽象要求转换为具体要求。例如，将磁盘块号转换为磁盘的盘面、 磁道号及扇区号。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>检查用户I&#x2F;O请求的合法性，了解I&#x2F;O设备的状态，传递有关参数，设置设备的工作方式。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>发出I&#x2F;O命令，如果设备空闲，便立即启动I&#x2F;O设备去完成指定的I&#x2F;O操作；如果设备处于忙碌状态，则将请求者的请求块挂在设备队列上等待。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>对于设置有通道的计算机系统，驱动程序还应能够根据用户的I&#x2F;O请求，自动地构成通道程序。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"设备驱动程序的处理过程\"><a href=\"#设备驱动程序的处理过程\" class=\"headerlink\" title=\"设备驱动程序的处理过程\"></a>设备驱动程序的处理过程</h3><ul>\n<li>将用户和上层软件对设备控制的抽象要求转换成对设备的具体要求，如对抽象要求的盘块号转换为磁盘的盘面、磁道及扇区。</li>\n<li>检查I&#x2F;O请求的合理性。</li>\n<li>读出和检查设备的状态，确保设备处于就绪态。</li>\n<li>传送必要的参数，如传送的字节数，数据在主存的首址等。</li>\n<li>工作方式的设置。</li>\n<li>启动I&#x2F;O设备，并检查启动是否成功，如成功则将控制返回给I&#x2F;O控制系统，在I&#x2F;O设备忙于传送数据时，该用户进程把自己阻塞，直至中断到来才将它唤醒，而CPU可干别的事。</li>\n</ul>\n<h3 id=\"对I-O设备的控制方式\"><a href=\"#对I-O设备的控制方式\" class=\"headerlink\" title=\"对I&#x2F;O设备的控制方式\"></a>对I&#x2F;O设备的控制方式</h3><ul>\n<li>I&#x2F;O控制的宗旨<ul>\n<li>减少CPU对I&#x2F;O控制的干预</li>\n<li>充分利用CPU完成数据处理工作</li>\n</ul>\n</li>\n<li>I&#x2F;O 控制方式<ul>\n<li>轮询的可编程I&#x2F;O方式</li>\n<li>中断驱动I&#x2F;O方式</li>\n<li>DMA控制方式</li>\n<li>I&#x2F;O通道控制方式</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"DMA控制器组成\"><a href=\"#DMA控制器组成\" class=\"headerlink\" title=\"DMA控制器组成\"></a>DMA控制器组成</h3><ul>\n<li>主机与DMA控制器的接口</li>\n<li>DMA控制器与块设备的接口</li>\n<li>I&#x2F;O控制逻辑</li>\n</ul>\n<h2 id=\"与设备无关的I-O软件\"><a href=\"#与设备无关的I-O软件\" class=\"headerlink\" title=\"与设备无关的I&#x2F;O软件\"></a>与设备无关的I&#x2F;O软件</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li>含义： 应用程序独立于具体使用的物理设备。</li>\n<li>驱动程序是一个与硬件(或设备)紧密相关的软件。为实现设备独立性，须在驱动程序上设置一层软件，称为设备独立性软件。</li>\n<li>设备独立性(Device Independence)的优点<ul>\n<li>以物理设备名使用设备</li>\n<li>引入了逻辑设备名</li>\n<li>逻辑设备名称到物理设备名称的转换（易于实现I&#x2F;O重定向）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"与设备无关的软件\"><a href=\"#与设备无关的软件\" class=\"headerlink\" title=\"与设备无关的软件\"></a>与设备无关的软件</h3><ul>\n<li>设备驱动程序的统一接口</li>\n<li>缓存管理</li>\n<li>差错控制</li>\n<li>对独立设备的分配与回收</li>\n<li>独立于设备的逻辑数据块</li>\n</ul>\n<h3 id=\"设备分配中的数据结构\"><a href=\"#设备分配中的数据结构\" class=\"headerlink\" title=\"设备分配中的数据结构\"></a>设备分配中的数据结构</h3><ul>\n<li>设备控制表DCT</li>\n<li>控制器控制表COCT</li>\n<li>通道控制表CHCT</li>\n<li>显然，在有通道的系统中，一个进程只有获得了通道，控制器和所需设备三者之后，才具备了进行I&#x2F;O操作的物理条件</li>\n<li>系统设备表SDT</li>\n<li>逻辑设备表LUT</li>\n<li>分配的流程，从资源多的到资源紧张的:LUT-&gt;SDT-&gt;DCT-&gt;COCT-&gt;CHCT</li>\n<li>在申请设备的过程中，根据用户请求的I&#x2F;O设备的逻辑名，查找逻辑设备和物理设备的映射表；以物理设备为索引，查找SDT，找到该设备所连接的DCT；继续查找与该设备连接的COCT和CHCT，就找到了一条通路。</li>\n</ul>\n<h2 id=\"用户层的I-O软件\"><a href=\"#用户层的I-O软件\" class=\"headerlink\" title=\"用户层的I&#x2F;O软件\"></a>用户层的I&#x2F;O软件</h2><h3 id=\"系统调用与库函数\"><a href=\"#系统调用与库函数\" class=\"headerlink\" title=\"系统调用与库函数\"></a>系统调用与库函数</h3><ul>\n<li>OS向用户提供的所有功能，用户进程都必须通过系统调用来获取</li>\n<li>在C语言以及UNIX系统中，系统调用（如read）与各系统调用所使用的库函数（如read）之间几乎是一一对应的。而微软的叫Win32API</li>\n</ul>\n<h3 id=\"假脱机系统（spooling）\"><a href=\"#假脱机系统（spooling）\" class=\"headerlink\" title=\"假脱机系统（spooling）\"></a>假脱机系统（spooling）</h3><ul>\n<li>spooling技术是对脱机输入&#x2F;输出系统的模拟</li>\n<li>主要组成<ul>\n<li>输入&#x2F;输出井</li>\n<li>输入&#x2F;输出缓冲区</li>\n<li>输入&#x2F;输出进程</li>\n<li>井管理程序</li>\n</ul>\n</li>\n<li>特点（体现操作系统的虚拟性）<ul>\n<li>提高了I&#x2F;O的速度<ul>\n<li>对数据所进行的I&#x2F;O操作，已从对低速设备演变为对输入井或输出井中的数据存取。</li>\n</ul>\n</li>\n<li>将独占设备改造为共享设备<ul>\n<li>实际分给用户进程的不是打印设备，而是共享输出井中的存储区域</li>\n</ul>\n</li>\n<li>实现了虚拟设备功能<ul>\n<li>将独占设备变成多台独占的虚拟设备。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"缓冲区管理\"><a href=\"#缓冲区管理\" class=\"headerlink\" title=\"缓冲区管理\"></a>缓冲区管理</h2><h3 id=\"缓冲的引入（原因）\"><a href=\"#缓冲的引入（原因）\" class=\"headerlink\" title=\"缓冲的引入（原因）\"></a>缓冲的引入（原因）</h3><ul>\n<li>缓和CPU与I&#x2F;O设备间速度不匹配的矛盾</li>\n<li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</li>\n<li>提高CPU和I&#x2F;O设备之间的并行性</li>\n<li>解决数据粒度不匹配的问题</li>\n</ul>\n<h3 id=\"单缓冲区\"><a href=\"#单缓冲区\" class=\"headerlink\" title=\"单缓冲区\"></a>单缓冲区</h3><ul>\n<li>即在CPU计算的时候，将数据数据输入到缓冲区(大小取决与T和C的大小)</li>\n</ul>\n<h3 id=\"双缓冲区\"><a href=\"#双缓冲区\" class=\"headerlink\" title=\"双缓冲区\"></a>双缓冲区</h3><ul>\n<li>即允许CPU连续工作（T不断）</li>\n</ul>\n<h3 id=\"环形缓冲区（专为生产者和消费者打造）\"><a href=\"#环形缓冲区（专为生产者和消费者打造）\" class=\"headerlink\" title=\"环形缓冲区（专为生产者和消费者打造）\"></a>环形缓冲区（专为生产者和消费者打造）</h3><ul>\n<li>组成<ul>\n<li>多个缓冲区</li>\n<li>多个指针</li>\n</ul>\n</li>\n<li>使用<ul>\n<li>Getbuf过程</li>\n<li>Releasebuf过程</li>\n</ul>\n</li>\n<li>同步问题</li>\n</ul>\n<h3 id=\"缓冲池-理解为更大的缓冲区\"><a href=\"#缓冲池-理解为更大的缓冲区\" class=\"headerlink\" title=\"缓冲池(理解为更大的缓冲区)\"></a>缓冲池(理解为更大的缓冲区)</h3><ul>\n<li>组成<ul>\n<li>空白缓冲队列（emq）<ul>\n<li>由空缓冲区链接而成F(emq)，L(emq)分别指向该队列首尾缓冲区</li>\n</ul>\n</li>\n<li>输入队列（inq）<ul>\n<li>由装满输入数据的缓冲区链接而成F(inq)，L(inq)分别指向该队列首尾缓冲区</li>\n</ul>\n</li>\n<li>输出队列（outq）<ul>\n<li>由装满输出数据的缓冲区链接而成F(outq)， L(outq)分别指向该队列首尾缓冲</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Getbuf和Putbuf过程<ul>\n<li>收容：缓冲池接收外界数据</li>\n<li>提取：外界从缓冲池获得数据</li>\n</ul>\n</li>\n<li>缓冲区工作方式（从缓冲区的角度来看）<ul>\n<li>收容输入</li>\n<li>提取输入</li>\n<li>收容输出</li>\n<li>提取输出</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"磁盘存储器的性能和调度\"><a href=\"#磁盘存储器的性能和调度\" class=\"headerlink\" title=\"磁盘存储器的性能和调度\"></a>磁盘存储器的性能和调度</h2><h3 id=\"数据的组织和格式\"><a href=\"#数据的组织和格式\" class=\"headerlink\" title=\"数据的组织和格式\"></a>数据的组织和格式</h3><h3 id=\"磁盘的类型\"><a href=\"#磁盘的类型\" class=\"headerlink\" title=\"磁盘的类型\"></a>磁盘的类型</h3><ul>\n<li>固定头磁盘（贵）</li>\n<li>移动头磁盘</li>\n</ul>\n<h3 id=\"磁盘访问的时间（关键）\"><a href=\"#磁盘访问的时间（关键）\" class=\"headerlink\" title=\"磁盘访问的时间（关键）\"></a>磁盘访问的时间（关键）</h3><ul>\n<li>寻道时间Ts&#x3D;m*n+s</li>\n<li>旋转延迟时间Tr</li>\n<li>传输时间Tt&#x3D;b&#x2F;rN</li>\n<li>总时间Ta&#x3D;Ts+1&#x2F;2r+b&#x2F;rN</li>\n</ul>\n<h3 id=\"磁盘的调度算法（掌握图表）\"><a href=\"#磁盘的调度算法（掌握图表）\" class=\"headerlink\" title=\"磁盘的调度算法（掌握图表）\"></a>磁盘的调度算法（掌握图表）</h3><ul>\n<li>先来先服务（FCFS）<ul>\n<li>优点：公平，简单</li>\n<li>缺点：可能导致某些进程的请求长期得不到满足</li>\n</ul>\n</li>\n<li>最短寻道时间优先（SSTF）<ul>\n<li>说明：要求访问的磁道和当前磁头所在的磁道距离最近，以使每次的寻道时间最短</li>\n</ul>\n</li>\n<li>扫描算法（SCAN）<ul>\n<li>扫描算法不仅考虑到欲访问的磁道与当前磁道间的距离，更优先考虑的是磁道当前的移动方向</li>\n<li>联想电梯的运行</li>\n<li>可防止低优先级进程出现“饥饿”的现象</li>\n</ul>\n</li>\n<li>循环扫描算法（CSCAN）<ul>\n<li>算法规定磁头单向移动，例如，只是自里向外移动，当磁头移到最外的磁道并访问后，磁头立即返回到最里的欲访问磁道，亦即将最小磁道号紧接着最大磁道号构成循环，进行循环扫描</li>\n</ul>\n</li>\n<li>NStepScan算法<ul>\n<li>N步SCAN算法是将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次这些子队列。</li>\n</ul>\n</li>\n<li>FSCAN算法<ul>\n<li>是Nstepscan算法的简化，将磁盘请求队列分成两个子队列</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"第六章：输入输出系统\"><a href=\"#第六章：输入输出系统\" class=\"headerlink\" title=\"第六章：输入输出系统\"></a>第六章：输入输出系统</h1><h2 id=\"I-O系统的功能，模型和接口\"><a href=\"#I-O系统的功能，模型和接口\" class=\"headerlink\" title=\"I&#x2F;O系统的功能，模型和接口\"></a>I&#x2F;O系统的功能，模型和接口</h2><h3 id=\"I-O系统管理的对象是I-O设备和相应的设备控制器。\"><a href=\"#I-O系统管理的对象是I-O设备和相应的设备控制器。\" class=\"headerlink\" title=\"I&#x2F;O系统管理的对象是I&#x2F;O设备和相应的设备控制器。\"></a>I&#x2F;O系统管理的对象是I&#x2F;O设备和相应的设备控制器。</h3><h3 id=\"I-O系统的基本功能\"><a href=\"#I-O系统的基本功能\" class=\"headerlink\" title=\"I&#x2F;O系统的基本功能\"></a>I&#x2F;O系统的基本功能</h3><ul>\n<li>隐藏物理设备的细节</li>\n<li>与设备的无关性</li>\n<li>提高处理机和I&#x2F;O设备的利用率</li>\n<li>对I&#x2F;O设备进行控制</li>\n<li>确保对设备的正确共享</li>\n<li>错误处理</li>\n</ul>\n<h3 id=\"I-O软件的层次结构\"><a href=\"#I-O软件的层次结构\" class=\"headerlink\" title=\"I&#x2F;O软件的层次结构\"></a>I&#x2F;O软件的层次结构</h3><ul>\n<li>用户层I&#x2F;O软件</li>\n<li>设备独立性软件</li>\n<li>设备驱动程序（厂家开发）</li>\n<li>中断处理程序</li>\n<li>硬件</li>\n</ul>\n<h3 id=\"I-O系统的分层\"><a href=\"#I-O系统的分层\" class=\"headerlink\" title=\"I&#x2F;O系统的分层\"></a>I&#x2F;O系统的分层</h3><ul>\n<li>中断处理程序</li>\n<li>设备驱动程序</li>\n<li>设备独立性软件</li>\n</ul>\n<h3 id=\"I-O系统接口\"><a href=\"#I-O系统接口\" class=\"headerlink\" title=\"I&#x2F;O系统接口\"></a>I&#x2F;O系统接口</h3><ul>\n<li>块设备接口<ul>\n<li>指以数据块为单位来组织和传送数据信息的设备</li>\n<li>典型的块设备是磁盘、光盘</li>\n<li>块设备的基本特征<ul>\n<li>①传输速率较高，通常每秒钟为几兆位；</li>\n<li>②它是可寻址的，即可随机地读&#x2F;写任意一块；</li>\n<li>③磁盘设备的I&#x2F;O采用DMA方式。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>流设备接口<ul>\n<li>又称字符设备指以单个字符为单位来传送数据信息的设备</li>\n<li>这类设备一般用于数据的输入和输出，有交互式终端、打印机</li>\n<li>字符设备的基本特征<ul>\n<li>①传输速率较低；</li>\n<li>②不可寻址，即不能指定输入时的源地址或输出时的目标地址；</li>\n<li>③字符设备的I&#x2F;O常采用中断驱动方式。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>网络通信接口<ul>\n<li>提供网络接入功能，使计算机能通过网络与其他计算机进行通信或上网浏览。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"I-O设备和设备控制器\"><a href=\"#I-O设备和设备控制器\" class=\"headerlink\" title=\"I&#x2F;O设备和设备控制器\"></a>I&#x2F;O设备和设备控制器</h2><h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><ul>\n<li>使用特性分<ul>\n<li>存储设备</li>\n<li>I&#x2F;O设备</li>\n</ul>\n</li>\n<li>传输速率分<ul>\n<li>低速设备（几字节——几百字节）<ul>\n<li>典型的设备有键盘、鼠标、语音的输入</li>\n</ul>\n</li>\n<li>中速设备（数千——数万字节）<ul>\n<li>典型的设备有行式打印机、激光打印机</li>\n</ul>\n</li>\n<li>高速设备（数十万——千兆字节）<ul>\n<li>典型的设备有磁带机、磁盘机、光盘机</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"设备并不是直接与CPU进行通信，而是与设备控制器通信。在设备与设备控制器之间应该有一个接口。\"><a href=\"#设备并不是直接与CPU进行通信，而是与设备控制器通信。在设备与设备控制器之间应该有一个接口。\" class=\"headerlink\" title=\"设备并不是直接与CPU进行通信，而是与设备控制器通信。在设备与设备控制器之间应该有一个接口。\"></a>设备并不是直接与CPU进行通信，而是与设备控制器通信。在设备与设备控制器之间应该有一个接口。</h3><ul>\n<li>数据信号：控制器 ←  设备 ←  控制器<ul>\n<li>传送数据信号，输入、输出bit</li>\n</ul>\n</li>\n<li>控制信号: 控制器  →  设备<ul>\n<li>执行读、写操作的信号</li>\n</ul>\n</li>\n<li>状态信号：设备当前使用状态</li>\n</ul>\n<h3 id=\"设备控制器\"><a href=\"#设备控制器\" class=\"headerlink\" title=\"设备控制器\"></a>设备控制器</h3><ul>\n<li>主要功能：控制一个或多个I&#x2F;O设备，以实现I&#x2F;O设备和计算机之间的数据交换</li>\n<li>基本功能<ul>\n<li>接收和识别命令<ul>\n<li>控制寄存器、命令译码器</li>\n</ul>\n</li>\n<li>数据交换<ul>\n<li>实现CPU与控制器，控制器与设备间的数据交换</li>\n</ul>\n</li>\n<li>标识和报告设备的状态</li>\n<li>地址识别<ul>\n<li>配置地址译码器，识别不同的设备</li>\n</ul>\n</li>\n<li>数据缓冲区</li>\n<li>差错控制</li>\n</ul>\n</li>\n<li>设备控制器的组成<ul>\n<li>设备控制器与处理机（CPU）的接口<ul>\n<li>实现CPU与设备控制器之间的通信</li>\n</ul>\n</li>\n<li>设备控制器与设备的接口<ul>\n<li>控制器可连接多个设备</li>\n</ul>\n</li>\n<li>I&#x2F;O逻辑<ul>\n<li>实现对设备的控制</li>\n<li>CPU利用该逻辑向控制器发送I&#x2F;O命令</li>\n<li>命令、地址译码</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"内存映像I-O\"><a href=\"#内存映像I-O\" class=\"headerlink\" title=\"内存映像I&#x2F;O\"></a>内存映像I&#x2F;O</h3><ul>\n<li>驱动程序将抽象I&#x2F;O命令转换出的一系列具体的命令，参数等数据装入设备控制器的相应寄存器，由控制器来执行这些命令，具体实施对I&#x2F;O设备的操作</li>\n</ul>\n<h3 id=\"I-O通道\"><a href=\"#I-O通道\" class=\"headerlink\" title=\"I&#x2F;O通道\"></a>I&#x2F;O通道</h3><ul>\n<li><p>目的：建立独立的I&#x2F;O操作(组织, 管理和结束)，使由CPU处理的I&#x2F;O工作转由通道完成（解放CPU，实现并行）</p>\n</li>\n<li><p>什么是I&#x2F;O通道？</p>\n<ul>\n<li>是一种特殊的处理机，具有通过执行通道程序完成I&#x2F;O操作的指令</li>\n<li>特点：指令单一(局限于与I&#x2F;O操作相关的指令)，与CPU共享内存</li>\n</ul>\n</li>\n<li><p>基本过程：</p>\n<ul>\n<li>CPU向通道发出I&#x2F;O指令-&gt;通道接收指令-&gt;从内存取出通道程序处理I&#x2F;O-&gt;向CPU发出中断</li>\n</ul>\n</li>\n<li><p>通道类型</p>\n<ul>\n<li>字节多路通道<ul>\n<li>低中速连接子通道时间片轮转方式共享主通道</li>\n<li>字节多路通道不适于连接高速设备，这推动了按数组方式进行数据传送的数组选择通道的形成。</li>\n</ul>\n</li>\n<li>数组选择通道<ul>\n<li>这种通道可以连接多台高速设备，但只含有一个分配型子通道，在一段时间内只能执行一道通道程序， 控制一台设备进行数据传送， 直至该设备传送完毕释放该通道。这种通道的利用率很低。</li>\n</ul>\n</li>\n<li>数组多路通道<ul>\n<li>含有多个非分配型子通道，前两种通道的组合，通道利用率较好</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>瓶颈问题</p>\n<ul>\n<li>原因;通道不足</li>\n<li>解决办法：增加设备到主机间的通路，而不增加通道（结果类似RS触发器）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"中断机构和中断处理程序\"><a href=\"#中断机构和中断处理程序\" class=\"headerlink\" title=\"中断机构和中断处理程序\"></a>中断机构和中断处理程序</h2><h3 id=\"中断\"><a href=\"#中断\" class=\"headerlink\" title=\"中断\"></a>中断</h3><ul>\n<li>分类<ul>\n<li>中断（外部触发）<ul>\n<li>对外部I&#x2F;O设备发出的中断信号的响应</li>\n</ul>\n</li>\n<li>陷入（内部原因：除0）<ul>\n<li>由CPU内部事件引起的中断</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>中断向量表（类比51单片机）<ul>\n<li>中断程序的入口地址表</li>\n</ul>\n</li>\n<li>中断优先级<ul>\n<li>对紧急程度不同的中断处理方式</li>\n</ul>\n</li>\n<li>对多中断源的处理方式<ul>\n<li>屏蔽中断</li>\n<li>嵌套中断</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"中断处理程序\"><a href=\"#中断处理程序\" class=\"headerlink\" title=\"中断处理程序\"></a>中断处理程序</h3><ul>\n<li>测定是否有未响应的中断信号</li>\n<li>保护被中断进程的CPU环境</li>\n<li>转入相应的设备处理程序</li>\n<li>中断处理</li>\n<li>恢复CPU 的现场并退出中断</li>\n</ul>\n<h2 id=\"设备驱动程序\"><a href=\"#设备驱动程序\" class=\"headerlink\" title=\"设备驱动程序\"></a>设备驱动程序</h2><h3 id=\"是I-O进程与设备控制器之间的通信程序，又由于它常以进程的形式存在，故以后就简称为设备驱动进程\"><a href=\"#是I-O进程与设备控制器之间的通信程序，又由于它常以进程的形式存在，故以后就简称为设备驱动进程\" class=\"headerlink\" title=\"是I&#x2F;O进程与设备控制器之间的通信程序，又由于它常以进程的形式存在，故以后就简称为设备驱动进程\"></a>是I&#x2F;O进程与设备控制器之间的通信程序，又由于它常以进程的形式存在，故以后就简称为设备驱动进程</h3><h3 id=\"主要任务是接受来自它上一层的与设备无关软件的抽象请求，并执行这个请求。\"><a href=\"#主要任务是接受来自它上一层的与设备无关软件的抽象请求，并执行这个请求。\" class=\"headerlink\" title=\"主要任务是接受来自它上一层的与设备无关软件的抽象请求，并执行这个请求。\"></a>主要任务是接受来自它上一层的与设备无关软件的抽象请求，并执行这个请求。</h3><h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><ul>\n<li><ol>\n<li>接收由I&#x2F;O进程发来的命令和参数， 并将命令中的抽象要求转换为具体要求。例如，将磁盘块号转换为磁盘的盘面、 磁道号及扇区号。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>检查用户I&#x2F;O请求的合法性，了解I&#x2F;O设备的状态，传递有关参数，设置设备的工作方式。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>发出I&#x2F;O命令，如果设备空闲，便立即启动I&#x2F;O设备去完成指定的I&#x2F;O操作；如果设备处于忙碌状态，则将请求者的请求块挂在设备队列上等待。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>对于设置有通道的计算机系统，驱动程序还应能够根据用户的I&#x2F;O请求，自动地构成通道程序。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"设备驱动程序的处理过程\"><a href=\"#设备驱动程序的处理过程\" class=\"headerlink\" title=\"设备驱动程序的处理过程\"></a>设备驱动程序的处理过程</h3><ul>\n<li>将用户和上层软件对设备控制的抽象要求转换成对设备的具体要求，如对抽象要求的盘块号转换为磁盘的盘面、磁道及扇区。</li>\n<li>检查I&#x2F;O请求的合理性。</li>\n<li>读出和检查设备的状态，确保设备处于就绪态。</li>\n<li>传送必要的参数，如传送的字节数，数据在主存的首址等。</li>\n<li>工作方式的设置。</li>\n<li>启动I&#x2F;O设备，并检查启动是否成功，如成功则将控制返回给I&#x2F;O控制系统，在I&#x2F;O设备忙于传送数据时，该用户进程把自己阻塞，直至中断到来才将它唤醒，而CPU可干别的事。</li>\n</ul>\n<h3 id=\"对I-O设备的控制方式\"><a href=\"#对I-O设备的控制方式\" class=\"headerlink\" title=\"对I&#x2F;O设备的控制方式\"></a>对I&#x2F;O设备的控制方式</h3><ul>\n<li>I&#x2F;O控制的宗旨<ul>\n<li>减少CPU对I&#x2F;O控制的干预</li>\n<li>充分利用CPU完成数据处理工作</li>\n</ul>\n</li>\n<li>I&#x2F;O 控制方式<ul>\n<li>轮询的可编程I&#x2F;O方式</li>\n<li>中断驱动I&#x2F;O方式</li>\n<li>DMA控制方式</li>\n<li>I&#x2F;O通道控制方式</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"DMA控制器组成\"><a href=\"#DMA控制器组成\" class=\"headerlink\" title=\"DMA控制器组成\"></a>DMA控制器组成</h3><ul>\n<li>主机与DMA控制器的接口</li>\n<li>DMA控制器与块设备的接口</li>\n<li>I&#x2F;O控制逻辑</li>\n</ul>\n<h2 id=\"与设备无关的I-O软件\"><a href=\"#与设备无关的I-O软件\" class=\"headerlink\" title=\"与设备无关的I&#x2F;O软件\"></a>与设备无关的I&#x2F;O软件</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li>含义： 应用程序独立于具体使用的物理设备。</li>\n<li>驱动程序是一个与硬件(或设备)紧密相关的软件。为实现设备独立性，须在驱动程序上设置一层软件，称为设备独立性软件。</li>\n<li>设备独立性(Device Independence)的优点<ul>\n<li>以物理设备名使用设备</li>\n<li>引入了逻辑设备名</li>\n<li>逻辑设备名称到物理设备名称的转换（易于实现I&#x2F;O重定向）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"与设备无关的软件\"><a href=\"#与设备无关的软件\" class=\"headerlink\" title=\"与设备无关的软件\"></a>与设备无关的软件</h3><ul>\n<li>设备驱动程序的统一接口</li>\n<li>缓存管理</li>\n<li>差错控制</li>\n<li>对独立设备的分配与回收</li>\n<li>独立于设备的逻辑数据块</li>\n</ul>\n<h3 id=\"设备分配中的数据结构\"><a href=\"#设备分配中的数据结构\" class=\"headerlink\" title=\"设备分配中的数据结构\"></a>设备分配中的数据结构</h3><ul>\n<li>设备控制表DCT</li>\n<li>控制器控制表COCT</li>\n<li>通道控制表CHCT</li>\n<li>显然，在有通道的系统中，一个进程只有获得了通道，控制器和所需设备三者之后，才具备了进行I&#x2F;O操作的物理条件</li>\n<li>系统设备表SDT</li>\n<li>逻辑设备表LUT</li>\n<li>分配的流程，从资源多的到资源紧张的:LUT-&gt;SDT-&gt;DCT-&gt;COCT-&gt;CHCT</li>\n<li>在申请设备的过程中，根据用户请求的I&#x2F;O设备的逻辑名，查找逻辑设备和物理设备的映射表；以物理设备为索引，查找SDT，找到该设备所连接的DCT；继续查找与该设备连接的COCT和CHCT，就找到了一条通路。</li>\n</ul>\n<h2 id=\"用户层的I-O软件\"><a href=\"#用户层的I-O软件\" class=\"headerlink\" title=\"用户层的I&#x2F;O软件\"></a>用户层的I&#x2F;O软件</h2><h3 id=\"系统调用与库函数\"><a href=\"#系统调用与库函数\" class=\"headerlink\" title=\"系统调用与库函数\"></a>系统调用与库函数</h3><ul>\n<li>OS向用户提供的所有功能，用户进程都必须通过系统调用来获取</li>\n<li>在C语言以及UNIX系统中，系统调用（如read）与各系统调用所使用的库函数（如read）之间几乎是一一对应的。而微软的叫Win32API</li>\n</ul>\n<h3 id=\"假脱机系统（spooling）\"><a href=\"#假脱机系统（spooling）\" class=\"headerlink\" title=\"假脱机系统（spooling）\"></a>假脱机系统（spooling）</h3><ul>\n<li>spooling技术是对脱机输入&#x2F;输出系统的模拟</li>\n<li>主要组成<ul>\n<li>输入&#x2F;输出井</li>\n<li>输入&#x2F;输出缓冲区</li>\n<li>输入&#x2F;输出进程</li>\n<li>井管理程序</li>\n</ul>\n</li>\n<li>特点（体现操作系统的虚拟性）<ul>\n<li>提高了I&#x2F;O的速度<ul>\n<li>对数据所进行的I&#x2F;O操作，已从对低速设备演变为对输入井或输出井中的数据存取。</li>\n</ul>\n</li>\n<li>将独占设备改造为共享设备<ul>\n<li>实际分给用户进程的不是打印设备，而是共享输出井中的存储区域</li>\n</ul>\n</li>\n<li>实现了虚拟设备功能<ul>\n<li>将独占设备变成多台独占的虚拟设备。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"缓冲区管理\"><a href=\"#缓冲区管理\" class=\"headerlink\" title=\"缓冲区管理\"></a>缓冲区管理</h2><h3 id=\"缓冲的引入（原因）\"><a href=\"#缓冲的引入（原因）\" class=\"headerlink\" title=\"缓冲的引入（原因）\"></a>缓冲的引入（原因）</h3><ul>\n<li>缓和CPU与I&#x2F;O设备间速度不匹配的矛盾</li>\n<li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</li>\n<li>提高CPU和I&#x2F;O设备之间的并行性</li>\n<li>解决数据粒度不匹配的问题</li>\n</ul>\n<h3 id=\"单缓冲区\"><a href=\"#单缓冲区\" class=\"headerlink\" title=\"单缓冲区\"></a>单缓冲区</h3><ul>\n<li>即在CPU计算的时候，将数据数据输入到缓冲区(大小取决与T和C的大小)</li>\n</ul>\n<h3 id=\"双缓冲区\"><a href=\"#双缓冲区\" class=\"headerlink\" title=\"双缓冲区\"></a>双缓冲区</h3><ul>\n<li>即允许CPU连续工作（T不断）</li>\n</ul>\n<h3 id=\"环形缓冲区（专为生产者和消费者打造）\"><a href=\"#环形缓冲区（专为生产者和消费者打造）\" class=\"headerlink\" title=\"环形缓冲区（专为生产者和消费者打造）\"></a>环形缓冲区（专为生产者和消费者打造）</h3><ul>\n<li>组成<ul>\n<li>多个缓冲区</li>\n<li>多个指针</li>\n</ul>\n</li>\n<li>使用<ul>\n<li>Getbuf过程</li>\n<li>Releasebuf过程</li>\n</ul>\n</li>\n<li>同步问题</li>\n</ul>\n<h3 id=\"缓冲池-理解为更大的缓冲区\"><a href=\"#缓冲池-理解为更大的缓冲区\" class=\"headerlink\" title=\"缓冲池(理解为更大的缓冲区)\"></a>缓冲池(理解为更大的缓冲区)</h3><ul>\n<li>组成<ul>\n<li>空白缓冲队列（emq）<ul>\n<li>由空缓冲区链接而成F(emq)，L(emq)分别指向该队列首尾缓冲区</li>\n</ul>\n</li>\n<li>输入队列（inq）<ul>\n<li>由装满输入数据的缓冲区链接而成F(inq)，L(inq)分别指向该队列首尾缓冲区</li>\n</ul>\n</li>\n<li>输出队列（outq）<ul>\n<li>由装满输出数据的缓冲区链接而成F(outq)， L(outq)分别指向该队列首尾缓冲</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Getbuf和Putbuf过程<ul>\n<li>收容：缓冲池接收外界数据</li>\n<li>提取：外界从缓冲池获得数据</li>\n</ul>\n</li>\n<li>缓冲区工作方式（从缓冲区的角度来看）<ul>\n<li>收容输入</li>\n<li>提取输入</li>\n<li>收容输出</li>\n<li>提取输出</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"磁盘存储器的性能和调度\"><a href=\"#磁盘存储器的性能和调度\" class=\"headerlink\" title=\"磁盘存储器的性能和调度\"></a>磁盘存储器的性能和调度</h2><h3 id=\"数据的组织和格式\"><a href=\"#数据的组织和格式\" class=\"headerlink\" title=\"数据的组织和格式\"></a>数据的组织和格式</h3><h3 id=\"磁盘的类型\"><a href=\"#磁盘的类型\" class=\"headerlink\" title=\"磁盘的类型\"></a>磁盘的类型</h3><ul>\n<li>固定头磁盘（贵）</li>\n<li>移动头磁盘</li>\n</ul>\n<h3 id=\"磁盘访问的时间（关键）\"><a href=\"#磁盘访问的时间（关键）\" class=\"headerlink\" title=\"磁盘访问的时间（关键）\"></a>磁盘访问的时间（关键）</h3><ul>\n<li>寻道时间Ts&#x3D;m*n+s</li>\n<li>旋转延迟时间Tr</li>\n<li>传输时间Tt&#x3D;b&#x2F;rN</li>\n<li>总时间Ta&#x3D;Ts+1&#x2F;2r+b&#x2F;rN</li>\n</ul>\n<h3 id=\"磁盘的调度算法（掌握图表）\"><a href=\"#磁盘的调度算法（掌握图表）\" class=\"headerlink\" title=\"磁盘的调度算法（掌握图表）\"></a>磁盘的调度算法（掌握图表）</h3><ul>\n<li>先来先服务（FCFS）<ul>\n<li>优点：公平，简单</li>\n<li>缺点：可能导致某些进程的请求长期得不到满足</li>\n</ul>\n</li>\n<li>最短寻道时间优先（SSTF）<ul>\n<li>说明：要求访问的磁道和当前磁头所在的磁道距离最近，以使每次的寻道时间最短</li>\n</ul>\n</li>\n<li>扫描算法（SCAN）<ul>\n<li>扫描算法不仅考虑到欲访问的磁道与当前磁道间的距离，更优先考虑的是磁道当前的移动方向</li>\n<li>联想电梯的运行</li>\n<li>可防止低优先级进程出现“饥饿”的现象</li>\n</ul>\n</li>\n<li>循环扫描算法（CSCAN）<ul>\n<li>算法规定磁头单向移动，例如，只是自里向外移动，当磁头移到最外的磁道并访问后，磁头立即返回到最里的欲访问磁道，亦即将最小磁道号紧接着最大磁道号构成循环，进行循环扫描</li>\n</ul>\n</li>\n<li>NStepScan算法<ul>\n<li>N步SCAN算法是将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次这些子队列。</li>\n</ul>\n</li>\n<li>FSCAN算法<ul>\n<li>是Nstepscan算法的简化，将磁盘请求队列分成两个子队列</li>\n</ul>\n</li>\n</ul>\n"},{"_content":"# 第七章：文件管理\n## 数据项\n### 基本数据项\n### 组合数据项\n## 记录\n### 记录是一组相关数据项的集合，用于描述一个对象在某个方面的属性\n## 文件\n### 文件类型\n### 文件长度\n### 文件的物理位置\n### 文件的建立时间\n## 文件操作\n### 创建文件\n### 删除文件\n### 读文件\n### 写文件\n### 设置文件读写的位置\n## 文件的逻辑结构\n### 顺序文件\n### 记录寻址\n### 索引文件\n### 索引顺序文件\n### 直接文件和哈希文件\n## 文件目录\n### 文件控制块（FCB）\n* 文件名+inode(属性)\n### 简单的文件目录\n* 单级文件目录\n    * 查找慢\n    * 不允许重名\n    * 不便于实现文件共享\n* 两级文件目录\n    * 提高检索速度，从M*N到M+N\n### 树形结构目录\n* 路径名\n    * “..”是父目录\n    * “/”是根目录\n    * 区别绝对路径和相对路径（../.../.../1/2/3/）\n## 文件共享\n### 有向无循环图（DAG）\n### 利用符号链接实现文件共享\n* 实际上就是“快捷方式”\n## 文件保护\n","source":"_posts/2023-06-14-7-文件管理.md","raw":"# 第七章：文件管理\n## 数据项\n### 基本数据项\n### 组合数据项\n## 记录\n### 记录是一组相关数据项的集合，用于描述一个对象在某个方面的属性\n## 文件\n### 文件类型\n### 文件长度\n### 文件的物理位置\n### 文件的建立时间\n## 文件操作\n### 创建文件\n### 删除文件\n### 读文件\n### 写文件\n### 设置文件读写的位置\n## 文件的逻辑结构\n### 顺序文件\n### 记录寻址\n### 索引文件\n### 索引顺序文件\n### 直接文件和哈希文件\n## 文件目录\n### 文件控制块（FCB）\n* 文件名+inode(属性)\n### 简单的文件目录\n* 单级文件目录\n    * 查找慢\n    * 不允许重名\n    * 不便于实现文件共享\n* 两级文件目录\n    * 提高检索速度，从M*N到M+N\n### 树形结构目录\n* 路径名\n    * “..”是父目录\n    * “/”是根目录\n    * 区别绝对路径和相对路径（../.../.../1/2/3/）\n## 文件共享\n### 有向无循环图（DAG）\n### 利用符号链接实现文件共享\n* 实际上就是“快捷方式”\n## 文件保护\n","slug":"2023-06-14-7-文件管理","published":1,"date":"2023-12-15T02:31:42.155Z","updated":"2023-12-15T02:31:42.159Z","_id":"clq60jou100074zgs21hj227w","title":"","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"第七章：文件管理\"><a href=\"#第七章：文件管理\" class=\"headerlink\" title=\"第七章：文件管理\"></a>第七章：文件管理</h1><h2 id=\"数据项\"><a href=\"#数据项\" class=\"headerlink\" title=\"数据项\"></a>数据项</h2><h3 id=\"基本数据项\"><a href=\"#基本数据项\" class=\"headerlink\" title=\"基本数据项\"></a>基本数据项</h3><h3 id=\"组合数据项\"><a href=\"#组合数据项\" class=\"headerlink\" title=\"组合数据项\"></a>组合数据项</h3><h2 id=\"记录\"><a href=\"#记录\" class=\"headerlink\" title=\"记录\"></a>记录</h2><h3 id=\"记录是一组相关数据项的集合，用于描述一个对象在某个方面的属性\"><a href=\"#记录是一组相关数据项的集合，用于描述一个对象在某个方面的属性\" class=\"headerlink\" title=\"记录是一组相关数据项的集合，用于描述一个对象在某个方面的属性\"></a>记录是一组相关数据项的集合，用于描述一个对象在某个方面的属性</h3><h2 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h2><h3 id=\"文件类型\"><a href=\"#文件类型\" class=\"headerlink\" title=\"文件类型\"></a>文件类型</h3><h3 id=\"文件长度\"><a href=\"#文件长度\" class=\"headerlink\" title=\"文件长度\"></a>文件长度</h3><h3 id=\"文件的物理位置\"><a href=\"#文件的物理位置\" class=\"headerlink\" title=\"文件的物理位置\"></a>文件的物理位置</h3><h3 id=\"文件的建立时间\"><a href=\"#文件的建立时间\" class=\"headerlink\" title=\"文件的建立时间\"></a>文件的建立时间</h3><h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><h3 id=\"创建文件\"><a href=\"#创建文件\" class=\"headerlink\" title=\"创建文件\"></a>创建文件</h3><h3 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h3><h3 id=\"读文件\"><a href=\"#读文件\" class=\"headerlink\" title=\"读文件\"></a>读文件</h3><h3 id=\"写文件\"><a href=\"#写文件\" class=\"headerlink\" title=\"写文件\"></a>写文件</h3><h3 id=\"设置文件读写的位置\"><a href=\"#设置文件读写的位置\" class=\"headerlink\" title=\"设置文件读写的位置\"></a>设置文件读写的位置</h3><h2 id=\"文件的逻辑结构\"><a href=\"#文件的逻辑结构\" class=\"headerlink\" title=\"文件的逻辑结构\"></a>文件的逻辑结构</h2><h3 id=\"顺序文件\"><a href=\"#顺序文件\" class=\"headerlink\" title=\"顺序文件\"></a>顺序文件</h3><h3 id=\"记录寻址\"><a href=\"#记录寻址\" class=\"headerlink\" title=\"记录寻址\"></a>记录寻址</h3><h3 id=\"索引文件\"><a href=\"#索引文件\" class=\"headerlink\" title=\"索引文件\"></a>索引文件</h3><h3 id=\"索引顺序文件\"><a href=\"#索引顺序文件\" class=\"headerlink\" title=\"索引顺序文件\"></a>索引顺序文件</h3><h3 id=\"直接文件和哈希文件\"><a href=\"#直接文件和哈希文件\" class=\"headerlink\" title=\"直接文件和哈希文件\"></a>直接文件和哈希文件</h3><h2 id=\"文件目录\"><a href=\"#文件目录\" class=\"headerlink\" title=\"文件目录\"></a>文件目录</h2><h3 id=\"文件控制块（FCB）\"><a href=\"#文件控制块（FCB）\" class=\"headerlink\" title=\"文件控制块（FCB）\"></a>文件控制块（FCB）</h3><ul>\n<li>文件名+inode(属性)</li>\n</ul>\n<h3 id=\"简单的文件目录\"><a href=\"#简单的文件目录\" class=\"headerlink\" title=\"简单的文件目录\"></a>简单的文件目录</h3><ul>\n<li>单级文件目录<ul>\n<li>查找慢</li>\n<li>不允许重名</li>\n<li>不便于实现文件共享</li>\n</ul>\n</li>\n<li>两级文件目录<ul>\n<li>提高检索速度，从M*N到M+N</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"树形结构目录\"><a href=\"#树形结构目录\" class=\"headerlink\" title=\"树形结构目录\"></a>树形结构目录</h3><ul>\n<li>路径名<ul>\n<li>“..”是父目录</li>\n<li>“&#x2F;”是根目录</li>\n<li>区别绝对路径和相对路径（..&#x2F;…&#x2F;…&#x2F;1&#x2F;2&#x2F;3&#x2F;）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"文件共享\"><a href=\"#文件共享\" class=\"headerlink\" title=\"文件共享\"></a>文件共享</h2><h3 id=\"有向无循环图（DAG）\"><a href=\"#有向无循环图（DAG）\" class=\"headerlink\" title=\"有向无循环图（DAG）\"></a>有向无循环图（DAG）</h3><h3 id=\"利用符号链接实现文件共享\"><a href=\"#利用符号链接实现文件共享\" class=\"headerlink\" title=\"利用符号链接实现文件共享\"></a>利用符号链接实现文件共享</h3><ul>\n<li>实际上就是“快捷方式”</li>\n</ul>\n<h2 id=\"文件保护\"><a href=\"#文件保护\" class=\"headerlink\" title=\"文件保护\"></a>文件保护</h2>","excerpt":"","more":"<h1 id=\"第七章：文件管理\"><a href=\"#第七章：文件管理\" class=\"headerlink\" title=\"第七章：文件管理\"></a>第七章：文件管理</h1><h2 id=\"数据项\"><a href=\"#数据项\" class=\"headerlink\" title=\"数据项\"></a>数据项</h2><h3 id=\"基本数据项\"><a href=\"#基本数据项\" class=\"headerlink\" title=\"基本数据项\"></a>基本数据项</h3><h3 id=\"组合数据项\"><a href=\"#组合数据项\" class=\"headerlink\" title=\"组合数据项\"></a>组合数据项</h3><h2 id=\"记录\"><a href=\"#记录\" class=\"headerlink\" title=\"记录\"></a>记录</h2><h3 id=\"记录是一组相关数据项的集合，用于描述一个对象在某个方面的属性\"><a href=\"#记录是一组相关数据项的集合，用于描述一个对象在某个方面的属性\" class=\"headerlink\" title=\"记录是一组相关数据项的集合，用于描述一个对象在某个方面的属性\"></a>记录是一组相关数据项的集合，用于描述一个对象在某个方面的属性</h3><h2 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h2><h3 id=\"文件类型\"><a href=\"#文件类型\" class=\"headerlink\" title=\"文件类型\"></a>文件类型</h3><h3 id=\"文件长度\"><a href=\"#文件长度\" class=\"headerlink\" title=\"文件长度\"></a>文件长度</h3><h3 id=\"文件的物理位置\"><a href=\"#文件的物理位置\" class=\"headerlink\" title=\"文件的物理位置\"></a>文件的物理位置</h3><h3 id=\"文件的建立时间\"><a href=\"#文件的建立时间\" class=\"headerlink\" title=\"文件的建立时间\"></a>文件的建立时间</h3><h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><h3 id=\"创建文件\"><a href=\"#创建文件\" class=\"headerlink\" title=\"创建文件\"></a>创建文件</h3><h3 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h3><h3 id=\"读文件\"><a href=\"#读文件\" class=\"headerlink\" title=\"读文件\"></a>读文件</h3><h3 id=\"写文件\"><a href=\"#写文件\" class=\"headerlink\" title=\"写文件\"></a>写文件</h3><h3 id=\"设置文件读写的位置\"><a href=\"#设置文件读写的位置\" class=\"headerlink\" title=\"设置文件读写的位置\"></a>设置文件读写的位置</h3><h2 id=\"文件的逻辑结构\"><a href=\"#文件的逻辑结构\" class=\"headerlink\" title=\"文件的逻辑结构\"></a>文件的逻辑结构</h2><h3 id=\"顺序文件\"><a href=\"#顺序文件\" class=\"headerlink\" title=\"顺序文件\"></a>顺序文件</h3><h3 id=\"记录寻址\"><a href=\"#记录寻址\" class=\"headerlink\" title=\"记录寻址\"></a>记录寻址</h3><h3 id=\"索引文件\"><a href=\"#索引文件\" class=\"headerlink\" title=\"索引文件\"></a>索引文件</h3><h3 id=\"索引顺序文件\"><a href=\"#索引顺序文件\" class=\"headerlink\" title=\"索引顺序文件\"></a>索引顺序文件</h3><h3 id=\"直接文件和哈希文件\"><a href=\"#直接文件和哈希文件\" class=\"headerlink\" title=\"直接文件和哈希文件\"></a>直接文件和哈希文件</h3><h2 id=\"文件目录\"><a href=\"#文件目录\" class=\"headerlink\" title=\"文件目录\"></a>文件目录</h2><h3 id=\"文件控制块（FCB）\"><a href=\"#文件控制块（FCB）\" class=\"headerlink\" title=\"文件控制块（FCB）\"></a>文件控制块（FCB）</h3><ul>\n<li>文件名+inode(属性)</li>\n</ul>\n<h3 id=\"简单的文件目录\"><a href=\"#简单的文件目录\" class=\"headerlink\" title=\"简单的文件目录\"></a>简单的文件目录</h3><ul>\n<li>单级文件目录<ul>\n<li>查找慢</li>\n<li>不允许重名</li>\n<li>不便于实现文件共享</li>\n</ul>\n</li>\n<li>两级文件目录<ul>\n<li>提高检索速度，从M*N到M+N</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"树形结构目录\"><a href=\"#树形结构目录\" class=\"headerlink\" title=\"树形结构目录\"></a>树形结构目录</h3><ul>\n<li>路径名<ul>\n<li>“..”是父目录</li>\n<li>“&#x2F;”是根目录</li>\n<li>区别绝对路径和相对路径（..&#x2F;…&#x2F;…&#x2F;1&#x2F;2&#x2F;3&#x2F;）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"文件共享\"><a href=\"#文件共享\" class=\"headerlink\" title=\"文件共享\"></a>文件共享</h2><h3 id=\"有向无循环图（DAG）\"><a href=\"#有向无循环图（DAG）\" class=\"headerlink\" title=\"有向无循环图（DAG）\"></a>有向无循环图（DAG）</h3><h3 id=\"利用符号链接实现文件共享\"><a href=\"#利用符号链接实现文件共享\" class=\"headerlink\" title=\"利用符号链接实现文件共享\"></a>利用符号链接实现文件共享</h3><ul>\n<li>实际上就是“快捷方式”</li>\n</ul>\n<h2 id=\"文件保护\"><a href=\"#文件保护\" class=\"headerlink\" title=\"文件保护\"></a>文件保护</h2>"},{"_content":"写完代码后，我们一般这样\n\ngit add . //添加所有文件\n\ngit commit -m \"本功能全部完成\"\n\n执行完commit后，想撤回commit，怎么办？\n\n这样凉拌：\n\n**git reset --soft HEAD^**\n\n这样就成功的撤销了你的commit\n\n注意，仅仅是撤回commit操作，您写的代码仍然保留。\n\n## --soft\n\n不删除工作空间改动代码，撤销commit，不撤销git add .\n\n## --mixed\n\n意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作\n\n这个为默认参数,git reset --mixed HEAD^ 和 git reset HEAD^ 效果是一样的。\n\n## --hard\n\n删除工作空间改动代码，撤销commit，撤销git add .\n\n注意完成这个操作后，就恢复到了上一次的commit状态。\n\n## 如果commit注释写错了，只是想改一下注释\n\ngit commit --amend\n\n此时会进入默认vim编辑器，修改注释完毕后保存就好了。\n","source":"_posts/2023-06-14-git commit之后，撤销commit.md","raw":"写完代码后，我们一般这样\n\ngit add . //添加所有文件\n\ngit commit -m \"本功能全部完成\"\n\n执行完commit后，想撤回commit，怎么办？\n\n这样凉拌：\n\n**git reset --soft HEAD^**\n\n这样就成功的撤销了你的commit\n\n注意，仅仅是撤回commit操作，您写的代码仍然保留。\n\n## --soft\n\n不删除工作空间改动代码，撤销commit，不撤销git add .\n\n## --mixed\n\n意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作\n\n这个为默认参数,git reset --mixed HEAD^ 和 git reset HEAD^ 效果是一样的。\n\n## --hard\n\n删除工作空间改动代码，撤销commit，撤销git add .\n\n注意完成这个操作后，就恢复到了上一次的commit状态。\n\n## 如果commit注释写错了，只是想改一下注释\n\ngit commit --amend\n\n此时会进入默认vim编辑器，修改注释完毕后保存就好了。\n","slug":"2023-06-14-git commit之后，撤销commit","published":1,"date":"2023-12-15T02:31:42.183Z","updated":"2023-12-15T02:31:42.191Z","_id":"clq60jouv00084zgshw9jhlsa","title":"","comments":1,"layout":"post","photos":[],"content":"<p>写完代码后，我们一般这样</p>\n<p>git add . &#x2F;&#x2F;添加所有文件</p>\n<p>git commit -m “本功能全部完成”</p>\n<p>执行完commit后，想撤回commit，怎么办？</p>\n<p>这样凉拌：</p>\n<p><strong>git reset –soft HEAD^</strong></p>\n<p>这样就成功的撤销了你的commit</p>\n<p>注意，仅仅是撤回commit操作，您写的代码仍然保留。</p>\n<h2 id=\"–soft\"><a href=\"#–soft\" class=\"headerlink\" title=\"–soft\"></a>–soft</h2><p>不删除工作空间改动代码，撤销commit，不撤销git add .</p>\n<h2 id=\"–mixed\"><a href=\"#–mixed\" class=\"headerlink\" title=\"–mixed\"></a>–mixed</h2><p>意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作</p>\n<p>这个为默认参数,git reset –mixed HEAD^ 和 git reset HEAD^ 效果是一样的。</p>\n<h2 id=\"–hard\"><a href=\"#–hard\" class=\"headerlink\" title=\"–hard\"></a>–hard</h2><p>删除工作空间改动代码，撤销commit，撤销git add .</p>\n<p>注意完成这个操作后，就恢复到了上一次的commit状态。</p>\n<h2 id=\"如果commit注释写错了，只是想改一下注释\"><a href=\"#如果commit注释写错了，只是想改一下注释\" class=\"headerlink\" title=\"如果commit注释写错了，只是想改一下注释\"></a>如果commit注释写错了，只是想改一下注释</h2><p>git commit –amend</p>\n<p>此时会进入默认vim编辑器，修改注释完毕后保存就好了。</p>\n","excerpt":"","more":"<p>写完代码后，我们一般这样</p>\n<p>git add . &#x2F;&#x2F;添加所有文件</p>\n<p>git commit -m “本功能全部完成”</p>\n<p>执行完commit后，想撤回commit，怎么办？</p>\n<p>这样凉拌：</p>\n<p><strong>git reset –soft HEAD^</strong></p>\n<p>这样就成功的撤销了你的commit</p>\n<p>注意，仅仅是撤回commit操作，您写的代码仍然保留。</p>\n<h2 id=\"–soft\"><a href=\"#–soft\" class=\"headerlink\" title=\"–soft\"></a>–soft</h2><p>不删除工作空间改动代码，撤销commit，不撤销git add .</p>\n<h2 id=\"–mixed\"><a href=\"#–mixed\" class=\"headerlink\" title=\"–mixed\"></a>–mixed</h2><p>意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作</p>\n<p>这个为默认参数,git reset –mixed HEAD^ 和 git reset HEAD^ 效果是一样的。</p>\n<h2 id=\"–hard\"><a href=\"#–hard\" class=\"headerlink\" title=\"–hard\"></a>–hard</h2><p>删除工作空间改动代码，撤销commit，撤销git add .</p>\n<p>注意完成这个操作后，就恢复到了上一次的commit状态。</p>\n<h2 id=\"如果commit注释写错了，只是想改一下注释\"><a href=\"#如果commit注释写错了，只是想改一下注释\" class=\"headerlink\" title=\"如果commit注释写错了，只是想改一下注释\"></a>如果commit注释写错了，只是想改一下注释</h2><p>git commit –amend</p>\n<p>此时会进入默认vim编辑器，修改注释完毕后保存就好了。</p>\n"},{"_content":"统一概念：\n\n- 工作区：改动（增删文件和内容）\n- 暂存区：输入命令：git add 改动的文件名，此次改动就放到了 ‘暂存区’\n- 本地仓库(简称：本地)：输入命令：git commit 此次修改的描述，此次改动就放到了本地仓库，每个 commit，我叫它为一个版本。\n- 远程仓库(简称：远程)：输入命令：git push 远程仓库，此次改动就放到了远程仓库（GitHub 等)\n- commit-id：输出命令：git log，最上面那行 commit xxxxxx，后面的字符串就是 commit-id\n\n\n\n下面，就是你在找的 Git 命令速查表。\n\n## 展示帮助信息\n\n```\ngit help -g\n```\n\nThe command output as below:\n\n```\nThe common Git guides are:\n   attributes          Defining attributes per path\n   cli                 Git command-line interface and conventions\n   core-tutorial       A Git core tutorial for developers\n   cvs-migration       Git for CVS users\n   diffcore            Tweaking diff output\n   everyday            A useful minimum set of commands for Everyday Git\n   glossary            A Git Glossary\n   hooks               Hooks used by Git\n   ignore              Specifies intentionally untracked files to ignore\n   modules             Defining submodule properties\n   namespaces          Git namespaces\n   repository-layout    Git Repository Layout\n   revisions           Specifying revisions and ranges for Git\n   tutorial            A tutorial introduction to Git\n   tutorial-2          A tutorial introduction to Git: part two\n   workflows           An overview of recommended workflows with Git\n\n'git help -a' and 'git help -g' list available subcommands and some concept guides. See 'git help <command>' or 'git help <concept>' to read about a specific subcommand or concept.\n```\n\n\n\n## 回到远程仓库的状态\n\n抛弃本地所有的修改，回到远程仓库的状态。\n\n```\ngit fetch --all && git reset --hard origin/master\n```\n\n\n\n## 重设第一个 commit\n\n也就是把所有的改动都重新放回工作区，并**清空所有的 commit**，这样就可以重新提交第一个 commit 了\n\n```\ngit update-ref -d HEAD\n```\n\n\n\n## 查看冲突文件列表\n\n展示工作区的冲突文件列表\n\n```\ngit diff --name-only --diff-filter=U\n```\n\n\n\n## 展示工作区和暂存区的不同\n\n输出**工作区**和**暂存区**的 different (不同)。\n\n```\ngit diff\n```\n\n还可以展示本地仓库中任意两个 commit 之间的文件变动：\n\n```\ngit diff <commit-id> <commit-id>\n```\n\n\n\n## 展示暂存区和最近版本的不同\n\n输出**暂存区**和本地最近的版本 (commit) 的 different (不同)。\n\n```\ngit diff --cached\n```\n\n\n\n## 展示暂存区、工作区和最近版本的不同\n\n输出**工作区**、**暂存区** 和本地最近的版本 (commit) 的 different (不同)。\n\n```\ngit diff HEAD\n```\n\n\n\n## 快速切换到上一个分支\n\n```\ngit checkout -\n```\n\n\n\n## 删除已经合并到 master 的分支\n\n```\ngit branch --merged master | grep -v '^\\*\\|  master' | xargs -n 1 git branch -d\n```\n\n\n\n## 展示本地分支关联远程仓库的情况\n\n```\ngit branch -vv\n```\n\n\n\n## 关联远程分支\n\n关联之后，git branch -vv 就可以展示关联的远程分支名了，同时推送到远程仓库直接：git push，不需要指定远程仓库了。\n\n```\ngit branch -u origin/mybranch\n```\n\n或者在 push 时加上 -u 参数\n\n```\ngit push origin/mybranch -u\n```\n\n\n\n## 列出所有远程分支\n\n-r 参数相当于：remote\n\n```\ngit branch -r\n```\n\n\n\n## 列出本地和远程分支\n\n-a 参数相当于：all\n\n```\ngit branch -a\n```\n\n\n\n## 查看远程分支和本地分支的对应关系\n\n```\ngit remote show origin\n```\n\n\n\n## 远程删除了分支本地也想删除\n\n```\ngit remote prune origin\n```\n\n\n\n## 创建并切换到本地分支\n\n```\ngit checkout -b <branch-name>\n```\n\n\n\n## 从远程分支中创建并切换到本地分支\n\n```\ngit checkout -b <branch-name> origin/<branch-name>\n```\n\n\n\n## 删除本地分支\n\n```\ngit branch -d <local-branchname>\n```\n\n\n\n## 删除远程分支\n\n```\ngit push origin --delete <remote-branchname>\n```\n\n或者\n\n```\ngit push origin :<remote-branchname>\n```\n\n\n\n## 重命名本地分支\n\n```\ngit branch -m <new-branch-name>\n```\n\n\n\n## 查看标签\n\n```\ngit tag\n```\n\n展示当前分支的最近的 tag\n\n```\ngit describe --tags --abbrev=0\n```\n\n\n\n## 查看标签详细信息\n\n```\ngit tag -ln\n```\n\n\n\n## 本地创建标签\n\n```\ngit tag <version-number>\n```\n\n默认 tag 是打在最近的一次 commit 上，如果需要指定 commit 打 tag：\n\n```\n$ git tag -a <version-number> -m \"v1.0 发布(描述)\" <commit-id>\n```\n\n\n\n## 推送标签到远程仓库\n\n首先要保证本地创建好了标签才可以推送标签到远程仓库：\n\n```\ngit push origin <local-version-number>\n```\n\n一次性推送所有标签，同步到远程仓库：\n\n```\ngit push origin --tags\n```\n\n\n\n## 删除本地标签\n\n```\ngit tag -d <tag-name>\n```\n\n\n\n## 删除远程标签\n\n```\ngit push origin --delete tag <tagname>\n```\n\n\n\n## 切回到某个标签\n\n一般上线之前都会打 tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态：\n\n```\ngit checkout -b branch_name tag_name\n```\n\n\n\n## 放弃工作区的修改\n\n```\ngit checkout <file-name>\n```\n\n放弃所有修改：\n\n```\ngit checkout .\n```\n\n\n\n## 恢复删除的文件\n\n```\ngit rev-list -n 1 HEAD -- <file_path> #得到 deleting_commit\n\ngit checkout <deleting_commit>^ -- <file_path> #回到删除文件 deleting_commit 之前的状态\n```\n\n\n\n## 以新增一个 commit 的方式还原某一个 commit 的修改\n\n```\ngit revert <commit-id>\n```\n\n\n\n## 回到某个 commit 的状态，并删除后面的 commit\n\n和 revert 的区别：reset 命令会抹去某个 commit id 之后的所有 commit\n\n```\ngit reset <commit-id>  #默认就是-mixed参数。\n\ngit reset --mixed HEAD^  #回退至上个版本，它将重置HEAD到另外一个commit,并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。\n\ngit reset --soft HEAD~3  #回退至三个版本之前，只回退了commit的信息，暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可  \n\ngit reset --hard <commit-id>  #彻底回退到指定commit-id的状态，暂存区和工作区也会变为指定commit-id版本的内容\n```\n\n\n\n## 修改上一个 commit 的描述\n\n如果暂存区有改动，同时也会将暂存区的改动提交到上一个 commit\n\n```\ngit commit --amend\n```\n\n\n\n## 查看 commit 历史\n\n```\ngit log\n```\n\n\n\n## 查看某段代码是谁写的\n\nblame 的意思为‘责怪’，你懂的。\n\n```\ngit blame <file-name>\n```\n\n\n\n## 显示本地更新过 HEAD 的 git 命令记录\n\n每次更新了 HEAD 的 git 命令比如 commit、amend、cherry-pick、reset、revert 等都会被记录下来（不限分支），就像 shell 的 history 一样。 这样你可以 reset 到任何一次更新了 HEAD 的操作之后，而不仅仅是回到当前分支下的某个 commit 之后的状态。\n\n```\ngit reflog\n```\n\n\n\n## 修改作者名\n\n```\ngit commit --amend --author='Author Name <email@address.com>'\n```\n\n\n\n## 修改远程仓库的 url\n\n```\ngit remote set-url origin <URL>\n```\n\n\n\n## 增加远程仓库\n\n```\ngit remote add origin <remote-url>\n```\n\n\n\n## 列出所有远程仓库\n\n```\ngit remote\n```\n\n\n\n## 查看两个星期内的改动\n\n```\ngit whatchanged --since='2 weeks ago'\n```\n\n\n\n## 把 A 分支的某一个 commit，放到 B 分支上\n\n这个过程需要 cherry-pick 命令，[参考](http://sg552.iteye.com/blog/1300713#bc2367928)\n\n```\ngit checkout <branch-name> && git cherry-pick <commit-id>\n```\n\n\n\n## 给 git 命令起别名\n\n简化命令\n\n```\ngit config --global alias.<handle> <command>\n\n比如：git status 改成 git st，这样可以简化命令\n\ngit config --global alias.st status\n```\n\n\n\n## 存储当前的修改，但不用提交 commit\n\n详解可以参考[廖雪峰老师的 git 教程](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000)\n\n```\ngit stash\n```\n\n\n\n## 保存当前状态，包括 untracked 的文件\n\nuntracked 文件：新建的文件\n\n```\ngit stash -u\n```\n\n\n\n## 展示所有 stashes\n\n```\ngit stash list\n```\n\n\n\n## 回到某个 stash 的状态\n\n```\ngit stash apply <stash@{n}>\n```\n\n\n\n## 回到最后一个 stash 的状态，并删除这个 stash\n\n```\ngit stash pop\n```\n\n\n\n## 删除所有的 stash\n\n```\ngit stash clear\n```\n\n\n\n## 从 stash 中拿出某个文件的修改\n\n```\ngit checkout <stash@{n}> -- <file-path>\n```\n\n\n\n## 展示所有 tracked 的文件\n\n```\ngit ls-files -t\n```\n\n\n\n## 展示所有 untracked 的文件\n\n```\ngit ls-files --others\n```\n\n\n\n## 展示所有忽略的文件\n\n```\ngit ls-files --others -i --exclude-standard\n```\n\n\n\n## 强制删除 untracked 的文件\n\n可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的 untracked 文件。clean 命令，**注意两点**：\n\n1. clean 后，删除的文件无法找回\n2. 不会影响 tracked 的文件的改动，只会删除 untracked 的文件\n\n```\ngit clean <file-name> -f\n```\n\n\n\n## 强制删除 untracked 的目录\n\n可以用来删除新建的目录，**注意**:这个命令也可以用来删除 untracked 的文件。详情见上一条\n\n```\ngit clean <directory-name> -df\n```\n\n\n\n## 展示简化的 commit 历史\n\n```\ngit log --pretty=oneline --graph --decorate --all\n```\n\n\n\n## 把某一个分支导出成一个文件\n\n```\ngit bundle create <file> <branch-name>\n```\n\n\n\n## 从包中导入分支\n\n新建一个分支，分支内容就是上面 git bundle create 命令导出的内容\n\n```\ngit clone repo.bundle <repo-dir> -b <branch-name>\n```\n\n\n\n## 执行 rebase 之前自动 stash\n\n```\ngit rebase --autostash\n```\n\n\n\n## 从远程仓库根据 ID，拉下某一状态，到本地分支\n\n```\ngit fetch origin pull/<id>/head:<branch-name>\n```\n\n\n\n## 详细展示一行中的修改\n\n```\ngit diff --word-diff\n```\n\n\n\n## 清除 gitignore 文件中记录的文件\n\n```\ngit clean -X -f\n```\n\n\n\n## 展示所有 alias 和 configs\n\n**注意：** config 分为：当前目录（local）和全局（golbal）的 config，默认为当前目录的 config\n\n```\ngit config --local --list (当前目录)\ngit config --global --list (全局)\n```\n\n\n\n## 展示忽略的文件\n\n```\ngit status --ignored\n```\n\n\n\n## commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit\n\n```\ngit log Branch1 ^Branch2\n```\n\n\n\n## 在 commit log 中显示 GPG 签名\n\n```\ngit log --show-signature\n```\n\n\n\n## 删除全局设置\n\n```\ngit config --global --unset <entry-name>\n```\n\n\n\n## 新建并切换到新分支上，同时这个分支没有任何 commit\n\n相当于保存修改，但是重写 commit 历史\n\n```\ngit checkout --orphan <branch-name>\n```\n\n\n\n## 展示任意分支某一文件的内容\n\n```\ngit show <branch-name>:<file-name>\n```\n\n\n\n## clone 下来指定的单一分支\n\n```\ngit clone -b <branch-name> --single-branch https://github.com/user/repo.git\n```\n\n\n\n## clone 最新一次提交\n\n只会 clone 最近一次提交，将减少 clone 时间\n\n```\ngit clone --depth=1 https://github.com/user/repo.git\n```\n\n\n\n## 忽略某个文件的改动\n\n关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动\n\n```\ngit update-index --assume-unchanged path/to/file\n```\n\n恢复 track 指定文件的改动\n\n```\ngit update-index --no-assume-unchanged path/to/file\n```\n\n\n\n## 忽略文件的权限变化\n\n不再将文件的权限变化视作改动\n\n```\ngit config core.fileMode false\n```\n\n\n\n## 以最后提交的顺序列出所有 Git 分支\n\n最新的放在最上面\n\n```\ngit for-each-ref --sort=-committerdate --format='%(refname:short)' refs/heads/\n```\n\n\n\n## 在 commit log 中查找相关内容\n\n通过 grep 查找，given-text：所需要查找的字段\n\n```\ngit log --all --grep='<given-text>'\n```\n\n\n\n## 把暂存区的指定 file 放到工作区中\n\n不添加参数，默认是 -mixed\n\n```\ngit reset <file-name>\n```\n\n\n\n## 强制推送\n\n```\ngit push -f <remote-name> <branch-name>\n```\n","source":"_posts/2023-06-14-Git操作奇淫技巧.md","raw":"统一概念：\n\n- 工作区：改动（增删文件和内容）\n- 暂存区：输入命令：git add 改动的文件名，此次改动就放到了 ‘暂存区’\n- 本地仓库(简称：本地)：输入命令：git commit 此次修改的描述，此次改动就放到了本地仓库，每个 commit，我叫它为一个版本。\n- 远程仓库(简称：远程)：输入命令：git push 远程仓库，此次改动就放到了远程仓库（GitHub 等)\n- commit-id：输出命令：git log，最上面那行 commit xxxxxx，后面的字符串就是 commit-id\n\n\n\n下面，就是你在找的 Git 命令速查表。\n\n## 展示帮助信息\n\n```\ngit help -g\n```\n\nThe command output as below:\n\n```\nThe common Git guides are:\n   attributes          Defining attributes per path\n   cli                 Git command-line interface and conventions\n   core-tutorial       A Git core tutorial for developers\n   cvs-migration       Git for CVS users\n   diffcore            Tweaking diff output\n   everyday            A useful minimum set of commands for Everyday Git\n   glossary            A Git Glossary\n   hooks               Hooks used by Git\n   ignore              Specifies intentionally untracked files to ignore\n   modules             Defining submodule properties\n   namespaces          Git namespaces\n   repository-layout    Git Repository Layout\n   revisions           Specifying revisions and ranges for Git\n   tutorial            A tutorial introduction to Git\n   tutorial-2          A tutorial introduction to Git: part two\n   workflows           An overview of recommended workflows with Git\n\n'git help -a' and 'git help -g' list available subcommands and some concept guides. See 'git help <command>' or 'git help <concept>' to read about a specific subcommand or concept.\n```\n\n\n\n## 回到远程仓库的状态\n\n抛弃本地所有的修改，回到远程仓库的状态。\n\n```\ngit fetch --all && git reset --hard origin/master\n```\n\n\n\n## 重设第一个 commit\n\n也就是把所有的改动都重新放回工作区，并**清空所有的 commit**，这样就可以重新提交第一个 commit 了\n\n```\ngit update-ref -d HEAD\n```\n\n\n\n## 查看冲突文件列表\n\n展示工作区的冲突文件列表\n\n```\ngit diff --name-only --diff-filter=U\n```\n\n\n\n## 展示工作区和暂存区的不同\n\n输出**工作区**和**暂存区**的 different (不同)。\n\n```\ngit diff\n```\n\n还可以展示本地仓库中任意两个 commit 之间的文件变动：\n\n```\ngit diff <commit-id> <commit-id>\n```\n\n\n\n## 展示暂存区和最近版本的不同\n\n输出**暂存区**和本地最近的版本 (commit) 的 different (不同)。\n\n```\ngit diff --cached\n```\n\n\n\n## 展示暂存区、工作区和最近版本的不同\n\n输出**工作区**、**暂存区** 和本地最近的版本 (commit) 的 different (不同)。\n\n```\ngit diff HEAD\n```\n\n\n\n## 快速切换到上一个分支\n\n```\ngit checkout -\n```\n\n\n\n## 删除已经合并到 master 的分支\n\n```\ngit branch --merged master | grep -v '^\\*\\|  master' | xargs -n 1 git branch -d\n```\n\n\n\n## 展示本地分支关联远程仓库的情况\n\n```\ngit branch -vv\n```\n\n\n\n## 关联远程分支\n\n关联之后，git branch -vv 就可以展示关联的远程分支名了，同时推送到远程仓库直接：git push，不需要指定远程仓库了。\n\n```\ngit branch -u origin/mybranch\n```\n\n或者在 push 时加上 -u 参数\n\n```\ngit push origin/mybranch -u\n```\n\n\n\n## 列出所有远程分支\n\n-r 参数相当于：remote\n\n```\ngit branch -r\n```\n\n\n\n## 列出本地和远程分支\n\n-a 参数相当于：all\n\n```\ngit branch -a\n```\n\n\n\n## 查看远程分支和本地分支的对应关系\n\n```\ngit remote show origin\n```\n\n\n\n## 远程删除了分支本地也想删除\n\n```\ngit remote prune origin\n```\n\n\n\n## 创建并切换到本地分支\n\n```\ngit checkout -b <branch-name>\n```\n\n\n\n## 从远程分支中创建并切换到本地分支\n\n```\ngit checkout -b <branch-name> origin/<branch-name>\n```\n\n\n\n## 删除本地分支\n\n```\ngit branch -d <local-branchname>\n```\n\n\n\n## 删除远程分支\n\n```\ngit push origin --delete <remote-branchname>\n```\n\n或者\n\n```\ngit push origin :<remote-branchname>\n```\n\n\n\n## 重命名本地分支\n\n```\ngit branch -m <new-branch-name>\n```\n\n\n\n## 查看标签\n\n```\ngit tag\n```\n\n展示当前分支的最近的 tag\n\n```\ngit describe --tags --abbrev=0\n```\n\n\n\n## 查看标签详细信息\n\n```\ngit tag -ln\n```\n\n\n\n## 本地创建标签\n\n```\ngit tag <version-number>\n```\n\n默认 tag 是打在最近的一次 commit 上，如果需要指定 commit 打 tag：\n\n```\n$ git tag -a <version-number> -m \"v1.0 发布(描述)\" <commit-id>\n```\n\n\n\n## 推送标签到远程仓库\n\n首先要保证本地创建好了标签才可以推送标签到远程仓库：\n\n```\ngit push origin <local-version-number>\n```\n\n一次性推送所有标签，同步到远程仓库：\n\n```\ngit push origin --tags\n```\n\n\n\n## 删除本地标签\n\n```\ngit tag -d <tag-name>\n```\n\n\n\n## 删除远程标签\n\n```\ngit push origin --delete tag <tagname>\n```\n\n\n\n## 切回到某个标签\n\n一般上线之前都会打 tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态：\n\n```\ngit checkout -b branch_name tag_name\n```\n\n\n\n## 放弃工作区的修改\n\n```\ngit checkout <file-name>\n```\n\n放弃所有修改：\n\n```\ngit checkout .\n```\n\n\n\n## 恢复删除的文件\n\n```\ngit rev-list -n 1 HEAD -- <file_path> #得到 deleting_commit\n\ngit checkout <deleting_commit>^ -- <file_path> #回到删除文件 deleting_commit 之前的状态\n```\n\n\n\n## 以新增一个 commit 的方式还原某一个 commit 的修改\n\n```\ngit revert <commit-id>\n```\n\n\n\n## 回到某个 commit 的状态，并删除后面的 commit\n\n和 revert 的区别：reset 命令会抹去某个 commit id 之后的所有 commit\n\n```\ngit reset <commit-id>  #默认就是-mixed参数。\n\ngit reset --mixed HEAD^  #回退至上个版本，它将重置HEAD到另外一个commit,并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。\n\ngit reset --soft HEAD~3  #回退至三个版本之前，只回退了commit的信息，暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可  \n\ngit reset --hard <commit-id>  #彻底回退到指定commit-id的状态，暂存区和工作区也会变为指定commit-id版本的内容\n```\n\n\n\n## 修改上一个 commit 的描述\n\n如果暂存区有改动，同时也会将暂存区的改动提交到上一个 commit\n\n```\ngit commit --amend\n```\n\n\n\n## 查看 commit 历史\n\n```\ngit log\n```\n\n\n\n## 查看某段代码是谁写的\n\nblame 的意思为‘责怪’，你懂的。\n\n```\ngit blame <file-name>\n```\n\n\n\n## 显示本地更新过 HEAD 的 git 命令记录\n\n每次更新了 HEAD 的 git 命令比如 commit、amend、cherry-pick、reset、revert 等都会被记录下来（不限分支），就像 shell 的 history 一样。 这样你可以 reset 到任何一次更新了 HEAD 的操作之后，而不仅仅是回到当前分支下的某个 commit 之后的状态。\n\n```\ngit reflog\n```\n\n\n\n## 修改作者名\n\n```\ngit commit --amend --author='Author Name <email@address.com>'\n```\n\n\n\n## 修改远程仓库的 url\n\n```\ngit remote set-url origin <URL>\n```\n\n\n\n## 增加远程仓库\n\n```\ngit remote add origin <remote-url>\n```\n\n\n\n## 列出所有远程仓库\n\n```\ngit remote\n```\n\n\n\n## 查看两个星期内的改动\n\n```\ngit whatchanged --since='2 weeks ago'\n```\n\n\n\n## 把 A 分支的某一个 commit，放到 B 分支上\n\n这个过程需要 cherry-pick 命令，[参考](http://sg552.iteye.com/blog/1300713#bc2367928)\n\n```\ngit checkout <branch-name> && git cherry-pick <commit-id>\n```\n\n\n\n## 给 git 命令起别名\n\n简化命令\n\n```\ngit config --global alias.<handle> <command>\n\n比如：git status 改成 git st，这样可以简化命令\n\ngit config --global alias.st status\n```\n\n\n\n## 存储当前的修改，但不用提交 commit\n\n详解可以参考[廖雪峰老师的 git 教程](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000)\n\n```\ngit stash\n```\n\n\n\n## 保存当前状态，包括 untracked 的文件\n\nuntracked 文件：新建的文件\n\n```\ngit stash -u\n```\n\n\n\n## 展示所有 stashes\n\n```\ngit stash list\n```\n\n\n\n## 回到某个 stash 的状态\n\n```\ngit stash apply <stash@{n}>\n```\n\n\n\n## 回到最后一个 stash 的状态，并删除这个 stash\n\n```\ngit stash pop\n```\n\n\n\n## 删除所有的 stash\n\n```\ngit stash clear\n```\n\n\n\n## 从 stash 中拿出某个文件的修改\n\n```\ngit checkout <stash@{n}> -- <file-path>\n```\n\n\n\n## 展示所有 tracked 的文件\n\n```\ngit ls-files -t\n```\n\n\n\n## 展示所有 untracked 的文件\n\n```\ngit ls-files --others\n```\n\n\n\n## 展示所有忽略的文件\n\n```\ngit ls-files --others -i --exclude-standard\n```\n\n\n\n## 强制删除 untracked 的文件\n\n可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的 untracked 文件。clean 命令，**注意两点**：\n\n1. clean 后，删除的文件无法找回\n2. 不会影响 tracked 的文件的改动，只会删除 untracked 的文件\n\n```\ngit clean <file-name> -f\n```\n\n\n\n## 强制删除 untracked 的目录\n\n可以用来删除新建的目录，**注意**:这个命令也可以用来删除 untracked 的文件。详情见上一条\n\n```\ngit clean <directory-name> -df\n```\n\n\n\n## 展示简化的 commit 历史\n\n```\ngit log --pretty=oneline --graph --decorate --all\n```\n\n\n\n## 把某一个分支导出成一个文件\n\n```\ngit bundle create <file> <branch-name>\n```\n\n\n\n## 从包中导入分支\n\n新建一个分支，分支内容就是上面 git bundle create 命令导出的内容\n\n```\ngit clone repo.bundle <repo-dir> -b <branch-name>\n```\n\n\n\n## 执行 rebase 之前自动 stash\n\n```\ngit rebase --autostash\n```\n\n\n\n## 从远程仓库根据 ID，拉下某一状态，到本地分支\n\n```\ngit fetch origin pull/<id>/head:<branch-name>\n```\n\n\n\n## 详细展示一行中的修改\n\n```\ngit diff --word-diff\n```\n\n\n\n## 清除 gitignore 文件中记录的文件\n\n```\ngit clean -X -f\n```\n\n\n\n## 展示所有 alias 和 configs\n\n**注意：** config 分为：当前目录（local）和全局（golbal）的 config，默认为当前目录的 config\n\n```\ngit config --local --list (当前目录)\ngit config --global --list (全局)\n```\n\n\n\n## 展示忽略的文件\n\n```\ngit status --ignored\n```\n\n\n\n## commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit\n\n```\ngit log Branch1 ^Branch2\n```\n\n\n\n## 在 commit log 中显示 GPG 签名\n\n```\ngit log --show-signature\n```\n\n\n\n## 删除全局设置\n\n```\ngit config --global --unset <entry-name>\n```\n\n\n\n## 新建并切换到新分支上，同时这个分支没有任何 commit\n\n相当于保存修改，但是重写 commit 历史\n\n```\ngit checkout --orphan <branch-name>\n```\n\n\n\n## 展示任意分支某一文件的内容\n\n```\ngit show <branch-name>:<file-name>\n```\n\n\n\n## clone 下来指定的单一分支\n\n```\ngit clone -b <branch-name> --single-branch https://github.com/user/repo.git\n```\n\n\n\n## clone 最新一次提交\n\n只会 clone 最近一次提交，将减少 clone 时间\n\n```\ngit clone --depth=1 https://github.com/user/repo.git\n```\n\n\n\n## 忽略某个文件的改动\n\n关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动\n\n```\ngit update-index --assume-unchanged path/to/file\n```\n\n恢复 track 指定文件的改动\n\n```\ngit update-index --no-assume-unchanged path/to/file\n```\n\n\n\n## 忽略文件的权限变化\n\n不再将文件的权限变化视作改动\n\n```\ngit config core.fileMode false\n```\n\n\n\n## 以最后提交的顺序列出所有 Git 分支\n\n最新的放在最上面\n\n```\ngit for-each-ref --sort=-committerdate --format='%(refname:short)' refs/heads/\n```\n\n\n\n## 在 commit log 中查找相关内容\n\n通过 grep 查找，given-text：所需要查找的字段\n\n```\ngit log --all --grep='<given-text>'\n```\n\n\n\n## 把暂存区的指定 file 放到工作区中\n\n不添加参数，默认是 -mixed\n\n```\ngit reset <file-name>\n```\n\n\n\n## 强制推送\n\n```\ngit push -f <remote-name> <branch-name>\n```\n","slug":"2023-06-14-Git操作奇淫技巧","published":1,"date":"2023-12-15T02:31:42.207Z","updated":"2023-12-15T02:31:42.215Z","_id":"clq60jovj00094zgs16iu12hv","title":"","comments":1,"layout":"post","photos":[],"content":"<p>统一概念：</p>\n<ul>\n<li>工作区：改动（增删文件和内容）</li>\n<li>暂存区：输入命令：git add 改动的文件名，此次改动就放到了 ‘暂存区’</li>\n<li>本地仓库(简称：本地)：输入命令：git commit 此次修改的描述，此次改动就放到了本地仓库，每个 commit，我叫它为一个版本。</li>\n<li>远程仓库(简称：远程)：输入命令：git push 远程仓库，此次改动就放到了远程仓库（GitHub 等)</li>\n<li>commit-id：输出命令：git log，最上面那行 commit xxxxxx，后面的字符串就是 commit-id</li>\n</ul>\n<p>下面，就是你在找的 Git 命令速查表。</p>\n<h2 id=\"展示帮助信息\"><a href=\"#展示帮助信息\" class=\"headerlink\" title=\"展示帮助信息\"></a>展示帮助信息</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git help -g</span><br></pre></td></tr></table></figure>\n\n<p>The command output as below:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The common Git guides are:</span><br><span class=\"line\">   attributes          Defining attributes per path</span><br><span class=\"line\">   cli                 Git command-line interface and conventions</span><br><span class=\"line\">   core-tutorial       A Git core tutorial for developers</span><br><span class=\"line\">   cvs-migration       Git for CVS users</span><br><span class=\"line\">   diffcore            Tweaking diff output</span><br><span class=\"line\">   everyday            A useful minimum set of commands for Everyday Git</span><br><span class=\"line\">   glossary            A Git Glossary</span><br><span class=\"line\">   hooks               Hooks used by Git</span><br><span class=\"line\">   ignore              Specifies intentionally untracked files to ignore</span><br><span class=\"line\">   modules             Defining submodule properties</span><br><span class=\"line\">   namespaces          Git namespaces</span><br><span class=\"line\">   repository-layout    Git Repository Layout</span><br><span class=\"line\">   revisions           Specifying revisions and ranges for Git</span><br><span class=\"line\">   tutorial            A tutorial introduction to Git</span><br><span class=\"line\">   tutorial-2          A tutorial introduction to Git: part two</span><br><span class=\"line\">   workflows           An overview of recommended workflows with Git</span><br><span class=\"line\"></span><br><span class=\"line\">&#x27;git help -a&#x27; and &#x27;git help -g&#x27; list available subcommands and some concept guides. See &#x27;git help &lt;command&gt;&#x27; or &#x27;git help &lt;concept&gt;&#x27; to read about a specific subcommand or concept.</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"回到远程仓库的状态\"><a href=\"#回到远程仓库的状态\" class=\"headerlink\" title=\"回到远程仓库的状态\"></a>回到远程仓库的状态</h2><p>抛弃本地所有的修改，回到远程仓库的状态。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch --all &amp;&amp; git reset --hard origin/master</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"重设第一个-commit\"><a href=\"#重设第一个-commit\" class=\"headerlink\" title=\"重设第一个 commit\"></a>重设第一个 commit</h2><p>也就是把所有的改动都重新放回工作区，并<strong>清空所有的 commit</strong>，这样就可以重新提交第一个 commit 了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git update-ref -d HEAD</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查看冲突文件列表\"><a href=\"#查看冲突文件列表\" class=\"headerlink\" title=\"查看冲突文件列表\"></a>查看冲突文件列表</h2><p>展示工作区的冲突文件列表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff --name-only --diff-filter=U</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示工作区和暂存区的不同\"><a href=\"#展示工作区和暂存区的不同\" class=\"headerlink\" title=\"展示工作区和暂存区的不同\"></a>展示工作区和暂存区的不同</h2><p>输出<strong>工作区</strong>和<strong>暂存区</strong>的 different (不同)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff</span><br></pre></td></tr></table></figure>\n\n<p>还可以展示本地仓库中任意两个 commit 之间的文件变动：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff &lt;commit-id&gt; &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示暂存区和最近版本的不同\"><a href=\"#展示暂存区和最近版本的不同\" class=\"headerlink\" title=\"展示暂存区和最近版本的不同\"></a>展示暂存区和最近版本的不同</h2><p>输出<strong>暂存区</strong>和本地最近的版本 (commit) 的 different (不同)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff --cached</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示暂存区、工作区和最近版本的不同\"><a href=\"#展示暂存区、工作区和最近版本的不同\" class=\"headerlink\" title=\"展示暂存区、工作区和最近版本的不同\"></a>展示暂存区、工作区和最近版本的不同</h2><p>输出<strong>工作区</strong>、<strong>暂存区</strong> 和本地最近的版本 (commit) 的 different (不同)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff HEAD</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"快速切换到上一个分支\"><a href=\"#快速切换到上一个分支\" class=\"headerlink\" title=\"快速切换到上一个分支\"></a>快速切换到上一个分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"删除已经合并到-master-的分支\"><a href=\"#删除已经合并到-master-的分支\" class=\"headerlink\" title=\"删除已经合并到 master 的分支\"></a>删除已经合并到 master 的分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --merged master | grep -v &#x27;^\\*\\|  master&#x27; | xargs -n 1 git branch -d</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示本地分支关联远程仓库的情况\"><a href=\"#展示本地分支关联远程仓库的情况\" class=\"headerlink\" title=\"展示本地分支关联远程仓库的情况\"></a>展示本地分支关联远程仓库的情况</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -vv</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"关联远程分支\"><a href=\"#关联远程分支\" class=\"headerlink\" title=\"关联远程分支\"></a>关联远程分支</h2><p>关联之后，git branch -vv 就可以展示关联的远程分支名了，同时推送到远程仓库直接：git push，不需要指定远程仓库了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -u origin/mybranch</span><br></pre></td></tr></table></figure>\n\n<p>或者在 push 时加上 -u 参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin/mybranch -u</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"列出所有远程分支\"><a href=\"#列出所有远程分支\" class=\"headerlink\" title=\"列出所有远程分支\"></a>列出所有远程分支</h2><p>-r 参数相当于：remote</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -r</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"列出本地和远程分支\"><a href=\"#列出本地和远程分支\" class=\"headerlink\" title=\"列出本地和远程分支\"></a>列出本地和远程分支</h2><p>-a 参数相当于：all</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -a</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查看远程分支和本地分支的对应关系\"><a href=\"#查看远程分支和本地分支的对应关系\" class=\"headerlink\" title=\"查看远程分支和本地分支的对应关系\"></a>查看远程分支和本地分支的对应关系</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote show origin</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"远程删除了分支本地也想删除\"><a href=\"#远程删除了分支本地也想删除\" class=\"headerlink\" title=\"远程删除了分支本地也想删除\"></a>远程删除了分支本地也想删除</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote prune origin</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"创建并切换到本地分支\"><a href=\"#创建并切换到本地分支\" class=\"headerlink\" title=\"创建并切换到本地分支\"></a>创建并切换到本地分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"从远程分支中创建并切换到本地分支\"><a href=\"#从远程分支中创建并切换到本地分支\" class=\"headerlink\" title=\"从远程分支中创建并切换到本地分支\"></a>从远程分支中创建并切换到本地分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"删除本地分支\"><a href=\"#删除本地分支\" class=\"headerlink\" title=\"删除本地分支\"></a>删除本地分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d &lt;local-branchname&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"删除远程分支\"><a href=\"#删除远程分支\" class=\"headerlink\" title=\"删除远程分支\"></a>删除远程分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin --delete &lt;remote-branchname&gt;</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin :&lt;remote-branchname&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"重命名本地分支\"><a href=\"#重命名本地分支\" class=\"headerlink\" title=\"重命名本地分支\"></a>重命名本地分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -m &lt;new-branch-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查看标签\"><a href=\"#查看标签\" class=\"headerlink\" title=\"查看标签\"></a>查看标签</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag</span><br></pre></td></tr></table></figure>\n\n<p>展示当前分支的最近的 tag</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git describe --tags --abbrev=0</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查看标签详细信息\"><a href=\"#查看标签详细信息\" class=\"headerlink\" title=\"查看标签详细信息\"></a>查看标签详细信息</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag -ln</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"本地创建标签\"><a href=\"#本地创建标签\" class=\"headerlink\" title=\"本地创建标签\"></a>本地创建标签</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag &lt;version-number&gt;</span><br></pre></td></tr></table></figure>\n\n<p>默认 tag 是打在最近的一次 commit 上，如果需要指定 commit 打 tag：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -a &lt;version-number&gt; -m &quot;v1.0 发布(描述)&quot; &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"推送标签到远程仓库\"><a href=\"#推送标签到远程仓库\" class=\"headerlink\" title=\"推送标签到远程仓库\"></a>推送标签到远程仓库</h2><p>首先要保证本地创建好了标签才可以推送标签到远程仓库：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin &lt;local-version-number&gt;</span><br></pre></td></tr></table></figure>\n\n<p>一次性推送所有标签，同步到远程仓库：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin --tags</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"删除本地标签\"><a href=\"#删除本地标签\" class=\"headerlink\" title=\"删除本地标签\"></a>删除本地标签</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag -d &lt;tag-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"删除远程标签\"><a href=\"#删除远程标签\" class=\"headerlink\" title=\"删除远程标签\"></a>删除远程标签</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin --delete tag &lt;tagname&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"切回到某个标签\"><a href=\"#切回到某个标签\" class=\"headerlink\" title=\"切回到某个标签\"></a>切回到某个标签</h2><p>一般上线之前都会打 tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b branch_name tag_name</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"放弃工作区的修改\"><a href=\"#放弃工作区的修改\" class=\"headerlink\" title=\"放弃工作区的修改\"></a>放弃工作区的修改</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout &lt;file-name&gt;</span><br></pre></td></tr></table></figure>\n\n<p>放弃所有修改：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout .</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"恢复删除的文件\"><a href=\"#恢复删除的文件\" class=\"headerlink\" title=\"恢复删除的文件\"></a>恢复删除的文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rev-list -n 1 HEAD -- &lt;file_path&gt; #得到 deleting_commit</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout &lt;deleting_commit&gt;^ -- &lt;file_path&gt; #回到删除文件 deleting_commit 之前的状态</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"以新增一个-commit-的方式还原某一个-commit-的修改\"><a href=\"#以新增一个-commit-的方式还原某一个-commit-的修改\" class=\"headerlink\" title=\"以新增一个 commit 的方式还原某一个 commit 的修改\"></a>以新增一个 commit 的方式还原某一个 commit 的修改</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git revert &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"回到某个-commit-的状态，并删除后面的-commit\"><a href=\"#回到某个-commit-的状态，并删除后面的-commit\" class=\"headerlink\" title=\"回到某个 commit 的状态，并删除后面的 commit\"></a>回到某个 commit 的状态，并删除后面的 commit</h2><p>和 revert 的区别：reset 命令会抹去某个 commit id 之后的所有 commit</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset &lt;commit-id&gt;  #默认就是-mixed参数。</span><br><span class=\"line\"></span><br><span class=\"line\">git reset --mixed HEAD^  #回退至上个版本，它将重置HEAD到另外一个commit,并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。</span><br><span class=\"line\"></span><br><span class=\"line\">git reset --soft HEAD~3  #回退至三个版本之前，只回退了commit的信息，暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可  </span><br><span class=\"line\"></span><br><span class=\"line\">git reset --hard &lt;commit-id&gt;  #彻底回退到指定commit-id的状态，暂存区和工作区也会变为指定commit-id版本的内容</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"修改上一个-commit-的描述\"><a href=\"#修改上一个-commit-的描述\" class=\"headerlink\" title=\"修改上一个 commit 的描述\"></a>修改上一个 commit 的描述</h2><p>如果暂存区有改动，同时也会将暂存区的改动提交到上一个 commit</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查看-commit-历史\"><a href=\"#查看-commit-历史\" class=\"headerlink\" title=\"查看 commit 历史\"></a>查看 commit 历史</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查看某段代码是谁写的\"><a href=\"#查看某段代码是谁写的\" class=\"headerlink\" title=\"查看某段代码是谁写的\"></a>查看某段代码是谁写的</h2><p>blame 的意思为‘责怪’，你懂的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git blame &lt;file-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"显示本地更新过-HEAD-的-git-命令记录\"><a href=\"#显示本地更新过-HEAD-的-git-命令记录\" class=\"headerlink\" title=\"显示本地更新过 HEAD 的 git 命令记录\"></a>显示本地更新过 HEAD 的 git 命令记录</h2><p>每次更新了 HEAD 的 git 命令比如 commit、amend、cherry-pick、reset、revert 等都会被记录下来（不限分支），就像 shell 的 history 一样。 这样你可以 reset 到任何一次更新了 HEAD 的操作之后，而不仅仅是回到当前分支下的某个 commit 之后的状态。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reflog</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"修改作者名\"><a href=\"#修改作者名\" class=\"headerlink\" title=\"修改作者名\"></a>修改作者名</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend --author=&#x27;Author Name &lt;email@address.com&gt;&#x27;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"修改远程仓库的-url\"><a href=\"#修改远程仓库的-url\" class=\"headerlink\" title=\"修改远程仓库的 url\"></a>修改远程仓库的 url</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote set-url origin &lt;URL&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"增加远程仓库\"><a href=\"#增加远程仓库\" class=\"headerlink\" title=\"增加远程仓库\"></a>增加远程仓库</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin &lt;remote-url&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"列出所有远程仓库\"><a href=\"#列出所有远程仓库\" class=\"headerlink\" title=\"列出所有远程仓库\"></a>列出所有远程仓库</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查看两个星期内的改动\"><a href=\"#查看两个星期内的改动\" class=\"headerlink\" title=\"查看两个星期内的改动\"></a>查看两个星期内的改动</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git whatchanged --since=&#x27;2 weeks ago&#x27;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"把-A-分支的某一个-commit，放到-B-分支上\"><a href=\"#把-A-分支的某一个-commit，放到-B-分支上\" class=\"headerlink\" title=\"把 A 分支的某一个 commit，放到 B 分支上\"></a>把 A 分支的某一个 commit，放到 B 分支上</h2><p>这个过程需要 cherry-pick 命令，<a href=\"http://sg552.iteye.com/blog/1300713#bc2367928\">参考</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"给-git-命令起别名\"><a href=\"#给-git-命令起别名\" class=\"headerlink\" title=\"给 git 命令起别名\"></a>给 git 命令起别名</h2><p>简化命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global alias.&lt;handle&gt; &lt;command&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">比如：git status 改成 git st，这样可以简化命令</span><br><span class=\"line\"></span><br><span class=\"line\">git config --global alias.st status</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"存储当前的修改，但不用提交-commit\"><a href=\"#存储当前的修改，但不用提交-commit\" class=\"headerlink\" title=\"存储当前的修改，但不用提交 commit\"></a>存储当前的修改，但不用提交 commit</h2><p>详解可以参考<a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000\">廖雪峰老师的 git 教程</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"保存当前状态，包括-untracked-的文件\"><a href=\"#保存当前状态，包括-untracked-的文件\" class=\"headerlink\" title=\"保存当前状态，包括 untracked 的文件\"></a>保存当前状态，包括 untracked 的文件</h2><p>untracked 文件：新建的文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash -u</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示所有-stashes\"><a href=\"#展示所有-stashes\" class=\"headerlink\" title=\"展示所有 stashes\"></a>展示所有 stashes</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash list</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"回到某个-stash-的状态\"><a href=\"#回到某个-stash-的状态\" class=\"headerlink\" title=\"回到某个 stash 的状态\"></a>回到某个 stash 的状态</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash apply &lt;stash@&#123;n&#125;&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"回到最后一个-stash-的状态，并删除这个-stash\"><a href=\"#回到最后一个-stash-的状态，并删除这个-stash\" class=\"headerlink\" title=\"回到最后一个 stash 的状态，并删除这个 stash\"></a>回到最后一个 stash 的状态，并删除这个 stash</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash pop</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"删除所有的-stash\"><a href=\"#删除所有的-stash\" class=\"headerlink\" title=\"删除所有的 stash\"></a>删除所有的 stash</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash clear</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"从-stash-中拿出某个文件的修改\"><a href=\"#从-stash-中拿出某个文件的修改\" class=\"headerlink\" title=\"从 stash 中拿出某个文件的修改\"></a>从 stash 中拿出某个文件的修改</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout &lt;stash@&#123;n&#125;&gt; -- &lt;file-path&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示所有-tracked-的文件\"><a href=\"#展示所有-tracked-的文件\" class=\"headerlink\" title=\"展示所有 tracked 的文件\"></a>展示所有 tracked 的文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git ls-files -t</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示所有-untracked-的文件\"><a href=\"#展示所有-untracked-的文件\" class=\"headerlink\" title=\"展示所有 untracked 的文件\"></a>展示所有 untracked 的文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git ls-files --others</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示所有忽略的文件\"><a href=\"#展示所有忽略的文件\" class=\"headerlink\" title=\"展示所有忽略的文件\"></a>展示所有忽略的文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git ls-files --others -i --exclude-standard</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"强制删除-untracked-的文件\"><a href=\"#强制删除-untracked-的文件\" class=\"headerlink\" title=\"强制删除 untracked 的文件\"></a>强制删除 untracked 的文件</h2><p>可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的 untracked 文件。clean 命令，<strong>注意两点</strong>：</p>\n<ol>\n<li>clean 后，删除的文件无法找回</li>\n<li>不会影响 tracked 的文件的改动，只会删除 untracked 的文件</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clean &lt;file-name&gt; -f</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"强制删除-untracked-的目录\"><a href=\"#强制删除-untracked-的目录\" class=\"headerlink\" title=\"强制删除 untracked 的目录\"></a>强制删除 untracked 的目录</h2><p>可以用来删除新建的目录，<strong>注意</strong>:这个命令也可以用来删除 untracked 的文件。详情见上一条</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clean &lt;directory-name&gt; -df</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示简化的-commit-历史\"><a href=\"#展示简化的-commit-历史\" class=\"headerlink\" title=\"展示简化的 commit 历史\"></a>展示简化的 commit 历史</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --pretty=oneline --graph --decorate --all</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"把某一个分支导出成一个文件\"><a href=\"#把某一个分支导出成一个文件\" class=\"headerlink\" title=\"把某一个分支导出成一个文件\"></a>把某一个分支导出成一个文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git bundle create &lt;file&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"从包中导入分支\"><a href=\"#从包中导入分支\" class=\"headerlink\" title=\"从包中导入分支\"></a>从包中导入分支</h2><p>新建一个分支，分支内容就是上面 git bundle create 命令导出的内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"执行-rebase-之前自动-stash\"><a href=\"#执行-rebase-之前自动-stash\" class=\"headerlink\" title=\"执行 rebase 之前自动 stash\"></a>执行 rebase 之前自动 stash</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase --autostash</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"从远程仓库根据-ID，拉下某一状态，到本地分支\"><a href=\"#从远程仓库根据-ID，拉下某一状态，到本地分支\" class=\"headerlink\" title=\"从远程仓库根据 ID，拉下某一状态，到本地分支\"></a>从远程仓库根据 ID，拉下某一状态，到本地分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch origin pull/&lt;id&gt;/head:&lt;branch-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"详细展示一行中的修改\"><a href=\"#详细展示一行中的修改\" class=\"headerlink\" title=\"详细展示一行中的修改\"></a>详细展示一行中的修改</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff --word-diff</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"清除-gitignore-文件中记录的文件\"><a href=\"#清除-gitignore-文件中记录的文件\" class=\"headerlink\" title=\"清除 gitignore 文件中记录的文件\"></a>清除 gitignore 文件中记录的文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clean -X -f</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示所有-alias-和-configs\"><a href=\"#展示所有-alias-和-configs\" class=\"headerlink\" title=\"展示所有 alias 和 configs\"></a>展示所有 alias 和 configs</h2><p><strong>注意：</strong> config 分为：当前目录（local）和全局（golbal）的 config，默认为当前目录的 config</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --local --list (当前目录)</span><br><span class=\"line\">git config --global --list (全局)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示忽略的文件\"><a href=\"#展示忽略的文件\" class=\"headerlink\" title=\"展示忽略的文件\"></a>展示忽略的文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status --ignored</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"commit-历史中显示-Branch1-有的，但是-Branch2-没有-commit\"><a href=\"#commit-历史中显示-Branch1-有的，但是-Branch2-没有-commit\" class=\"headerlink\" title=\"commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit\"></a>commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log Branch1 ^Branch2</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"在-commit-log-中显示-GPG-签名\"><a href=\"#在-commit-log-中显示-GPG-签名\" class=\"headerlink\" title=\"在 commit log 中显示 GPG 签名\"></a>在 commit log 中显示 GPG 签名</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --show-signature</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"删除全局设置\"><a href=\"#删除全局设置\" class=\"headerlink\" title=\"删除全局设置\"></a>删除全局设置</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global --unset &lt;entry-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"新建并切换到新分支上，同时这个分支没有任何-commit\"><a href=\"#新建并切换到新分支上，同时这个分支没有任何-commit\" class=\"headerlink\" title=\"新建并切换到新分支上，同时这个分支没有任何 commit\"></a>新建并切换到新分支上，同时这个分支没有任何 commit</h2><p>相当于保存修改，但是重写 commit 历史</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout --orphan &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示任意分支某一文件的内容\"><a href=\"#展示任意分支某一文件的内容\" class=\"headerlink\" title=\"展示任意分支某一文件的内容\"></a>展示任意分支某一文件的内容</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git show &lt;branch-name&gt;:&lt;file-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"clone-下来指定的单一分支\"><a href=\"#clone-下来指定的单一分支\" class=\"headerlink\" title=\"clone 下来指定的单一分支\"></a>clone 下来指定的单一分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone -b &lt;branch-name&gt; --single-branch https://github.com/user/repo.git</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"clone-最新一次提交\"><a href=\"#clone-最新一次提交\" class=\"headerlink\" title=\"clone 最新一次提交\"></a>clone 最新一次提交</h2><p>只会 clone 最近一次提交，将减少 clone 时间</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone --depth=1 https://github.com/user/repo.git</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"忽略某个文件的改动\"><a href=\"#忽略某个文件的改动\" class=\"headerlink\" title=\"忽略某个文件的改动\"></a>忽略某个文件的改动</h2><p>关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git update-index --assume-unchanged path/to/file</span><br></pre></td></tr></table></figure>\n\n<p>恢复 track 指定文件的改动</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git update-index --no-assume-unchanged path/to/file</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"忽略文件的权限变化\"><a href=\"#忽略文件的权限变化\" class=\"headerlink\" title=\"忽略文件的权限变化\"></a>忽略文件的权限变化</h2><p>不再将文件的权限变化视作改动</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config core.fileMode false</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"以最后提交的顺序列出所有-Git-分支\"><a href=\"#以最后提交的顺序列出所有-Git-分支\" class=\"headerlink\" title=\"以最后提交的顺序列出所有 Git 分支\"></a>以最后提交的顺序列出所有 Git 分支</h2><p>最新的放在最上面</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git for-each-ref --sort=-committerdate --format=&#x27;%(refname:short)&#x27; refs/heads/</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"在-commit-log-中查找相关内容\"><a href=\"#在-commit-log-中查找相关内容\" class=\"headerlink\" title=\"在 commit log 中查找相关内容\"></a>在 commit log 中查找相关内容</h2><p>通过 grep 查找，given-text：所需要查找的字段</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --all --grep=&#x27;&lt;given-text&gt;&#x27;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"把暂存区的指定-file-放到工作区中\"><a href=\"#把暂存区的指定-file-放到工作区中\" class=\"headerlink\" title=\"把暂存区的指定 file 放到工作区中\"></a>把暂存区的指定 file 放到工作区中</h2><p>不添加参数，默认是 -mixed</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset &lt;file-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"强制推送\"><a href=\"#强制推送\" class=\"headerlink\" title=\"强制推送\"></a>强制推送</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -f &lt;remote-name&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>统一概念：</p>\n<ul>\n<li>工作区：改动（增删文件和内容）</li>\n<li>暂存区：输入命令：git add 改动的文件名，此次改动就放到了 ‘暂存区’</li>\n<li>本地仓库(简称：本地)：输入命令：git commit 此次修改的描述，此次改动就放到了本地仓库，每个 commit，我叫它为一个版本。</li>\n<li>远程仓库(简称：远程)：输入命令：git push 远程仓库，此次改动就放到了远程仓库（GitHub 等)</li>\n<li>commit-id：输出命令：git log，最上面那行 commit xxxxxx，后面的字符串就是 commit-id</li>\n</ul>\n<p>下面，就是你在找的 Git 命令速查表。</p>\n<h2 id=\"展示帮助信息\"><a href=\"#展示帮助信息\" class=\"headerlink\" title=\"展示帮助信息\"></a>展示帮助信息</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git help -g</span><br></pre></td></tr></table></figure>\n\n<p>The command output as below:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The common Git guides are:</span><br><span class=\"line\">   attributes          Defining attributes per path</span><br><span class=\"line\">   cli                 Git command-line interface and conventions</span><br><span class=\"line\">   core-tutorial       A Git core tutorial for developers</span><br><span class=\"line\">   cvs-migration       Git for CVS users</span><br><span class=\"line\">   diffcore            Tweaking diff output</span><br><span class=\"line\">   everyday            A useful minimum set of commands for Everyday Git</span><br><span class=\"line\">   glossary            A Git Glossary</span><br><span class=\"line\">   hooks               Hooks used by Git</span><br><span class=\"line\">   ignore              Specifies intentionally untracked files to ignore</span><br><span class=\"line\">   modules             Defining submodule properties</span><br><span class=\"line\">   namespaces          Git namespaces</span><br><span class=\"line\">   repository-layout    Git Repository Layout</span><br><span class=\"line\">   revisions           Specifying revisions and ranges for Git</span><br><span class=\"line\">   tutorial            A tutorial introduction to Git</span><br><span class=\"line\">   tutorial-2          A tutorial introduction to Git: part two</span><br><span class=\"line\">   workflows           An overview of recommended workflows with Git</span><br><span class=\"line\"></span><br><span class=\"line\">&#x27;git help -a&#x27; and &#x27;git help -g&#x27; list available subcommands and some concept guides. See &#x27;git help &lt;command&gt;&#x27; or &#x27;git help &lt;concept&gt;&#x27; to read about a specific subcommand or concept.</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"回到远程仓库的状态\"><a href=\"#回到远程仓库的状态\" class=\"headerlink\" title=\"回到远程仓库的状态\"></a>回到远程仓库的状态</h2><p>抛弃本地所有的修改，回到远程仓库的状态。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch --all &amp;&amp; git reset --hard origin/master</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"重设第一个-commit\"><a href=\"#重设第一个-commit\" class=\"headerlink\" title=\"重设第一个 commit\"></a>重设第一个 commit</h2><p>也就是把所有的改动都重新放回工作区，并<strong>清空所有的 commit</strong>，这样就可以重新提交第一个 commit 了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git update-ref -d HEAD</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查看冲突文件列表\"><a href=\"#查看冲突文件列表\" class=\"headerlink\" title=\"查看冲突文件列表\"></a>查看冲突文件列表</h2><p>展示工作区的冲突文件列表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff --name-only --diff-filter=U</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示工作区和暂存区的不同\"><a href=\"#展示工作区和暂存区的不同\" class=\"headerlink\" title=\"展示工作区和暂存区的不同\"></a>展示工作区和暂存区的不同</h2><p>输出<strong>工作区</strong>和<strong>暂存区</strong>的 different (不同)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff</span><br></pre></td></tr></table></figure>\n\n<p>还可以展示本地仓库中任意两个 commit 之间的文件变动：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff &lt;commit-id&gt; &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示暂存区和最近版本的不同\"><a href=\"#展示暂存区和最近版本的不同\" class=\"headerlink\" title=\"展示暂存区和最近版本的不同\"></a>展示暂存区和最近版本的不同</h2><p>输出<strong>暂存区</strong>和本地最近的版本 (commit) 的 different (不同)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff --cached</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示暂存区、工作区和最近版本的不同\"><a href=\"#展示暂存区、工作区和最近版本的不同\" class=\"headerlink\" title=\"展示暂存区、工作区和最近版本的不同\"></a>展示暂存区、工作区和最近版本的不同</h2><p>输出<strong>工作区</strong>、<strong>暂存区</strong> 和本地最近的版本 (commit) 的 different (不同)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff HEAD</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"快速切换到上一个分支\"><a href=\"#快速切换到上一个分支\" class=\"headerlink\" title=\"快速切换到上一个分支\"></a>快速切换到上一个分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"删除已经合并到-master-的分支\"><a href=\"#删除已经合并到-master-的分支\" class=\"headerlink\" title=\"删除已经合并到 master 的分支\"></a>删除已经合并到 master 的分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --merged master | grep -v &#x27;^\\*\\|  master&#x27; | xargs -n 1 git branch -d</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示本地分支关联远程仓库的情况\"><a href=\"#展示本地分支关联远程仓库的情况\" class=\"headerlink\" title=\"展示本地分支关联远程仓库的情况\"></a>展示本地分支关联远程仓库的情况</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -vv</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"关联远程分支\"><a href=\"#关联远程分支\" class=\"headerlink\" title=\"关联远程分支\"></a>关联远程分支</h2><p>关联之后，git branch -vv 就可以展示关联的远程分支名了，同时推送到远程仓库直接：git push，不需要指定远程仓库了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -u origin/mybranch</span><br></pre></td></tr></table></figure>\n\n<p>或者在 push 时加上 -u 参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin/mybranch -u</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"列出所有远程分支\"><a href=\"#列出所有远程分支\" class=\"headerlink\" title=\"列出所有远程分支\"></a>列出所有远程分支</h2><p>-r 参数相当于：remote</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -r</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"列出本地和远程分支\"><a href=\"#列出本地和远程分支\" class=\"headerlink\" title=\"列出本地和远程分支\"></a>列出本地和远程分支</h2><p>-a 参数相当于：all</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -a</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查看远程分支和本地分支的对应关系\"><a href=\"#查看远程分支和本地分支的对应关系\" class=\"headerlink\" title=\"查看远程分支和本地分支的对应关系\"></a>查看远程分支和本地分支的对应关系</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote show origin</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"远程删除了分支本地也想删除\"><a href=\"#远程删除了分支本地也想删除\" class=\"headerlink\" title=\"远程删除了分支本地也想删除\"></a>远程删除了分支本地也想删除</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote prune origin</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"创建并切换到本地分支\"><a href=\"#创建并切换到本地分支\" class=\"headerlink\" title=\"创建并切换到本地分支\"></a>创建并切换到本地分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"从远程分支中创建并切换到本地分支\"><a href=\"#从远程分支中创建并切换到本地分支\" class=\"headerlink\" title=\"从远程分支中创建并切换到本地分支\"></a>从远程分支中创建并切换到本地分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"删除本地分支\"><a href=\"#删除本地分支\" class=\"headerlink\" title=\"删除本地分支\"></a>删除本地分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d &lt;local-branchname&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"删除远程分支\"><a href=\"#删除远程分支\" class=\"headerlink\" title=\"删除远程分支\"></a>删除远程分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin --delete &lt;remote-branchname&gt;</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin :&lt;remote-branchname&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"重命名本地分支\"><a href=\"#重命名本地分支\" class=\"headerlink\" title=\"重命名本地分支\"></a>重命名本地分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -m &lt;new-branch-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查看标签\"><a href=\"#查看标签\" class=\"headerlink\" title=\"查看标签\"></a>查看标签</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag</span><br></pre></td></tr></table></figure>\n\n<p>展示当前分支的最近的 tag</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git describe --tags --abbrev=0</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查看标签详细信息\"><a href=\"#查看标签详细信息\" class=\"headerlink\" title=\"查看标签详细信息\"></a>查看标签详细信息</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag -ln</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"本地创建标签\"><a href=\"#本地创建标签\" class=\"headerlink\" title=\"本地创建标签\"></a>本地创建标签</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag &lt;version-number&gt;</span><br></pre></td></tr></table></figure>\n\n<p>默认 tag 是打在最近的一次 commit 上，如果需要指定 commit 打 tag：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -a &lt;version-number&gt; -m &quot;v1.0 发布(描述)&quot; &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"推送标签到远程仓库\"><a href=\"#推送标签到远程仓库\" class=\"headerlink\" title=\"推送标签到远程仓库\"></a>推送标签到远程仓库</h2><p>首先要保证本地创建好了标签才可以推送标签到远程仓库：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin &lt;local-version-number&gt;</span><br></pre></td></tr></table></figure>\n\n<p>一次性推送所有标签，同步到远程仓库：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin --tags</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"删除本地标签\"><a href=\"#删除本地标签\" class=\"headerlink\" title=\"删除本地标签\"></a>删除本地标签</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag -d &lt;tag-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"删除远程标签\"><a href=\"#删除远程标签\" class=\"headerlink\" title=\"删除远程标签\"></a>删除远程标签</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin --delete tag &lt;tagname&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"切回到某个标签\"><a href=\"#切回到某个标签\" class=\"headerlink\" title=\"切回到某个标签\"></a>切回到某个标签</h2><p>一般上线之前都会打 tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b branch_name tag_name</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"放弃工作区的修改\"><a href=\"#放弃工作区的修改\" class=\"headerlink\" title=\"放弃工作区的修改\"></a>放弃工作区的修改</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout &lt;file-name&gt;</span><br></pre></td></tr></table></figure>\n\n<p>放弃所有修改：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout .</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"恢复删除的文件\"><a href=\"#恢复删除的文件\" class=\"headerlink\" title=\"恢复删除的文件\"></a>恢复删除的文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rev-list -n 1 HEAD -- &lt;file_path&gt; #得到 deleting_commit</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout &lt;deleting_commit&gt;^ -- &lt;file_path&gt; #回到删除文件 deleting_commit 之前的状态</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"以新增一个-commit-的方式还原某一个-commit-的修改\"><a href=\"#以新增一个-commit-的方式还原某一个-commit-的修改\" class=\"headerlink\" title=\"以新增一个 commit 的方式还原某一个 commit 的修改\"></a>以新增一个 commit 的方式还原某一个 commit 的修改</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git revert &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"回到某个-commit-的状态，并删除后面的-commit\"><a href=\"#回到某个-commit-的状态，并删除后面的-commit\" class=\"headerlink\" title=\"回到某个 commit 的状态，并删除后面的 commit\"></a>回到某个 commit 的状态，并删除后面的 commit</h2><p>和 revert 的区别：reset 命令会抹去某个 commit id 之后的所有 commit</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset &lt;commit-id&gt;  #默认就是-mixed参数。</span><br><span class=\"line\"></span><br><span class=\"line\">git reset --mixed HEAD^  #回退至上个版本，它将重置HEAD到另外一个commit,并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。</span><br><span class=\"line\"></span><br><span class=\"line\">git reset --soft HEAD~3  #回退至三个版本之前，只回退了commit的信息，暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可  </span><br><span class=\"line\"></span><br><span class=\"line\">git reset --hard &lt;commit-id&gt;  #彻底回退到指定commit-id的状态，暂存区和工作区也会变为指定commit-id版本的内容</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"修改上一个-commit-的描述\"><a href=\"#修改上一个-commit-的描述\" class=\"headerlink\" title=\"修改上一个 commit 的描述\"></a>修改上一个 commit 的描述</h2><p>如果暂存区有改动，同时也会将暂存区的改动提交到上一个 commit</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查看-commit-历史\"><a href=\"#查看-commit-历史\" class=\"headerlink\" title=\"查看 commit 历史\"></a>查看 commit 历史</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查看某段代码是谁写的\"><a href=\"#查看某段代码是谁写的\" class=\"headerlink\" title=\"查看某段代码是谁写的\"></a>查看某段代码是谁写的</h2><p>blame 的意思为‘责怪’，你懂的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git blame &lt;file-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"显示本地更新过-HEAD-的-git-命令记录\"><a href=\"#显示本地更新过-HEAD-的-git-命令记录\" class=\"headerlink\" title=\"显示本地更新过 HEAD 的 git 命令记录\"></a>显示本地更新过 HEAD 的 git 命令记录</h2><p>每次更新了 HEAD 的 git 命令比如 commit、amend、cherry-pick、reset、revert 等都会被记录下来（不限分支），就像 shell 的 history 一样。 这样你可以 reset 到任何一次更新了 HEAD 的操作之后，而不仅仅是回到当前分支下的某个 commit 之后的状态。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reflog</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"修改作者名\"><a href=\"#修改作者名\" class=\"headerlink\" title=\"修改作者名\"></a>修改作者名</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend --author=&#x27;Author Name &lt;email@address.com&gt;&#x27;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"修改远程仓库的-url\"><a href=\"#修改远程仓库的-url\" class=\"headerlink\" title=\"修改远程仓库的 url\"></a>修改远程仓库的 url</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote set-url origin &lt;URL&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"增加远程仓库\"><a href=\"#增加远程仓库\" class=\"headerlink\" title=\"增加远程仓库\"></a>增加远程仓库</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin &lt;remote-url&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"列出所有远程仓库\"><a href=\"#列出所有远程仓库\" class=\"headerlink\" title=\"列出所有远程仓库\"></a>列出所有远程仓库</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查看两个星期内的改动\"><a href=\"#查看两个星期内的改动\" class=\"headerlink\" title=\"查看两个星期内的改动\"></a>查看两个星期内的改动</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git whatchanged --since=&#x27;2 weeks ago&#x27;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"把-A-分支的某一个-commit，放到-B-分支上\"><a href=\"#把-A-分支的某一个-commit，放到-B-分支上\" class=\"headerlink\" title=\"把 A 分支的某一个 commit，放到 B 分支上\"></a>把 A 分支的某一个 commit，放到 B 分支上</h2><p>这个过程需要 cherry-pick 命令，<a href=\"http://sg552.iteye.com/blog/1300713#bc2367928\">参考</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"给-git-命令起别名\"><a href=\"#给-git-命令起别名\" class=\"headerlink\" title=\"给 git 命令起别名\"></a>给 git 命令起别名</h2><p>简化命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global alias.&lt;handle&gt; &lt;command&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">比如：git status 改成 git st，这样可以简化命令</span><br><span class=\"line\"></span><br><span class=\"line\">git config --global alias.st status</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"存储当前的修改，但不用提交-commit\"><a href=\"#存储当前的修改，但不用提交-commit\" class=\"headerlink\" title=\"存储当前的修改，但不用提交 commit\"></a>存储当前的修改，但不用提交 commit</h2><p>详解可以参考<a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000\">廖雪峰老师的 git 教程</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"保存当前状态，包括-untracked-的文件\"><a href=\"#保存当前状态，包括-untracked-的文件\" class=\"headerlink\" title=\"保存当前状态，包括 untracked 的文件\"></a>保存当前状态，包括 untracked 的文件</h2><p>untracked 文件：新建的文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash -u</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示所有-stashes\"><a href=\"#展示所有-stashes\" class=\"headerlink\" title=\"展示所有 stashes\"></a>展示所有 stashes</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash list</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"回到某个-stash-的状态\"><a href=\"#回到某个-stash-的状态\" class=\"headerlink\" title=\"回到某个 stash 的状态\"></a>回到某个 stash 的状态</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash apply &lt;stash@&#123;n&#125;&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"回到最后一个-stash-的状态，并删除这个-stash\"><a href=\"#回到最后一个-stash-的状态，并删除这个-stash\" class=\"headerlink\" title=\"回到最后一个 stash 的状态，并删除这个 stash\"></a>回到最后一个 stash 的状态，并删除这个 stash</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash pop</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"删除所有的-stash\"><a href=\"#删除所有的-stash\" class=\"headerlink\" title=\"删除所有的 stash\"></a>删除所有的 stash</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash clear</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"从-stash-中拿出某个文件的修改\"><a href=\"#从-stash-中拿出某个文件的修改\" class=\"headerlink\" title=\"从 stash 中拿出某个文件的修改\"></a>从 stash 中拿出某个文件的修改</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout &lt;stash@&#123;n&#125;&gt; -- &lt;file-path&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示所有-tracked-的文件\"><a href=\"#展示所有-tracked-的文件\" class=\"headerlink\" title=\"展示所有 tracked 的文件\"></a>展示所有 tracked 的文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git ls-files -t</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示所有-untracked-的文件\"><a href=\"#展示所有-untracked-的文件\" class=\"headerlink\" title=\"展示所有 untracked 的文件\"></a>展示所有 untracked 的文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git ls-files --others</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示所有忽略的文件\"><a href=\"#展示所有忽略的文件\" class=\"headerlink\" title=\"展示所有忽略的文件\"></a>展示所有忽略的文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git ls-files --others -i --exclude-standard</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"强制删除-untracked-的文件\"><a href=\"#强制删除-untracked-的文件\" class=\"headerlink\" title=\"强制删除 untracked 的文件\"></a>强制删除 untracked 的文件</h2><p>可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的 untracked 文件。clean 命令，<strong>注意两点</strong>：</p>\n<ol>\n<li>clean 后，删除的文件无法找回</li>\n<li>不会影响 tracked 的文件的改动，只会删除 untracked 的文件</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clean &lt;file-name&gt; -f</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"强制删除-untracked-的目录\"><a href=\"#强制删除-untracked-的目录\" class=\"headerlink\" title=\"强制删除 untracked 的目录\"></a>强制删除 untracked 的目录</h2><p>可以用来删除新建的目录，<strong>注意</strong>:这个命令也可以用来删除 untracked 的文件。详情见上一条</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clean &lt;directory-name&gt; -df</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示简化的-commit-历史\"><a href=\"#展示简化的-commit-历史\" class=\"headerlink\" title=\"展示简化的 commit 历史\"></a>展示简化的 commit 历史</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --pretty=oneline --graph --decorate --all</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"把某一个分支导出成一个文件\"><a href=\"#把某一个分支导出成一个文件\" class=\"headerlink\" title=\"把某一个分支导出成一个文件\"></a>把某一个分支导出成一个文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git bundle create &lt;file&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"从包中导入分支\"><a href=\"#从包中导入分支\" class=\"headerlink\" title=\"从包中导入分支\"></a>从包中导入分支</h2><p>新建一个分支，分支内容就是上面 git bundle create 命令导出的内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"执行-rebase-之前自动-stash\"><a href=\"#执行-rebase-之前自动-stash\" class=\"headerlink\" title=\"执行 rebase 之前自动 stash\"></a>执行 rebase 之前自动 stash</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase --autostash</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"从远程仓库根据-ID，拉下某一状态，到本地分支\"><a href=\"#从远程仓库根据-ID，拉下某一状态，到本地分支\" class=\"headerlink\" title=\"从远程仓库根据 ID，拉下某一状态，到本地分支\"></a>从远程仓库根据 ID，拉下某一状态，到本地分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch origin pull/&lt;id&gt;/head:&lt;branch-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"详细展示一行中的修改\"><a href=\"#详细展示一行中的修改\" class=\"headerlink\" title=\"详细展示一行中的修改\"></a>详细展示一行中的修改</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff --word-diff</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"清除-gitignore-文件中记录的文件\"><a href=\"#清除-gitignore-文件中记录的文件\" class=\"headerlink\" title=\"清除 gitignore 文件中记录的文件\"></a>清除 gitignore 文件中记录的文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clean -X -f</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示所有-alias-和-configs\"><a href=\"#展示所有-alias-和-configs\" class=\"headerlink\" title=\"展示所有 alias 和 configs\"></a>展示所有 alias 和 configs</h2><p><strong>注意：</strong> config 分为：当前目录（local）和全局（golbal）的 config，默认为当前目录的 config</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --local --list (当前目录)</span><br><span class=\"line\">git config --global --list (全局)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示忽略的文件\"><a href=\"#展示忽略的文件\" class=\"headerlink\" title=\"展示忽略的文件\"></a>展示忽略的文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status --ignored</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"commit-历史中显示-Branch1-有的，但是-Branch2-没有-commit\"><a href=\"#commit-历史中显示-Branch1-有的，但是-Branch2-没有-commit\" class=\"headerlink\" title=\"commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit\"></a>commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log Branch1 ^Branch2</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"在-commit-log-中显示-GPG-签名\"><a href=\"#在-commit-log-中显示-GPG-签名\" class=\"headerlink\" title=\"在 commit log 中显示 GPG 签名\"></a>在 commit log 中显示 GPG 签名</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --show-signature</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"删除全局设置\"><a href=\"#删除全局设置\" class=\"headerlink\" title=\"删除全局设置\"></a>删除全局设置</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global --unset &lt;entry-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"新建并切换到新分支上，同时这个分支没有任何-commit\"><a href=\"#新建并切换到新分支上，同时这个分支没有任何-commit\" class=\"headerlink\" title=\"新建并切换到新分支上，同时这个分支没有任何 commit\"></a>新建并切换到新分支上，同时这个分支没有任何 commit</h2><p>相当于保存修改，但是重写 commit 历史</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout --orphan &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"展示任意分支某一文件的内容\"><a href=\"#展示任意分支某一文件的内容\" class=\"headerlink\" title=\"展示任意分支某一文件的内容\"></a>展示任意分支某一文件的内容</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git show &lt;branch-name&gt;:&lt;file-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"clone-下来指定的单一分支\"><a href=\"#clone-下来指定的单一分支\" class=\"headerlink\" title=\"clone 下来指定的单一分支\"></a>clone 下来指定的单一分支</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone -b &lt;branch-name&gt; --single-branch https://github.com/user/repo.git</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"clone-最新一次提交\"><a href=\"#clone-最新一次提交\" class=\"headerlink\" title=\"clone 最新一次提交\"></a>clone 最新一次提交</h2><p>只会 clone 最近一次提交，将减少 clone 时间</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone --depth=1 https://github.com/user/repo.git</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"忽略某个文件的改动\"><a href=\"#忽略某个文件的改动\" class=\"headerlink\" title=\"忽略某个文件的改动\"></a>忽略某个文件的改动</h2><p>关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git update-index --assume-unchanged path/to/file</span><br></pre></td></tr></table></figure>\n\n<p>恢复 track 指定文件的改动</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git update-index --no-assume-unchanged path/to/file</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"忽略文件的权限变化\"><a href=\"#忽略文件的权限变化\" class=\"headerlink\" title=\"忽略文件的权限变化\"></a>忽略文件的权限变化</h2><p>不再将文件的权限变化视作改动</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config core.fileMode false</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"以最后提交的顺序列出所有-Git-分支\"><a href=\"#以最后提交的顺序列出所有-Git-分支\" class=\"headerlink\" title=\"以最后提交的顺序列出所有 Git 分支\"></a>以最后提交的顺序列出所有 Git 分支</h2><p>最新的放在最上面</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git for-each-ref --sort=-committerdate --format=&#x27;%(refname:short)&#x27; refs/heads/</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"在-commit-log-中查找相关内容\"><a href=\"#在-commit-log-中查找相关内容\" class=\"headerlink\" title=\"在 commit log 中查找相关内容\"></a>在 commit log 中查找相关内容</h2><p>通过 grep 查找，given-text：所需要查找的字段</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --all --grep=&#x27;&lt;given-text&gt;&#x27;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"把暂存区的指定-file-放到工作区中\"><a href=\"#把暂存区的指定-file-放到工作区中\" class=\"headerlink\" title=\"把暂存区的指定 file 放到工作区中\"></a>把暂存区的指定 file 放到工作区中</h2><p>不添加参数，默认是 -mixed</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset &lt;file-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"强制推送\"><a href=\"#强制推送\" class=\"headerlink\" title=\"强制推送\"></a>强制推送</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -f &lt;remote-name&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>\n"},{"_content":"# Ubuntu20.04版本源：\n\n## deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse\n## deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse\n\n## deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse\n## deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse\n\n## deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse\n## deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse\n\n## deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\n## deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\n\n### ================================================================\n\n# Ubuntu22.04版本源：\n\n## deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse\n## deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse\n\n## deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse\n## deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse\n\n## deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse\n## deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse\n\n## deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse\n## deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse\n\n## deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse\n## deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse\n","source":"_posts/2023-06-14-ubuntu-source-list.md","raw":"# Ubuntu20.04版本源：\n\n## deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse\n## deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse\n\n## deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse\n## deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse\n\n## deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse\n## deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse\n\n## deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\n## deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\n\n### ================================================================\n\n# Ubuntu22.04版本源：\n\n## deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse\n## deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse\n\n## deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse\n## deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse\n\n## deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse\n## deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse\n\n## deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse\n## deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse\n\n## deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse\n## deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse\n","slug":"2023-06-14-ubuntu-source-list","published":1,"date":"2023-12-15T02:31:42.231Z","updated":"2023-12-15T02:31:42.239Z","_id":"clq60jow9000a4zgs04lo4knk","title":"","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Ubuntu20-04版本源：\"><a href=\"#Ubuntu20-04版本源：\" class=\"headerlink\" title=\"Ubuntu20.04版本源：\"></a>Ubuntu20.04版本源：</h1><h2 id=\"deb-http-mirrors-aliyun-com-ubuntu-focal-main-restricted-universe-multiverse\"><a href=\"#deb-http-mirrors-aliyun-com-ubuntu-focal-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse\"></a>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> focal main restricted universe multiverse</h2><h2 id=\"deb-src-http-mirrors-aliyun-com-ubuntu-focal-main-restricted-universe-multiverse\"><a href=\"#deb-src-http-mirrors-aliyun-com-ubuntu-focal-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse\"></a>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> focal main restricted universe multiverse</h2><h2 id=\"deb-http-mirrors-aliyun-com-ubuntu-focal-security-main-restricted-universe-multiverse\"><a href=\"#deb-http-mirrors-aliyun-com-ubuntu-focal-security-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse\"></a>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> focal-security main restricted universe multiverse</h2><h2 id=\"deb-src-http-mirrors-aliyun-com-ubuntu-focal-security-main-restricted-universe-multiverse\"><a href=\"#deb-src-http-mirrors-aliyun-com-ubuntu-focal-security-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse\"></a>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> focal-security main restricted universe multiverse</h2><h2 id=\"deb-http-mirrors-aliyun-com-ubuntu-focal-updates-main-restricted-universe-multiverse\"><a href=\"#deb-http-mirrors-aliyun-com-ubuntu-focal-updates-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse\"></a>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> focal-updates main restricted universe multiverse</h2><h2 id=\"deb-src-http-mirrors-aliyun-com-ubuntu-focal-updates-main-restricted-universe-multiverse\"><a href=\"#deb-src-http-mirrors-aliyun-com-ubuntu-focal-updates-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse\"></a>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> focal-updates main restricted universe multiverse</h2><h2 id=\"deb-http-mirrors-aliyun-com-ubuntu-focal-backports-main-restricted-universe-multiverse\"><a href=\"#deb-http-mirrors-aliyun-com-ubuntu-focal-backports-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\"></a>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> focal-backports main restricted universe multiverse</h2><h2 id=\"deb-src-http-mirrors-aliyun-com-ubuntu-focal-backports-main-restricted-universe-multiverse\"><a href=\"#deb-src-http-mirrors-aliyun-com-ubuntu-focal-backports-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\"></a>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> focal-backports main restricted universe multiverse</h2><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\"></a>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</h3><h1 id=\"Ubuntu22-04版本源：\"><a href=\"#Ubuntu22-04版本源：\" class=\"headerlink\" title=\"Ubuntu22.04版本源：\"></a>Ubuntu22.04版本源：</h1><h2 id=\"deb-http-mirrors-aliyun-com-ubuntu-jammy-main-restricted-universe-multiverse\"><a href=\"#deb-http-mirrors-aliyun-com-ubuntu-jammy-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse\"></a>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy main restricted universe multiverse</h2><h2 id=\"deb-src-http-mirrors-aliyun-com-ubuntu-jammy-main-restricted-universe-multiverse\"><a href=\"#deb-src-http-mirrors-aliyun-com-ubuntu-jammy-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse\"></a>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy main restricted universe multiverse</h2><h2 id=\"deb-http-mirrors-aliyun-com-ubuntu-jammy-security-main-restricted-universe-multiverse\"><a href=\"#deb-http-mirrors-aliyun-com-ubuntu-jammy-security-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse\"></a>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-security main restricted universe multiverse</h2><h2 id=\"deb-src-http-mirrors-aliyun-com-ubuntu-jammy-security-main-restricted-universe-multiverse\"><a href=\"#deb-src-http-mirrors-aliyun-com-ubuntu-jammy-security-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse\"></a>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-security main restricted universe multiverse</h2><h2 id=\"deb-http-mirrors-aliyun-com-ubuntu-jammy-updates-main-restricted-universe-multiverse\"><a href=\"#deb-http-mirrors-aliyun-com-ubuntu-jammy-updates-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse\"></a>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-updates main restricted universe multiverse</h2><h2 id=\"deb-src-http-mirrors-aliyun-com-ubuntu-jammy-updates-main-restricted-universe-multiverse\"><a href=\"#deb-src-http-mirrors-aliyun-com-ubuntu-jammy-updates-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse\"></a>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-updates main restricted universe multiverse</h2><h2 id=\"deb-http-mirrors-aliyun-com-ubuntu-jammy-proposed-main-restricted-universe-multiverse\"><a href=\"#deb-http-mirrors-aliyun-com-ubuntu-jammy-proposed-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse\"></a>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-proposed main restricted universe multiverse</h2><h2 id=\"deb-src-http-mirrors-aliyun-com-ubuntu-jammy-proposed-main-restricted-universe-multiverse\"><a href=\"#deb-src-http-mirrors-aliyun-com-ubuntu-jammy-proposed-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse\"></a>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-proposed main restricted universe multiverse</h2><h2 id=\"deb-http-mirrors-aliyun-com-ubuntu-jammy-backports-main-restricted-universe-multiverse\"><a href=\"#deb-http-mirrors-aliyun-com-ubuntu-jammy-backports-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse\"></a>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-backports main restricted universe multiverse</h2><h2 id=\"deb-src-http-mirrors-aliyun-com-ubuntu-jammy-backports-main-restricted-universe-multiverse\"><a href=\"#deb-src-http-mirrors-aliyun-com-ubuntu-jammy-backports-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse\"></a>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-backports main restricted universe multiverse</h2>","excerpt":"","more":"<h1 id=\"Ubuntu20-04版本源：\"><a href=\"#Ubuntu20-04版本源：\" class=\"headerlink\" title=\"Ubuntu20.04版本源：\"></a>Ubuntu20.04版本源：</h1><h2 id=\"deb-http-mirrors-aliyun-com-ubuntu-focal-main-restricted-universe-multiverse\"><a href=\"#deb-http-mirrors-aliyun-com-ubuntu-focal-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse\"></a>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> focal main restricted universe multiverse</h2><h2 id=\"deb-src-http-mirrors-aliyun-com-ubuntu-focal-main-restricted-universe-multiverse\"><a href=\"#deb-src-http-mirrors-aliyun-com-ubuntu-focal-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse\"></a>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> focal main restricted universe multiverse</h2><h2 id=\"deb-http-mirrors-aliyun-com-ubuntu-focal-security-main-restricted-universe-multiverse\"><a href=\"#deb-http-mirrors-aliyun-com-ubuntu-focal-security-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse\"></a>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> focal-security main restricted universe multiverse</h2><h2 id=\"deb-src-http-mirrors-aliyun-com-ubuntu-focal-security-main-restricted-universe-multiverse\"><a href=\"#deb-src-http-mirrors-aliyun-com-ubuntu-focal-security-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse\"></a>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> focal-security main restricted universe multiverse</h2><h2 id=\"deb-http-mirrors-aliyun-com-ubuntu-focal-updates-main-restricted-universe-multiverse\"><a href=\"#deb-http-mirrors-aliyun-com-ubuntu-focal-updates-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse\"></a>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> focal-updates main restricted universe multiverse</h2><h2 id=\"deb-src-http-mirrors-aliyun-com-ubuntu-focal-updates-main-restricted-universe-multiverse\"><a href=\"#deb-src-http-mirrors-aliyun-com-ubuntu-focal-updates-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse\"></a>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> focal-updates main restricted universe multiverse</h2><h2 id=\"deb-http-mirrors-aliyun-com-ubuntu-focal-backports-main-restricted-universe-multiverse\"><a href=\"#deb-http-mirrors-aliyun-com-ubuntu-focal-backports-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\"></a>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> focal-backports main restricted universe multiverse</h2><h2 id=\"deb-src-http-mirrors-aliyun-com-ubuntu-focal-backports-main-restricted-universe-multiverse\"><a href=\"#deb-src-http-mirrors-aliyun-com-ubuntu-focal-backports-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\"></a>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> focal-backports main restricted universe multiverse</h2><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\"></a>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</h3><h1 id=\"Ubuntu22-04版本源：\"><a href=\"#Ubuntu22-04版本源：\" class=\"headerlink\" title=\"Ubuntu22.04版本源：\"></a>Ubuntu22.04版本源：</h1><h2 id=\"deb-http-mirrors-aliyun-com-ubuntu-jammy-main-restricted-universe-multiverse\"><a href=\"#deb-http-mirrors-aliyun-com-ubuntu-jammy-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse\"></a>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy main restricted universe multiverse</h2><h2 id=\"deb-src-http-mirrors-aliyun-com-ubuntu-jammy-main-restricted-universe-multiverse\"><a href=\"#deb-src-http-mirrors-aliyun-com-ubuntu-jammy-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse\"></a>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy main restricted universe multiverse</h2><h2 id=\"deb-http-mirrors-aliyun-com-ubuntu-jammy-security-main-restricted-universe-multiverse\"><a href=\"#deb-http-mirrors-aliyun-com-ubuntu-jammy-security-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse\"></a>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-security main restricted universe multiverse</h2><h2 id=\"deb-src-http-mirrors-aliyun-com-ubuntu-jammy-security-main-restricted-universe-multiverse\"><a href=\"#deb-src-http-mirrors-aliyun-com-ubuntu-jammy-security-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse\"></a>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-security main restricted universe multiverse</h2><h2 id=\"deb-http-mirrors-aliyun-com-ubuntu-jammy-updates-main-restricted-universe-multiverse\"><a href=\"#deb-http-mirrors-aliyun-com-ubuntu-jammy-updates-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse\"></a>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-updates main restricted universe multiverse</h2><h2 id=\"deb-src-http-mirrors-aliyun-com-ubuntu-jammy-updates-main-restricted-universe-multiverse\"><a href=\"#deb-src-http-mirrors-aliyun-com-ubuntu-jammy-updates-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse\"></a>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-updates main restricted universe multiverse</h2><h2 id=\"deb-http-mirrors-aliyun-com-ubuntu-jammy-proposed-main-restricted-universe-multiverse\"><a href=\"#deb-http-mirrors-aliyun-com-ubuntu-jammy-proposed-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse\"></a>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-proposed main restricted universe multiverse</h2><h2 id=\"deb-src-http-mirrors-aliyun-com-ubuntu-jammy-proposed-main-restricted-universe-multiverse\"><a href=\"#deb-src-http-mirrors-aliyun-com-ubuntu-jammy-proposed-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse\"></a>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-proposed main restricted universe multiverse</h2><h2 id=\"deb-http-mirrors-aliyun-com-ubuntu-jammy-backports-main-restricted-universe-multiverse\"><a href=\"#deb-http-mirrors-aliyun-com-ubuntu-jammy-backports-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse\"></a>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-backports main restricted universe multiverse</h2><h2 id=\"deb-src-http-mirrors-aliyun-com-ubuntu-jammy-backports-main-restricted-universe-multiverse\"><a href=\"#deb-src-http-mirrors-aliyun-com-ubuntu-jammy-backports-main-restricted-universe-multiverse\" class=\"headerlink\" title=\"deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse\"></a>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-backports main restricted universe multiverse</h2>"},{"_content":"## 进入vi\n\n**vi filename**     打开或新建文档，并将光标置于第一行行首\n\n**vi +n filename**     打开文件，并将光标置于第n行首\n\n**vi + filename**     打开文件，并将光标置于最后一行首\n\n**vi +/pattern filename**     打开文件，并将光标置于第一个与pattern匹配的串处\n\n**vi -r filename**     在上次正用vi编辑时发生系统崩溃，恢复filename\n\n**vi filename....filename**     打开多个文件，依次进行编辑\n\n## 2保存退出\n\n**w**    保存当前文件\n\n**w /tmp1**     另存为/tmp1\n\n**20,59w /tmp1**    仅将20-59行之间的内存另存为/tmp1\n\n**x 或 wq**    保存退出\n\n**q**     退出vi\n\n**q!**    退出不保存  >\n\n**!command**    执行shell命令command\n\n**n1,n2 w !command**    将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入\n\n**r !command**   将命令command的输出结果放到当前行\n\n**w !sudo tee %**   保存没权限时，可获取权限再保存\n\n## 3光标移动\n\n**h**    光标左移一个字符\n\n**l**    光标右移一个字符\n\n**space**   光标右移一个字符\n\n**Backspace**   光标左移一个字符\n\n**k** 或 **Ctrl+p**    光标上移一行\n\n**j** 或 **Ctrl+n**    光标下移一行\n\n**Enter**   光标下移一行\n\n**w** 或 **W**   光标右移一个字至字首\n\n**b** 或 **B**   光标左移一个字至字首\n\n**e** 或 **E**   光标右移一个字至字尾\n\n**)**   光标移至句尾\n\n**(**   光标移至句首\n\n**}**   光标移至段落开头\n\n**{**   光标移至段落结尾\n\n**nG**   光标移至第n行首\n\n**n+**   光标下移n行\n\n**n-**   光标上移n行\n\n**n$**   光标移至第n行尾\n\n**H**   光标移至屏幕顶行\n\n**M**   光标移至屏幕中间行\n\n**L**   光标移至屏幕最后行\n\n**0**   （注意是数字零）光标移至当前行首\n\n**$**   光标移至当前行尾\n\n## 屏幕翻滚\n\n**Ctrl+u**   向文件首翻半屏\n\n**Ctrl+d**   向文件尾翻半屏\n\n**Ctrl+f**   向文件尾翻一屏\n\n**Ctrl＋b**   向文件首翻一屏\n\n**nz**   将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部\n\n## 插入\n\n**i**  在光标前\n\n**I**   在当前行首\n\n**a**   光标后\n\n**A**   在当前行尾\n\n**o**   在当前行之下新开一行\n\n**O**   在当前行之上新开一行\n\n**r**   替换当前字符\n\n**R**   替换当前字符及其后的字符，直至按ESC键\n\n**s**   从当前光标位置处开始，以输入的文本替代指定数目的字符\n\n**S**   删除指定数目的行，并以所输入文本代替\n\n**ncw** 或 **nCW**   修改指定数目的字\n\n**nCC**   修改指定数目的行\n\n## 删除\n\n**ndw** 或 **ndW**   删除光标处开始及其后的n-1个字\n\n**do**   删至行首\n\n**d$**   删至行尾\n\n**ndd**   删除当前行及其后n-1行\n\n**x** 或 **X**   删除一个字符，x删除光标后的，而X删除光标前的\n\n**Ctrl+u**   删除输入方式下所输入的文本\n\n**n1,n2 d**   将n1行到n2行之间的内容删除\n\n**%d**   删除全部内容\n\n**1,$d**   删除全部内容\n\n## 复制粘贴、剪切、移动\n\n**yy**   复制当前行\n\n**nyy**   复制当前行开始的n行\n\n先按 **v** 然后方向键选择区域，按 **y** 复制选中行\n\n**dd**   剪切当前行\n\n**p** （小）   在当前光标处下面粘贴内容\n\n**P** （大）   在当前光标处上面粘贴内容\n\n**n1,n2 co n3**   将n1行到n2行之间的内容拷贝到第n3行下\n\n**n1,n2 m n3**   将n1行到n2行之间的内容移至到第n3行下\n\n## 搜索（查找）\n\n**/abc**   从光标开始处向文件尾搜索abc\n\n**?abc**   从光标开始处向文件首搜索abc\n\n**//abc**   从光标开始处向文件尾搜索/abc，其中/是转义\n\n**n**   在同一方向重复上一次搜索命令\n\n**N**   在反方向上重复上一次搜索命令\n\n## 替换\n\n**s/vivian/sky/**   替换当前行第一个 vivian 为 sky\n\n**s/vivian/sky/g**   替换当前行所有 vivian 为 sky\n\n**n,$s/vivian/sky/**   替换第 n 行开始到最后一行中每一行的第一个 vivian 为 sky\n\n**n,$s/vivian/sky/g**   替换第 n 行开始到最后一行中每一行所有 vivian 为sky\n\n**%s/vivian/sky/g**   （等同于 g/vivian/s//sky/） 替换每一行的每一个 vivian 为 sky\n\n**s#vivian/#sky#**   替换当前行第一个 vivian/ 为 sky/（可以使用 # 或 + 作为分隔符，此时中间出现的 / 不会作为分隔符）\n\n**s/p1/p2/g**   将当前行中所有p1均用p2替代\n\n**n1,n2s/p1/p2/g**   将第n1至n2行中所有p1均用p2替代\n\n**g/p1/s//p2/g**   将文件中所有p1均用p2替换\n\n## 寄存器\n\n**\"?nyy**   将当前行及其下n行的内容保存到寄存器？中，其中?为一个字母，n为一个数字\n\n**\"?nyw**   将当前行及其下n个字保存到寄存器？中，其中?为一个字母，n为一个数字\n\n**\"?nyl**   将当前行及其下n个字符保存到寄存器？中，其中?为一个字母，n为一个数字\n\n**\"?p**   取出寄存器？中的内容并将其放到光标位置处。这里？可以是一个字母，也可以是一个数字\n\n**ndd**   将当前行及其下共n行文本删除，并将所删内容放到1号删除寄存器中\n\n## 选项设置\n\n**set number**   显示行号\n\n**set number!**   不显示行号，其它选项同理加！号\n\n**set all**   列出所有选项设置情况\n\n**set term**   设置终端类型\n\n**set ignorance**   在搜索中忽略大小写\n\n**set list**   显示制表位(Ctrl+I)和行尾标志（$)\n\n**set report**   显示由面向行的命令修改过的数目\n\n**set terse**   显示简短的警告信息\n\n**set warn**   在转到别的文件时若没保存当前文件则显示NO write信息\n\n**set nomagic**   允许在搜索模式中，使用前面不带“”的特殊字符\n\n**set nowrapscan**   禁止vi在搜索到达文件两端时，又从另一端开始\n\n**set mesg**   允许vi显示其他用户用write写到自己终端上的信息\n","source":"_posts/2023-06-14-Vi操作命令.md","raw":"## 进入vi\n\n**vi filename**     打开或新建文档，并将光标置于第一行行首\n\n**vi +n filename**     打开文件，并将光标置于第n行首\n\n**vi + filename**     打开文件，并将光标置于最后一行首\n\n**vi +/pattern filename**     打开文件，并将光标置于第一个与pattern匹配的串处\n\n**vi -r filename**     在上次正用vi编辑时发生系统崩溃，恢复filename\n\n**vi filename....filename**     打开多个文件，依次进行编辑\n\n## 2保存退出\n\n**w**    保存当前文件\n\n**w /tmp1**     另存为/tmp1\n\n**20,59w /tmp1**    仅将20-59行之间的内存另存为/tmp1\n\n**x 或 wq**    保存退出\n\n**q**     退出vi\n\n**q!**    退出不保存  >\n\n**!command**    执行shell命令command\n\n**n1,n2 w !command**    将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入\n\n**r !command**   将命令command的输出结果放到当前行\n\n**w !sudo tee %**   保存没权限时，可获取权限再保存\n\n## 3光标移动\n\n**h**    光标左移一个字符\n\n**l**    光标右移一个字符\n\n**space**   光标右移一个字符\n\n**Backspace**   光标左移一个字符\n\n**k** 或 **Ctrl+p**    光标上移一行\n\n**j** 或 **Ctrl+n**    光标下移一行\n\n**Enter**   光标下移一行\n\n**w** 或 **W**   光标右移一个字至字首\n\n**b** 或 **B**   光标左移一个字至字首\n\n**e** 或 **E**   光标右移一个字至字尾\n\n**)**   光标移至句尾\n\n**(**   光标移至句首\n\n**}**   光标移至段落开头\n\n**{**   光标移至段落结尾\n\n**nG**   光标移至第n行首\n\n**n+**   光标下移n行\n\n**n-**   光标上移n行\n\n**n$**   光标移至第n行尾\n\n**H**   光标移至屏幕顶行\n\n**M**   光标移至屏幕中间行\n\n**L**   光标移至屏幕最后行\n\n**0**   （注意是数字零）光标移至当前行首\n\n**$**   光标移至当前行尾\n\n## 屏幕翻滚\n\n**Ctrl+u**   向文件首翻半屏\n\n**Ctrl+d**   向文件尾翻半屏\n\n**Ctrl+f**   向文件尾翻一屏\n\n**Ctrl＋b**   向文件首翻一屏\n\n**nz**   将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部\n\n## 插入\n\n**i**  在光标前\n\n**I**   在当前行首\n\n**a**   光标后\n\n**A**   在当前行尾\n\n**o**   在当前行之下新开一行\n\n**O**   在当前行之上新开一行\n\n**r**   替换当前字符\n\n**R**   替换当前字符及其后的字符，直至按ESC键\n\n**s**   从当前光标位置处开始，以输入的文本替代指定数目的字符\n\n**S**   删除指定数目的行，并以所输入文本代替\n\n**ncw** 或 **nCW**   修改指定数目的字\n\n**nCC**   修改指定数目的行\n\n## 删除\n\n**ndw** 或 **ndW**   删除光标处开始及其后的n-1个字\n\n**do**   删至行首\n\n**d$**   删至行尾\n\n**ndd**   删除当前行及其后n-1行\n\n**x** 或 **X**   删除一个字符，x删除光标后的，而X删除光标前的\n\n**Ctrl+u**   删除输入方式下所输入的文本\n\n**n1,n2 d**   将n1行到n2行之间的内容删除\n\n**%d**   删除全部内容\n\n**1,$d**   删除全部内容\n\n## 复制粘贴、剪切、移动\n\n**yy**   复制当前行\n\n**nyy**   复制当前行开始的n行\n\n先按 **v** 然后方向键选择区域，按 **y** 复制选中行\n\n**dd**   剪切当前行\n\n**p** （小）   在当前光标处下面粘贴内容\n\n**P** （大）   在当前光标处上面粘贴内容\n\n**n1,n2 co n3**   将n1行到n2行之间的内容拷贝到第n3行下\n\n**n1,n2 m n3**   将n1行到n2行之间的内容移至到第n3行下\n\n## 搜索（查找）\n\n**/abc**   从光标开始处向文件尾搜索abc\n\n**?abc**   从光标开始处向文件首搜索abc\n\n**//abc**   从光标开始处向文件尾搜索/abc，其中/是转义\n\n**n**   在同一方向重复上一次搜索命令\n\n**N**   在反方向上重复上一次搜索命令\n\n## 替换\n\n**s/vivian/sky/**   替换当前行第一个 vivian 为 sky\n\n**s/vivian/sky/g**   替换当前行所有 vivian 为 sky\n\n**n,$s/vivian/sky/**   替换第 n 行开始到最后一行中每一行的第一个 vivian 为 sky\n\n**n,$s/vivian/sky/g**   替换第 n 行开始到最后一行中每一行所有 vivian 为sky\n\n**%s/vivian/sky/g**   （等同于 g/vivian/s//sky/） 替换每一行的每一个 vivian 为 sky\n\n**s#vivian/#sky#**   替换当前行第一个 vivian/ 为 sky/（可以使用 # 或 + 作为分隔符，此时中间出现的 / 不会作为分隔符）\n\n**s/p1/p2/g**   将当前行中所有p1均用p2替代\n\n**n1,n2s/p1/p2/g**   将第n1至n2行中所有p1均用p2替代\n\n**g/p1/s//p2/g**   将文件中所有p1均用p2替换\n\n## 寄存器\n\n**\"?nyy**   将当前行及其下n行的内容保存到寄存器？中，其中?为一个字母，n为一个数字\n\n**\"?nyw**   将当前行及其下n个字保存到寄存器？中，其中?为一个字母，n为一个数字\n\n**\"?nyl**   将当前行及其下n个字符保存到寄存器？中，其中?为一个字母，n为一个数字\n\n**\"?p**   取出寄存器？中的内容并将其放到光标位置处。这里？可以是一个字母，也可以是一个数字\n\n**ndd**   将当前行及其下共n行文本删除，并将所删内容放到1号删除寄存器中\n\n## 选项设置\n\n**set number**   显示行号\n\n**set number!**   不显示行号，其它选项同理加！号\n\n**set all**   列出所有选项设置情况\n\n**set term**   设置终端类型\n\n**set ignorance**   在搜索中忽略大小写\n\n**set list**   显示制表位(Ctrl+I)和行尾标志（$)\n\n**set report**   显示由面向行的命令修改过的数目\n\n**set terse**   显示简短的警告信息\n\n**set warn**   在转到别的文件时若没保存当前文件则显示NO write信息\n\n**set nomagic**   允许在搜索模式中，使用前面不带“”的特殊字符\n\n**set nowrapscan**   禁止vi在搜索到达文件两端时，又从另一端开始\n\n**set mesg**   允许vi显示其他用户用write写到自己终端上的信息\n","slug":"2023-06-14-Vi操作命令","published":1,"date":"2023-12-15T02:31:42.255Z","updated":"2023-12-15T02:31:42.267Z","_id":"clq60joww000b4zgs1m0j2ig4","title":"","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"进入vi\"><a href=\"#进入vi\" class=\"headerlink\" title=\"进入vi\"></a>进入vi</h2><p><strong>vi filename</strong>     打开或新建文档，并将光标置于第一行行首</p>\n<p><strong>vi +n filename</strong>     打开文件，并将光标置于第n行首</p>\n<p><strong>vi + filename</strong>     打开文件，并将光标置于最后一行首</p>\n<p><strong>vi +&#x2F;pattern filename</strong>     打开文件，并将光标置于第一个与pattern匹配的串处</p>\n<p><strong>vi -r filename</strong>     在上次正用vi编辑时发生系统崩溃，恢复filename</p>\n<p><strong>vi filename….filename</strong>     打开多个文件，依次进行编辑</p>\n<h2 id=\"2保存退出\"><a href=\"#2保存退出\" class=\"headerlink\" title=\"2保存退出\"></a>2保存退出</h2><p><strong>w</strong>    保存当前文件</p>\n<p><strong>w &#x2F;tmp1</strong>     另存为&#x2F;tmp1</p>\n<p><strong>20,59w &#x2F;tmp1</strong>    仅将20-59行之间的内存另存为&#x2F;tmp1</p>\n<p><strong>x 或 wq</strong>    保存退出</p>\n<p><strong>q</strong>     退出vi</p>\n<p><strong>q!</strong>    退出不保存  &gt;</p>\n<p><strong>!command</strong>    执行shell命令command</p>\n<p><strong>n1,n2 w !command</strong>    将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入</p>\n<p><strong>r !command</strong>   将命令command的输出结果放到当前行</p>\n<p><strong>w !sudo tee %</strong>   保存没权限时，可获取权限再保存</p>\n<h2 id=\"3光标移动\"><a href=\"#3光标移动\" class=\"headerlink\" title=\"3光标移动\"></a>3光标移动</h2><p><strong>h</strong>    光标左移一个字符</p>\n<p><strong>l</strong>    光标右移一个字符</p>\n<p><strong>space</strong>   光标右移一个字符</p>\n<p><strong>Backspace</strong>   光标左移一个字符</p>\n<p><strong>k</strong> 或 <strong>Ctrl+p</strong>    光标上移一行</p>\n<p><strong>j</strong> 或 <strong>Ctrl+n</strong>    光标下移一行</p>\n<p><strong>Enter</strong>   光标下移一行</p>\n<p><strong>w</strong> 或 <strong>W</strong>   光标右移一个字至字首</p>\n<p><strong>b</strong> 或 <strong>B</strong>   光标左移一个字至字首</p>\n<p><strong>e</strong> 或 <strong>E</strong>   光标右移一个字至字尾</p>\n<p><strong>)</strong>   光标移至句尾</p>\n<p><strong>(</strong>   光标移至句首</p>\n<p><strong>}</strong>   光标移至段落开头</p>\n<p><strong>{</strong>   光标移至段落结尾</p>\n<p><strong>nG</strong>   光标移至第n行首</p>\n<p><strong>n+</strong>   光标下移n行</p>\n<p><strong>n-</strong>   光标上移n行</p>\n<p><strong>n$</strong>   光标移至第n行尾</p>\n<p><strong>H</strong>   光标移至屏幕顶行</p>\n<p><strong>M</strong>   光标移至屏幕中间行</p>\n<p><strong>L</strong>   光标移至屏幕最后行</p>\n<p><strong>0</strong>   （注意是数字零）光标移至当前行首</p>\n<p><strong>$</strong>   光标移至当前行尾</p>\n<h2 id=\"屏幕翻滚\"><a href=\"#屏幕翻滚\" class=\"headerlink\" title=\"屏幕翻滚\"></a>屏幕翻滚</h2><p><strong>Ctrl+u</strong>   向文件首翻半屏</p>\n<p><strong>Ctrl+d</strong>   向文件尾翻半屏</p>\n<p><strong>Ctrl+f</strong>   向文件尾翻一屏</p>\n<p><strong>Ctrl＋b</strong>   向文件首翻一屏</p>\n<p><strong>nz</strong>   将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部</p>\n<h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><p><strong>i</strong>  在光标前</p>\n<p><strong>I</strong>   在当前行首</p>\n<p><strong>a</strong>   光标后</p>\n<p><strong>A</strong>   在当前行尾</p>\n<p><strong>o</strong>   在当前行之下新开一行</p>\n<p><strong>O</strong>   在当前行之上新开一行</p>\n<p><strong>r</strong>   替换当前字符</p>\n<p><strong>R</strong>   替换当前字符及其后的字符，直至按ESC键</p>\n<p><strong>s</strong>   从当前光标位置处开始，以输入的文本替代指定数目的字符</p>\n<p><strong>S</strong>   删除指定数目的行，并以所输入文本代替</p>\n<p><strong>ncw</strong> 或 <strong>nCW</strong>   修改指定数目的字</p>\n<p><strong>nCC</strong>   修改指定数目的行</p>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p><strong>ndw</strong> 或 <strong>ndW</strong>   删除光标处开始及其后的n-1个字</p>\n<p><strong>do</strong>   删至行首</p>\n<p><strong>d$</strong>   删至行尾</p>\n<p><strong>ndd</strong>   删除当前行及其后n-1行</p>\n<p><strong>x</strong> 或 <strong>X</strong>   删除一个字符，x删除光标后的，而X删除光标前的</p>\n<p><strong>Ctrl+u</strong>   删除输入方式下所输入的文本</p>\n<p><strong>n1,n2 d</strong>   将n1行到n2行之间的内容删除</p>\n<p><strong>%d</strong>   删除全部内容</p>\n<p><strong>1,$d</strong>   删除全部内容</p>\n<h2 id=\"复制粘贴、剪切、移动\"><a href=\"#复制粘贴、剪切、移动\" class=\"headerlink\" title=\"复制粘贴、剪切、移动\"></a>复制粘贴、剪切、移动</h2><p><strong>yy</strong>   复制当前行</p>\n<p><strong>nyy</strong>   复制当前行开始的n行</p>\n<p>先按 <strong>v</strong> 然后方向键选择区域，按 <strong>y</strong> 复制选中行</p>\n<p><strong>dd</strong>   剪切当前行</p>\n<p><strong>p</strong> （小）   在当前光标处下面粘贴内容</p>\n<p><strong>P</strong> （大）   在当前光标处上面粘贴内容</p>\n<p><strong>n1,n2 co n3</strong>   将n1行到n2行之间的内容拷贝到第n3行下</p>\n<p><strong>n1,n2 m n3</strong>   将n1行到n2行之间的内容移至到第n3行下</p>\n<h2 id=\"搜索（查找）\"><a href=\"#搜索（查找）\" class=\"headerlink\" title=\"搜索（查找）\"></a>搜索（查找）</h2><p><strong>&#x2F;abc</strong>   从光标开始处向文件尾搜索abc</p>\n<p><strong>?abc</strong>   从光标开始处向文件首搜索abc</p>\n<p><strong>&#x2F;&#x2F;abc</strong>   从光标开始处向文件尾搜索&#x2F;abc，其中&#x2F;是转义</p>\n<p><strong>n</strong>   在同一方向重复上一次搜索命令</p>\n<p><strong>N</strong>   在反方向上重复上一次搜索命令</p>\n<h2 id=\"替换\"><a href=\"#替换\" class=\"headerlink\" title=\"替换\"></a>替换</h2><p><strong>s&#x2F;vivian&#x2F;sky&#x2F;</strong>   替换当前行第一个 vivian 为 sky</p>\n<p><strong>s&#x2F;vivian&#x2F;sky&#x2F;g</strong>   替换当前行所有 vivian 为 sky</p>\n<p><strong>n,$s&#x2F;vivian&#x2F;sky&#x2F;</strong>   替换第 n 行开始到最后一行中每一行的第一个 vivian 为 sky</p>\n<p><strong>n,$s&#x2F;vivian&#x2F;sky&#x2F;g</strong>   替换第 n 行开始到最后一行中每一行所有 vivian 为sky</p>\n<p><strong>%s&#x2F;vivian&#x2F;sky&#x2F;g</strong>   （等同于 g&#x2F;vivian&#x2F;s&#x2F;&#x2F;sky&#x2F;） 替换每一行的每一个 vivian 为 sky</p>\n<p><strong>s#vivian&#x2F;#sky#</strong>   替换当前行第一个 vivian&#x2F; 为 sky&#x2F;（可以使用 # 或 + 作为分隔符，此时中间出现的 &#x2F; 不会作为分隔符）</p>\n<p><strong>s&#x2F;p1&#x2F;p2&#x2F;g</strong>   将当前行中所有p1均用p2替代</p>\n<p><strong>n1,n2s&#x2F;p1&#x2F;p2&#x2F;g</strong>   将第n1至n2行中所有p1均用p2替代</p>\n<p><strong>g&#x2F;p1&#x2F;s&#x2F;&#x2F;p2&#x2F;g</strong>   将文件中所有p1均用p2替换</p>\n<h2 id=\"寄存器\"><a href=\"#寄存器\" class=\"headerlink\" title=\"寄存器\"></a>寄存器</h2><p><strong>“?nyy</strong>   将当前行及其下n行的内容保存到寄存器？中，其中?为一个字母，n为一个数字</p>\n<p><strong>“?nyw</strong>   将当前行及其下n个字保存到寄存器？中，其中?为一个字母，n为一个数字</p>\n<p><strong>“?nyl</strong>   将当前行及其下n个字符保存到寄存器？中，其中?为一个字母，n为一个数字</p>\n<p><strong>“?p</strong>   取出寄存器？中的内容并将其放到光标位置处。这里？可以是一个字母，也可以是一个数字</p>\n<p><strong>ndd</strong>   将当前行及其下共n行文本删除，并将所删内容放到1号删除寄存器中</p>\n<h2 id=\"选项设置\"><a href=\"#选项设置\" class=\"headerlink\" title=\"选项设置\"></a>选项设置</h2><p><strong>set number</strong>   显示行号</p>\n<p><strong>set number!</strong>   不显示行号，其它选项同理加！号</p>\n<p><strong>set all</strong>   列出所有选项设置情况</p>\n<p><strong>set term</strong>   设置终端类型</p>\n<p><strong>set ignorance</strong>   在搜索中忽略大小写</p>\n<p><strong>set list</strong>   显示制表位(Ctrl+I)和行尾标志（$)</p>\n<p><strong>set report</strong>   显示由面向行的命令修改过的数目</p>\n<p><strong>set terse</strong>   显示简短的警告信息</p>\n<p><strong>set warn</strong>   在转到别的文件时若没保存当前文件则显示NO write信息</p>\n<p><strong>set nomagic</strong>   允许在搜索模式中，使用前面不带“”的特殊字符</p>\n<p><strong>set nowrapscan</strong>   禁止vi在搜索到达文件两端时，又从另一端开始</p>\n<p><strong>set mesg</strong>   允许vi显示其他用户用write写到自己终端上的信息</p>\n","excerpt":"","more":"<h2 id=\"进入vi\"><a href=\"#进入vi\" class=\"headerlink\" title=\"进入vi\"></a>进入vi</h2><p><strong>vi filename</strong>     打开或新建文档，并将光标置于第一行行首</p>\n<p><strong>vi +n filename</strong>     打开文件，并将光标置于第n行首</p>\n<p><strong>vi + filename</strong>     打开文件，并将光标置于最后一行首</p>\n<p><strong>vi +&#x2F;pattern filename</strong>     打开文件，并将光标置于第一个与pattern匹配的串处</p>\n<p><strong>vi -r filename</strong>     在上次正用vi编辑时发生系统崩溃，恢复filename</p>\n<p><strong>vi filename….filename</strong>     打开多个文件，依次进行编辑</p>\n<h2 id=\"2保存退出\"><a href=\"#2保存退出\" class=\"headerlink\" title=\"2保存退出\"></a>2保存退出</h2><p><strong>w</strong>    保存当前文件</p>\n<p><strong>w &#x2F;tmp1</strong>     另存为&#x2F;tmp1</p>\n<p><strong>20,59w &#x2F;tmp1</strong>    仅将20-59行之间的内存另存为&#x2F;tmp1</p>\n<p><strong>x 或 wq</strong>    保存退出</p>\n<p><strong>q</strong>     退出vi</p>\n<p><strong>q!</strong>    退出不保存  &gt;</p>\n<p><strong>!command</strong>    执行shell命令command</p>\n<p><strong>n1,n2 w !command</strong>    将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入</p>\n<p><strong>r !command</strong>   将命令command的输出结果放到当前行</p>\n<p><strong>w !sudo tee %</strong>   保存没权限时，可获取权限再保存</p>\n<h2 id=\"3光标移动\"><a href=\"#3光标移动\" class=\"headerlink\" title=\"3光标移动\"></a>3光标移动</h2><p><strong>h</strong>    光标左移一个字符</p>\n<p><strong>l</strong>    光标右移一个字符</p>\n<p><strong>space</strong>   光标右移一个字符</p>\n<p><strong>Backspace</strong>   光标左移一个字符</p>\n<p><strong>k</strong> 或 <strong>Ctrl+p</strong>    光标上移一行</p>\n<p><strong>j</strong> 或 <strong>Ctrl+n</strong>    光标下移一行</p>\n<p><strong>Enter</strong>   光标下移一行</p>\n<p><strong>w</strong> 或 <strong>W</strong>   光标右移一个字至字首</p>\n<p><strong>b</strong> 或 <strong>B</strong>   光标左移一个字至字首</p>\n<p><strong>e</strong> 或 <strong>E</strong>   光标右移一个字至字尾</p>\n<p><strong>)</strong>   光标移至句尾</p>\n<p><strong>(</strong>   光标移至句首</p>\n<p><strong>}</strong>   光标移至段落开头</p>\n<p><strong>{</strong>   光标移至段落结尾</p>\n<p><strong>nG</strong>   光标移至第n行首</p>\n<p><strong>n+</strong>   光标下移n行</p>\n<p><strong>n-</strong>   光标上移n行</p>\n<p><strong>n$</strong>   光标移至第n行尾</p>\n<p><strong>H</strong>   光标移至屏幕顶行</p>\n<p><strong>M</strong>   光标移至屏幕中间行</p>\n<p><strong>L</strong>   光标移至屏幕最后行</p>\n<p><strong>0</strong>   （注意是数字零）光标移至当前行首</p>\n<p><strong>$</strong>   光标移至当前行尾</p>\n<h2 id=\"屏幕翻滚\"><a href=\"#屏幕翻滚\" class=\"headerlink\" title=\"屏幕翻滚\"></a>屏幕翻滚</h2><p><strong>Ctrl+u</strong>   向文件首翻半屏</p>\n<p><strong>Ctrl+d</strong>   向文件尾翻半屏</p>\n<p><strong>Ctrl+f</strong>   向文件尾翻一屏</p>\n<p><strong>Ctrl＋b</strong>   向文件首翻一屏</p>\n<p><strong>nz</strong>   将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部</p>\n<h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><p><strong>i</strong>  在光标前</p>\n<p><strong>I</strong>   在当前行首</p>\n<p><strong>a</strong>   光标后</p>\n<p><strong>A</strong>   在当前行尾</p>\n<p><strong>o</strong>   在当前行之下新开一行</p>\n<p><strong>O</strong>   在当前行之上新开一行</p>\n<p><strong>r</strong>   替换当前字符</p>\n<p><strong>R</strong>   替换当前字符及其后的字符，直至按ESC键</p>\n<p><strong>s</strong>   从当前光标位置处开始，以输入的文本替代指定数目的字符</p>\n<p><strong>S</strong>   删除指定数目的行，并以所输入文本代替</p>\n<p><strong>ncw</strong> 或 <strong>nCW</strong>   修改指定数目的字</p>\n<p><strong>nCC</strong>   修改指定数目的行</p>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p><strong>ndw</strong> 或 <strong>ndW</strong>   删除光标处开始及其后的n-1个字</p>\n<p><strong>do</strong>   删至行首</p>\n<p><strong>d$</strong>   删至行尾</p>\n<p><strong>ndd</strong>   删除当前行及其后n-1行</p>\n<p><strong>x</strong> 或 <strong>X</strong>   删除一个字符，x删除光标后的，而X删除光标前的</p>\n<p><strong>Ctrl+u</strong>   删除输入方式下所输入的文本</p>\n<p><strong>n1,n2 d</strong>   将n1行到n2行之间的内容删除</p>\n<p><strong>%d</strong>   删除全部内容</p>\n<p><strong>1,$d</strong>   删除全部内容</p>\n<h2 id=\"复制粘贴、剪切、移动\"><a href=\"#复制粘贴、剪切、移动\" class=\"headerlink\" title=\"复制粘贴、剪切、移动\"></a>复制粘贴、剪切、移动</h2><p><strong>yy</strong>   复制当前行</p>\n<p><strong>nyy</strong>   复制当前行开始的n行</p>\n<p>先按 <strong>v</strong> 然后方向键选择区域，按 <strong>y</strong> 复制选中行</p>\n<p><strong>dd</strong>   剪切当前行</p>\n<p><strong>p</strong> （小）   在当前光标处下面粘贴内容</p>\n<p><strong>P</strong> （大）   在当前光标处上面粘贴内容</p>\n<p><strong>n1,n2 co n3</strong>   将n1行到n2行之间的内容拷贝到第n3行下</p>\n<p><strong>n1,n2 m n3</strong>   将n1行到n2行之间的内容移至到第n3行下</p>\n<h2 id=\"搜索（查找）\"><a href=\"#搜索（查找）\" class=\"headerlink\" title=\"搜索（查找）\"></a>搜索（查找）</h2><p><strong>&#x2F;abc</strong>   从光标开始处向文件尾搜索abc</p>\n<p><strong>?abc</strong>   从光标开始处向文件首搜索abc</p>\n<p><strong>&#x2F;&#x2F;abc</strong>   从光标开始处向文件尾搜索&#x2F;abc，其中&#x2F;是转义</p>\n<p><strong>n</strong>   在同一方向重复上一次搜索命令</p>\n<p><strong>N</strong>   在反方向上重复上一次搜索命令</p>\n<h2 id=\"替换\"><a href=\"#替换\" class=\"headerlink\" title=\"替换\"></a>替换</h2><p><strong>s&#x2F;vivian&#x2F;sky&#x2F;</strong>   替换当前行第一个 vivian 为 sky</p>\n<p><strong>s&#x2F;vivian&#x2F;sky&#x2F;g</strong>   替换当前行所有 vivian 为 sky</p>\n<p><strong>n,$s&#x2F;vivian&#x2F;sky&#x2F;</strong>   替换第 n 行开始到最后一行中每一行的第一个 vivian 为 sky</p>\n<p><strong>n,$s&#x2F;vivian&#x2F;sky&#x2F;g</strong>   替换第 n 行开始到最后一行中每一行所有 vivian 为sky</p>\n<p><strong>%s&#x2F;vivian&#x2F;sky&#x2F;g</strong>   （等同于 g&#x2F;vivian&#x2F;s&#x2F;&#x2F;sky&#x2F;） 替换每一行的每一个 vivian 为 sky</p>\n<p><strong>s#vivian&#x2F;#sky#</strong>   替换当前行第一个 vivian&#x2F; 为 sky&#x2F;（可以使用 # 或 + 作为分隔符，此时中间出现的 &#x2F; 不会作为分隔符）</p>\n<p><strong>s&#x2F;p1&#x2F;p2&#x2F;g</strong>   将当前行中所有p1均用p2替代</p>\n<p><strong>n1,n2s&#x2F;p1&#x2F;p2&#x2F;g</strong>   将第n1至n2行中所有p1均用p2替代</p>\n<p><strong>g&#x2F;p1&#x2F;s&#x2F;&#x2F;p2&#x2F;g</strong>   将文件中所有p1均用p2替换</p>\n<h2 id=\"寄存器\"><a href=\"#寄存器\" class=\"headerlink\" title=\"寄存器\"></a>寄存器</h2><p><strong>“?nyy</strong>   将当前行及其下n行的内容保存到寄存器？中，其中?为一个字母，n为一个数字</p>\n<p><strong>“?nyw</strong>   将当前行及其下n个字保存到寄存器？中，其中?为一个字母，n为一个数字</p>\n<p><strong>“?nyl</strong>   将当前行及其下n个字符保存到寄存器？中，其中?为一个字母，n为一个数字</p>\n<p><strong>“?p</strong>   取出寄存器？中的内容并将其放到光标位置处。这里？可以是一个字母，也可以是一个数字</p>\n<p><strong>ndd</strong>   将当前行及其下共n行文本删除，并将所删内容放到1号删除寄存器中</p>\n<h2 id=\"选项设置\"><a href=\"#选项设置\" class=\"headerlink\" title=\"选项设置\"></a>选项设置</h2><p><strong>set number</strong>   显示行号</p>\n<p><strong>set number!</strong>   不显示行号，其它选项同理加！号</p>\n<p><strong>set all</strong>   列出所有选项设置情况</p>\n<p><strong>set term</strong>   设置终端类型</p>\n<p><strong>set ignorance</strong>   在搜索中忽略大小写</p>\n<p><strong>set list</strong>   显示制表位(Ctrl+I)和行尾标志（$)</p>\n<p><strong>set report</strong>   显示由面向行的命令修改过的数目</p>\n<p><strong>set terse</strong>   显示简短的警告信息</p>\n<p><strong>set warn</strong>   在转到别的文件时若没保存当前文件则显示NO write信息</p>\n<p><strong>set nomagic</strong>   允许在搜索模式中，使用前面不带“”的特殊字符</p>\n<p><strong>set nowrapscan</strong>   禁止vi在搜索到达文件两端时，又从另一端开始</p>\n<p><strong>set mesg</strong>   允许vi显示其他用户用write写到自己终端上的信息</p>\n"},{"_content":"# 数据结构\n## 第一章：数据结构的\n基本概念\n### 定义\n* 在任何问题中，数据元素都不是孤立存在的，而是在它们之间存在着某种关系，这种数据元素相互之间的关系称为结构（Structure）。数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。\n### 逻辑结构\n* 逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的\n* 数据的逻辑结构分为线性结构和非线性结构\n    * 集合 结构中的数据元素之间除了“同属于一个集合”的关系外，别无其他关系。 类似于数学上的集合\n    * 线性结构 结构中的数据元素之间只存在一对一的关系。比如排队\n    * 树形结构 结构中的数据元素之间存在一对多的关系。比如家族族谱\n    * 图状结构或网状结构 结构中的数据元素之间存在多对多的关系。 比如地图\n### 物理结构\n* 存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。数据的存储结构主要有：顺序存储、链式存储、索引存储和散列存储。\n    * 顺序存储：存储的物理位置相邻。（p.s. 物理位置即信息在计算机中的位置。）\n    * 链接存储：存储的物理位置未必相邻，通过记录相邻元素的物理位置来找到相邻元素。\n    * 索引存储：类似于目录，以后可以联系操作系统的文件系统章节来理解。\n    * 散列存储：通过关键字直接计算出元素的物理地址（以后详解）。\n### 算法的五个特征\n* 1，有穷性：有限步之后结束\n* 2，确定性：不存在二义性，即没有歧义\n* 3，可行性：比如受限于计算机的计算能力，有些算法虽然理论上可行，但实际上无法完成。\n* 4，输入：能被计算机处理的各种类型数据，如数字，音频，图像等等。\n* 5，输出：一至多个程序输出结果。\n### 算法的复杂度\n* 时间复杂度：\n    * • 它用来衡量算法随着问题规模增大，算法执行时间增长的快慢；\n    * • 是问题规模的函数：T(n)是时间规模函数 时间复杂度主要分析T(n)的数量级\n    * • T(n)=O(f(n)) f(n)是算法中基本运算的频度 一般我们考虑最坏情况下的时间复杂度\n* 空间复杂度：\n    * • 它用来衡量算法随着问题规模增大，算法所需空间的快慢；\n    * • 是问题规模的函数：S(n)=O(g(n)) ；算法所需空间的增长率和g(n)的增长率相同。\n### 概要: 复杂度计算为重点\n* 常用的时间复杂度大小关系：\n* 复杂度如何计算\n    * 时间复杂度计算（单个循环体）\n        * 直接关注循环体的执行次数，设为k \n    * 时间复杂度计算（多个循环体）\n        * 两个运算规则：乘法规则，加法规则。\n## 第二章：线性表\n### 线性表的逻辑结构\n* 定义：线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列。其中n为表长。当n=0时 线性表是一个空表\n* 特点：线性表中第一个元素称为表头元素；最后一个元素称为表尾元素。\n除第一个元素外，每个元素有且仅有一个直接前驱。\n除最后一个元素外，每个元素有且仅有一个直接后继。\n### 线性表的顺序存储结构\n* 线性表的顺序存储又称为顺序表。\n它是用一组地址连续的存储单元（比如C语言里面的数组），依次存储线性表中的数据元素，从而使得逻\n辑上相邻的两个元素在物理位置上也相邻。\n* 建立顺序表的三个属性: \n1.存储空间的起始位置（数组名data）\n2.顺序表最大存储容量（MaxSize）\n3.顺序表当前的长度（length）\n* 其实数组还可以动态分配空间，存储数组的空间是在程序执行过程中通过动态存储分配语句分配\n* 总结：\n    * 1.顺序表最主要的特点是随机访问（C语言中基于数组），即通过首地址和元素序号可以在O(1)的时间内找到指定的元素。\n    * 2.顺序表的存储密度高，每个结点只存储数据元素。无需给表中元素花费空间建立它们之间的逻辑关系（因为物理位置相邻特性决定）\n    * 3.顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。\n### 顺序表的操作\n* 1.插入\n    * 算法思路：\n        * 1.判断i的值是否正确\n        * 2.判断表长是否超过数组长度\n        * 3.从后向前到第i个位置，分别将这些元素都向后移动一位\n        * 4.将该元素插入位置i 并修改表长\n    * 代码\n    * 分析：\n        * 最好情况：在表尾插入（即i=n+1），元素后移语句将不执行，时间复杂度为O(1)。\n        * 最坏情况：在表头插入（即i=1），元素后移语句将执行\nn次，时间复杂度为O(n)。\n        * 平均情况：假设pi（pi=1/(n+1) ）是在第i个位置上插入\n一个结点的概率，则在长度为n的线性表中插入一个结\n点时所需移动结点的平均次数为\n* 2.删除\n    * 算法思路：\n        * 1.判断i的值是否正确\n        * 2.取删除的元素\n        * 3.将被删元素后面的所有元素都依次向前移动一位\n        * 4.修改表长\n    * 代码\n    * 分析\n        * 最好情况：删除表尾元素（即i=n），无须移动元素，时间复杂度为O(1)。\n        * 最坏情况：删除表头元素（即i=1），需要移动除第一个元素外的所有元素，时间复杂度为O(n)。\n        * 平均情况：假设pi(pi=1/n)是删除第i个位置上结点的概率，则在长度为n的线性表中删除一个结点时所需移动结点的平均次数为\n### 线性表的链式存储结构\n* 线性表的链式存储是指通过一组任意的存储单元来存储线性表中的数据元素。\n* 头结点和头指针的区别？\n    * 不管带不带头结点，头指针始终指向链表的第一个结点，而头结点是带头结点链表中的第一个结点，结点内通常不存储信息\n* 为什么要设置头结点？\n    * 1.处理操作起来方便 例如：对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了\n    * 2.无论链表是否为空，其头指针是指向头结点的非空指针，因此空表和非空表的处理也就统一了。\n### 单链表的操作\n* 1.头插法建立单链表：\n    * 建立新的结点分配内存空间，将新结点插入到当前链表的表头\n    * 代码\n* 2.尾插法建立单链表：\n    * 建立新的结点分配内存空间，将新结点插入到当前链表的表尾\n    * 代码\n* 3.按序号查找结点\n    * 在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止,否则返回最后一个结点指针域NULL。\n    * 代码\n* 4.按值查找结点\n    * 从单链表第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针；若整个单链表中没有这样的结点，则返回NULL。\n    * 代码\n* 5．插入\n    * 插入操作是将值为x的新结点插入到单链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i−1个结点，再在其后插入新结点。\n    * 算法思路：\n1.取指向插入位置的前驱结点的指针\n① p=GetElem(L,i-1);\n2.令新结点*s的指针域指向*p的后继结点\n② s->next=p->next;\n3.令结点*p的指针域指向新插入的结点*s\n③ p->next=s; \n* 6．删除\n    * 删除操作是将单链表的第i个结点删除。先检查删除位置的合法性，然后查找表中第i−1个结点，即被删结点的前驱结点，再将其删除。\n    * 算法思路：\n1.取指向删除位置的前驱结点的指针 p=GetElem(L,i-1);\n2.取指向删除位置的指针 q=p->next;\n3.p指向结点的后继指向被删除结点的后继 p->next=q->next\n4.释放删除结点 free(q);\n### 双链表\n* 定义\n* 1.插入：(方法不唯一)\n① s->next=p->next;\n② p->next->prior=s;\n③ s->prior=p;\n④ p->next=s;\n* 2.删除：\n① p->next=q->next;\n② q->next->prior=p;\n③ free(q);\n\n### 循环链表&&静态链表\n* 循环单链表：循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环\n* 循环双链表：类比循环单链表，循环双链表链表区别于双链表就是首尾结点构成环\n    * 当循环双链表为空表时，其头结点的prior域和next域都等于Head。\n* 静态链表：静态链表是用数组来描述线性表的链式存储结构。\n    * 数组第一个元素不存储数据，它的指针域存储第一个元素所在的数组下标。链表最后一个元素的指针域值为-1。\n    * 例子\n## 第三章：栈和队列\n### 栈\n* 栈（Stack）：只允许在一端进行插入或删除操作的线性表。\n* 栈顶（Top）：线性表允许进行插入和删除的那一端。\n* 栈底（Bottom）：固定的，不允许进行插入和删除的另一端\n* 特点：\n1.栈是受限的线性表，所以自然具有线性关\n系。\n2.栈中元素后进去的必然先出来，即后进先出\nLIFO（Last In First Out）\n    * 栈中元素后进\n去的必然先出\n来，即后进先\n出LIFO（Last In\nFirst Out）\n* 顺序栈\n    * 栈是线性表的特例，那栈的顺序存储也是线性表顺序存储的简化。栈的顺序存储结构也叫作顺序栈。\n    * 顺序栈的操作\n        * 1.判空：\n        * 2.进栈：\n        * 3.出栈：\n        * 4.读取栈顶元素：\n* 共享栈\n    * 顺序栈的存储空间大小需要事先开辟好，很多时候对每个栈各自单独开辟存储空间的利用率不如将各个栈的存储空间共享\n    * 示意图\n    * 共享栈的结构\n    * 共享栈的操作：（进栈）\n* 链式栈\n    * 栈是线性表的特例，线性表的存储结构还有链式存储结构，所以也可以用链表的方式来实现栈。栈的链式存储结构也叫作链栈。\n    * 特点\n1.链栈一般不存在栈满的情况。\n2.空栈的判定条件通常定为top==NULL；\n    * 结构\n    * 链式栈的操作\n        * 1.进栈\n        * 2.出栈\n### 队列\n* 队列是只允许在一端进行插入，而在另一端进行删除的线性表\n* 队头（Front）：允许删除的一端，又称为队首。\n* 队尾（Rear）： 允许插入的一端。\n* 先进入队列的元素必然先离开队列，即先进先出（First In First Out）简称FIFO\n* 顺序队列\n    * 用数组来实现队列，可以将队首放在数组下标为0的位置。\n* 循环队列\n    * 把数组“掰弯”，形成一个环。Rear指针到了下标为4的位置还能继续指回到下标为0的地方。这样首尾相连的顺序存储的队列就叫循环队列\n    * 入队：rear=(rear+1)%MaxSize\n    * 出队：front=(front+1)%MaxSize\n    * 循环队列的操作\n        * 1.入队：\n        * 2.出队：\n    * 概要: 那如何分辨队列是空还是满呢？\n        * 方法一：设置标志位flag，当flag=0且rear等于front时为队列空，当flag=1且rear等于front时为队列满。\n        * 方法二：我们把front=rear仅作为队空的判定条件。当队列满的时候，令数组中仍然保留一个空余单元。我们认为这种情况就是队列满了。\n* 链式队列\n    * 队列的链式存储结构，其实就是线性表的单链表，只不过需要加点限制，只能表尾插入元素，表头删除元素。\n    * 为了方便操作，我们分别设置队头指针和队尾指针，队头指针指向头结点，队尾指针指向尾结点。\n    * 链式队列的操作\n        * 1.入队：我们知道队列只能从队尾插入元素，队头删除元素。于是入队就是在队尾指针进行插入结点操作。链队的插入操作和单链表的插入操作是一致的。\n\n        * 2.出队：出队就是头结点的后继结点出队，然后将头结点的后继改为它后面的结点。\n* 双端队列\n    * 双端队列是指允许两端都可以进行入队和出队操作的队列\n### 栈的应用\n* 1、括号匹配：假设有两种括号，一种圆的()，一种方的[]，嵌套的顺序是任意的。\n    * 算法思想：若是左括号，入栈；若是右括号，出栈一个左括号判断是否与之匹配；检验到字符串尾，还要检查栈是否为空。只有栈空，整个字符串才是括号匹配的。\n\n    * 代码\n* 2、表达式求值：\n    *  \n    * 规则：从左到右扫描表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈然后跟这个符号进行运算，最后将运算结果进栈，直到最终获得结果。\n* 3、递归：\n    * 要理解递归，你要先理解递归，直到你能理解递归。\n如果在一个函数、过程或数据结构的定义中又应用了它自身，那么这个函数、过程或数据结构称为是递归定义的，简称递归。递归最重要的是递归式和递归边界。\n    * 1.阶乘\n        * 时间复杂度：O(NlogN)\n    * 2.斐波那契数列\n        * 时间复杂度   O(2^n)\n* 概要: 如何将中缀表达式转换成后缀表达式？\n    * 1.按运算符优先级对所有运算符和它的运算数加括号。(原本的括号不用加)\n    * 2.把运算符移到对应的括号后。\n    * 3.去掉括号。\n    * 例子\n## 第四章：树\n### 树的基本概念\n* 树是递归定义的结构\n* 结点\n    * 根节点：树只有一个根结点\n    * 结点的度：结点拥有的子树的数量\n        * 度为0：叶子结点或者终端结点\n        * 度不为0：分支结点或者非终端结点\n            * 分支结点除去根结点也称为内部结点\n* 树的度：树中所有结点的度数的最大值\n* 结点关系\n    * 祖先结点\n        * 根结点到该结点的唯一路径的任意结点\n    * 子孙结点\n    * 双亲结点\n        * 根结点到该结点的唯一路径上最接近该结点的结点\n    * 孩子结点\n    * 兄弟结点\n        * 有相同双亲结点的结点\n* 层次，高度，深度，树的高度\n    * 层次：根为第一层，它的孩子为第二层，以此类推\n    * 结点的深度：根结点开始自顶向下累加\n    * 结点的高度：叶节点开始自底向上累加\n    * 树的高度（深度）：树中结点的最大层数\n* 树的性质\n    * 1.树中的结点数等于所有结点的度数加1。\n        * 证明：不难想象，除根结点以外，每个结点有且仅有一个指向它的前驱结点。也就是说每个结点和指向它的分支一一对应。\n假设树中一共有b个分支，那么除了根结点，整个树就包含有b个结点，所以整个树的结点数就是这b个结点加上根结点，设为n，则n=b+1。而分支数b也就是所有结点的度数，证毕。\n    * 2.度为m的树中第i层上至多有m^(i−1)个结点（i≥1）。\n        * 证明：（数学归纳法）\n首先考虑i=1的情况：第一层只有根结点，即一个结点，i=1带入式子满足。\n假设第i-1层满足这个性质，第i-1层最多有m i-2个结点。\n……… ..........\ni-1层\n………\n又因为树的度为m,所以对于第i-1层的每个结点，最多\n有m个孩子结点。所以第i层的结点数最多是i-1层的m\n倍，所以第i层上最多有m ^(i-1)个结点。\n    * 3.高度为h的m叉树至多有(m^h-1)/(m-1)个结点\n    * 4.具有n个结点的m叉树的最小高度为logm(n(m-1)+1) \n### 树的存储结构\n* 顺序存储结构\n    * 双亲表示法：用一组连续的存储空间存储树的结点，同时在每个结点中，用一个变量存储该结点的双亲结点在数组中的位置。\n* 链式存储结构\n    * 孩子表示法：把每个结点的孩子结点排列起来存储成一个单链表。所以n个结点就有n个链表；\n如果是叶子结点，那这个结点的孩子单链表就是空的；\n然后n个单链表的的头指针又存储在一个顺序表（数组）中。\n\n    * 孩子兄弟表示法：顾名思义就是要存储孩子和孩子结点的兄弟，具体来说，就是设置两个指针，分别指向该结\n点的第一个孩子结点和这个孩子结点的右兄弟结点。\n### 二叉树\n* 定义\n    * 二叉树是n（n≥0）个结点的有限集合：\n① 或者为空二叉树，即n=0。\n② 或者由一个根结点和两个互不相交的被称为根的左子树\n和右子树组成。左子树和右子树又分别是一棵二叉树。 \n        * 1.每个结点最多有两棵子树。\n        * 2.左右子树有顺序\n* 二叉树的五种基本形态：\n    * 1.空树\n    * 2.只有一个根结点\n    * 3.根结点只有左子树\n    * 4.根结点只有右子树\n    * 5.根结点既有左子树又有右子树\n* 特殊二叉树\n    * 1.斜树\n    * 2.满二叉树:\n    * 3.完全二叉树\n* 二叉树的性质\n    * 1.非空二叉树上叶子结点数等于度为2的结点数加1\n    * 2.非空二叉树上第K层上至多有2^k−1个结点（K≥1）\n    * 3.高度为H的二叉树至多有2^H-1个结点（H≥1）\n    * 4.具有N个（N>0）结点的完全二叉树的高度为 [log2(N+1)]或[log2N] +1。\n### 二叉树的存储结构\n* 顺序存储\n    * 二叉树的顺序存储结构就是用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素。\n* 链式存储\n    * 二叉树每个结点最多两个孩子，所以设计二叉树的结点结构时考虑两个指针指向该结点的两个孩子。\n### 二叉树的遍历\n* 先序遍历：\n1）访问根结点；\n2）先序遍历左子树；\n3）先序遍历右子树。\n    * 递归\n    * 非递归\n* 中序遍历：\n1）中序遍历左子树；\n2）访问根结点；\n3）中序遍历右子树。\n    * 递归\n    * 非递归\n* 后序遍历：\n1）后序遍历左子树；\n2）后序遍历右子树；\n3）访问根结点。\n    * 递归\n    * 非递归\n* 层次遍历：\n若树为空，则什么都不做直接返回。\n否则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。\n\n### 线索二叉树\n* N个结点的二叉链表，每个结点都有指向左右孩子的\n结点指针，所以一共有2N个指针，而N个结点的二叉\n树一共有N-1条分支，也就是说存在2N-(N-1)=N+1个空指针。比如左图二叉树中有6个结点，那么就有7个空\n指针。\n\n* 大量的空余指针能否利用起来？\n    * 指向前驱和后继的指针称为线索，加上线索的二叉链表就称为线索链表，相应的二叉树就称为线索二叉树\n    * 对二叉树以某种次序遍历使其变为线索二叉树的过程就叫做线索化\n### 哈夫曼树和哈夫曼编码\n* 算法的描述如下：\n1）将这N个结点分别作为N棵仅含一个结点的二叉树，构成森林F。\n2）构造一个新结点，并从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值\n置为左、右子树上根结点的权值之和。\n3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中。\n4）重复步骤2）和3），直至F中只剩下一棵树为止。\n\n## 第五章：图\n### 图的基本概念\n* 定义：\n树是N（N≥0）个结点的有限集合，N=0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：\n1）有且仅有一个特定的称为根的结点。\n2）当N>1时，其余结点可分为m（m>0）个互不相交的有限集合T1，T2，…，Tm，其中每一个集合本身又是一棵树，并且称为根结点的子树。\n    * 图G由顶点集V和边集E组成，记为G=(V，E)\n        * V(G)表示图G中顶点的有限非空集。\n用|V|表示图G中顶点的个数，也称为图G的阶\n        * E(G)表示图G中顶点之间的关系（边）集合。\n用|E|表示图G中边的条数。\n* 分类\n    * 有向图\n        * 有向边（弧）的有限集合\n            * 弧是顶点的有序对\n            * <v,w>\n            * v是弧尾，w是弧头\n            * v邻接到w或w邻接自v\n    * 无向图\n        * 无向边的有限集合\n            * 边是顶点的无序对\n            * （v,w）\n            * （v,w）=(w,v)\n            * w，v互为邻接点\n* 简单图\n    * 1.不存在顶点到自身的边\n    * 2.同一条边不重复出现\n* 多重图\n    * 若图G中某两个结点之间的边数多于一条，又允许顶点通过通过同一个边和自己关联\n* 完全图\n    * 无向完全图\n        * 如果任意两个顶点之间都存在边\n    * 有向完全图\n        * 如果任意两个顶点之间都存在方向相反的两条弧\n* 子图\n* 连通图：图中任意两个顶点都是连通的\n* 连通分量：无向图中的极大连通子图\n    * 连通\n        * 顶点A到顶点B有路径\n    * 极大\n        * 1.顶点足够多\n        * 2.极大连通子图包含这些依附这些顶点的所有边\n    * 结论1:如果一个图有n个顶点，并且有小于n-1条边，则此图必是非连通图。\n    * 概要: 找连通分量的方法：\n从选取一个顶点开始，以这个顶点作为一个子图，然后逐个添加与这个子图相连的顶点和边直到所有相连的顶点都加入该子图\n* 强连通：顶点V到顶点W和顶点W到顶点V都有路径\n* 强连通图：图中任一对顶点都是强连通的\n* 连通图的生成树：包含图中全部n个顶点，但是只有n-1条边的极小连通子图\n    * 结论2:生成树去掉一条边则变成非连通图，加上一条边就会形成回路。\n* 度：以该顶点为一个端点的边数目\n    * 无向图中顶点V的度是指依附于该顶点的边的条数，记为TD(v)\n    * 有向图中顶点V的度分为出度和入度\n        * 入度（ID）是以顶点v为终点的有向边的数目\n        * 出度（OD）是以顶点V为起点的有向边的数目\n* 简单路径和简单回路：顶点不重复出现的路径称为简单路径。对于回路，除了第一个和最后一个顶点其余顶点不重复出现的回路称为简单回路\n* 权和网：图中每条边考研赋予一定意义的数值，这个数值叫做这条边的权，有权值得图称为带权图，也叫做网\n* 路径和路径长度：顶点p到q之间的路径是指顶点序列怕保存的，p,a,b,c,d,……q。路径上边的数目就是路径长度\n* 回路（环）：第一个和最后一个顶点相同的路径称为回路或者环\n* 距离：从顶点u到v的最短路径长度。不存在路径则为无穷\n### 图的存储结构\n* 邻接矩阵（顺序存储）\n* 邻接表（链式存储）\n    * 十字链表（有向图）\n    * 邻接多重表（无向图）\n### 图的遍历\n* 深度优先遍历\n    * 深度优先搜索(DFS:Depth-First-Search):深度优先搜索类似于树的先序遍历算法\n        * 空间复杂度：由于DFS是一个递归算法，递归是需要一个工作栈来辅助工作，最多需要图中所有顶点进栈，所以时间复杂度为O(|V|)\n        * 时间复杂度：1)邻接表：遍历过程的主要操作是对顶点遍历它的邻接点，由于通过访问边表来查找邻接点，所以时间复杂度为O(|E|),访问顶点时间为O(|V|),所以总的时间复杂度为O(|V|+|E|)\n                      2)邻接矩阵：查找每个顶点的邻接点时间复杂度为O(|V|),对每个顶点都进行查找，所以总的时间复杂度为O(|V|2)\n* 广度优先遍历\n    * 广度优先搜索(BFS:Breadth-First-Search):广度优先搜索类似于树的层序遍历算法\n        * 空间复杂度：BFS需要借助一个队列，n个顶点均需要入队一次，所以最坏情况下n个顶点在队列，那么则需要O(|V|)的空间复杂度。    \n        * 时间复杂度：\n1)邻接表：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，就需要访问这个顶点的所有边，所以时间复杂度为O(|E|)。所以总的时间复杂度为O(|V|+|E|)\n2)邻接矩阵：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，需要遍历一遍矩阵的一行，所以时间复杂度为O(|V|),所以总的时间复杂度为O(|V|2)\n\n### 图的应用\n* 最小生成树\n    * 普利姆（Prlm）\n        * ①从图中找第一个起始顶点v0，作为生成树的第一个顶点，然后从这个顶点到其他顶点的所有边中选一条权值最小的边。然后把这条边的另一个顶点v和这条边加入到生成树中。\n        * ②对剩下的其他所有顶点，分别检查这些顶点与顶点v的权值是否比这些顶点在lowcost数组中对应的权值小，如果更小，则用较小的权值更新lowcost数组。\n        * ③从更新后的lowcost数组中继续挑选权值最小而且不在生成树中的边，然后加入到生成树。\n        * ④反复执行②③直到所有所有顶点都加入到生成树中。\n        * 概要:  \n            * 双重循环，外层循环次数为n-1，内层并列的两个循环次数都是n。故普利姆算法时间复杂度为O(n2)\n而且时间复杂度只和n有关，所以适合稠密图\n    * 克鲁斯卡尔（Kruskal）\n        * 将图中边按照权值从小到大排列，然后从最小的边开始扫描，设置一个边的集合来记录，如果该边并入不构成回路的话，则将该边并入当前生成树。直到所有的边都检测完为止。\n        * 概要:  \n            * \n            *  \n            * 概要: 克鲁斯卡尔算法操作分为对边的权值排序部分和一个单重for循环，它们是并列关系，由于排序耗费时间大于单重循环，所以克鲁斯卡尔算法的主要时间耗费在排序上。排序和图中边的数量有关系，所以适合稀疏图\n* 最短路径\n    * 迪杰斯特拉\n        * 一个源点到其余顶点的最短路径\n            * 该算法设置一个集合S记录已求得的最短路径的顶点，可用一个数组s[]来实现，初始化为0，当s[vi]=1时表示将顶点vi放入S中，初始时把源点v0放入S中。此外，在构造过程中还设置了两个辅助数组：\ndist[]：记录了从源点v0到其他各顶点当前的最短路径长度，dist[i]初值为arcs[v0][i]。\npath[]：path[i]表示从源点到顶点i之间的最短路径的前驱结点，在算法结束时，可根据其值追溯得到源点v0到顶点vi的最短路径。\n\n假设从顶点0出发，也就是顶点0为源点，集合S最初只包含顶点0，邻接矩阵arcs表示带权有向图，arcs[i][j]表示有向边<i，j>的权值，若不存在有向边<i，j>，则arcs[i][j]为∞。Dijkstra算法的步骤如下：\n1）初始化：集合S初始为{0}，dist[]的初始值dist[i]=arcs[0][i]，i=1，2，…，n-1。\n2）找出dist[]中的最小值dist[j]，将顶点j加入集合S，即修改s[vj]=1。\n3）修改从v0出发到集合V-S上任一顶点vk可达的最短路径长度：如果dist[j] + arcs[j][k]< dist[k]，则令dist[k]=dist[j] + arcs[j][k]。另外更新path[k]=j(也就是顶点j加入集合之后如果有新的路径使得到顶点k路径变短的话就将到顶点k的路径长度修改成较短的)\n4）重复2）～3）操作共n-1次，直到所有的顶点都包含在S中。\n    * 弗洛伊德\n        * 所有顶点到所有顶点的最短路径\n            * 算法思想：\n递推产生一个n阶方阵序列A(−1)，A(0)，…，A(k)，…，A(n−1)\n其中A(k)[i][j]表示从顶点vi到顶点vj的路径长度，k表示绕行第k个顶点的运算步骤。初始时，对于任意两个顶点vi和vj，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以∞作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点k(k=0，1，…，n-1)作为中间顶点。如果增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径\n    * 非带权图\n        * 两点之间经过边数最少的路径\n    * 带权图\n        * 两点之间经过的边上权值之和最小的路径\n* 拓扑排序\n    * AOV\n        * 如果我们把每个环节看成图中一个顶点，在这样一个有向图中，用顶点表示活动，用弧表示活动之间的优先关系，那么这样的有向图称为AOV网(Activity On Vertex)\n\n    * 拓扑排序就是对一个有向图构造拓扑序列的过程，构造会有两种结果：\n如果此图全部顶点都被输出了，说明它是不存在回路的AOV网；\n如果没有输出全部顶点，则说明这个图存在回路，不是AOV网。\n    * 拓扑排序算法：\n     从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为弧尾的弧。重复这个步骤直到输出图中全部顶点，或者找不到入度为0的顶点为止。\n\n* 关键路径\n    * AOE(Activity On Edge):在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网称为AOE网。\n\n## 第六章：查找\n### 查找的基本概念和顺序查找\n* 查找定义：在数据集合中寻找满足某种条件的数据元素的过程称为查找\n* 关键字：数据元素中某个可以以唯一标识该元素的数据项\n* 平均查找长度（ASL：Average Search Length）:在查找的过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值\n* 顺序查找(线性查找)，主要用于在线性表中进行查找。从查找表的一端开始，顺序扫描查找表，依次将扫描到的关键字和待查找的值key进行比较。如果相等，则查找成功。如果扫描结束仍然没有发现相等的数据元素，则查找失败。\n    * 1\n    * 2\n    * 3 \n    * 4\n    * 时间复杂度为O(n)\n### 折半查找\n* 算法思路：\n    * 首先将给定值key与表中中间位置元素的关键字比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分中。然后在缩小的范围内继续进行同样的查找，如此重复直到找到为止，或者确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。\n* 折半查找分析\n    * 折半查找判定树\n        * 对于折半查找，查找的比较次数就是从根结点到该结点经历的结点数\n        * 时间复杂度为O(logn)\n        * 概要: 具有N个（N>0）结点的完全二叉树的高度为 [log2(N+1)] 或 [log2N] +1。\n\n### 分块查找\n* 分块查找又称为索引顺序查找\n* 分块查找思想：\n    * ①确定待查找值在哪个块（折半查找）\n\n②在确定的块中查找待查找值（顺序查找）\n* 分块查找分析\n    * 由于分块查找实际是进行两次查找，所以整个算法的平均查找长度是两次查找的平均查找长度之和。\n即ASL分块=ASL折半+ASL顺序\n        *  \n### 二叉排序树\n* 二叉排序树(Binary Search Tree 也叫二叉搜索树)或者是一棵空树，或者是具有以下性质的二叉树\n①若左子树不空，则左子树上所有结点的值均小于它的根结点的值。\n②若右子树不空，则右子树上所有结点的值均大于它的根结点的值。\n③它的左右子树也是一棵二叉排序树。\n* 算法思想\n    * 由于二叉排序树的特点(左子树<根结点<右子树),所以每次查找一个关键字，需要先和根结点进行比较：\n如果这个关键字小于根结点的值，则再到这个根结点的左子树进行同样的比较操作一直进行下去直到找到该关键字，表示查找成功，或者是空指针，表示查找失败。\n如果这个关键字大于根结点的值，则再到这个根结点的右子树进行同样的比较操作一直进行下去直到找到该关键字，表示查找成功，或者是空指针，表示查找失败。\n        * 查找关键字代码\n            * 1 \n            * 2\n        * 插入关键字代码\n            * 1)空树：直接插入新结点返回成功\n2)树不空：检查是否存在关键字重复的结点：\n①存在：返回插入失败\n②不存在：检查根结点的值和待插入关键字值的大小关系递归插入左右子树\n            *  \n        * 构造代码\n            *  \n        * 删除结点\n            * ①删除的是叶子结点\n                * 方法：直接删去该结点即可\n            * ②删除的是仅有左子树或者右子树的结点\n                * 方法：“子承父业”\n            * ③删除的是左右子树都有的结点\n                * 仿照②类型，先将一个孩子“继承父业”，另一个孩子“归顺”于这个孩子\n方法：找到待删除结点的直接前驱或者直接后继结点，用该结点来替换待删除结点，再删除该结点。\n* 二叉排序树分析\n    * 查找时间复杂度是O(n)\n* 概要: “左小右大”\n### 平衡二叉树(AVL树)\n* 平衡二叉树(AVL树)是特殊的二叉排序树，特殊的地方在于左右子树的高度之差绝对值不超过1，而且左右子树又是一棵平衡二叉树。\n* 平衡因子\n    * 定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是−1、0或1。\n* 平衡调整\n    * 平衡二叉树的建立过程和二叉排序树的建立过程是相似的，都是从一棵空树开始陆续插入结点。不同的地方在于对于平衡二叉树的建立过程中，由于插入结点可能会破坏结点的平衡性，所以需要进行平衡调整。\n\n        * LL调整(左孩子的左子树上插入结点导致)\n            * 最小不平衡子树根结点的平衡因子为2>0\n它的左孩子结点平衡因子为1>0\n两个都大于0，所以直接右旋就可以调整\n            * 概要: “正则右旋”\n        * RR调整(右孩子的右子树上插入结点导致)\n            *  最小不平衡子树根结点的平衡因子为-2<0\n它的右孩子结点平衡因子为-1<0\n两个都小于0，所以直接左旋就可以调整\n            * 概要: “负则左旋”\n        * LR调整(左孩子的右子树上插入结点导致)\n        * RL调整(右孩子的左子树上插入结点导致)\n        * 概要: 先局部转换为LL或RR，最后进行调整\n* 分析\n    * 含有n个结点平衡二叉树的最大深度为O(log2n)，因此，平衡二叉树的平均查找长度为O(log2n) \n### B树和B+树\n* 2-3树\n    * 2-3树是一种多路查找树：2和3的意思就是2-3树包含两种结点\n        * 1)2结点包含一个元素和两个孩子(或者没有孩子)。\n    ①左子树包含的元素小于该结点的元素值，右子树包含的元素大于该结点的元素值\n    ②2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子\n        * 2)3结点包含一大一小两个元素和三个孩子(或者没有孩子)。(两个元素按大小顺序排列好)\n    ①左子树包含的元素小于该结点较小的元素值，右子树包含的元素大于该结点较大的元素值，中间子树包含的元素介于这两个元素值之间。\n    ②3结点要不有三个孩子，要不就没有孩子，不允许有一个或两个孩子\n        * 3)2-3树所有叶子结点都在同一层次\n* 2-3-4树\n    * 2-3-4树也是一种多路查找树：2和3和4的意思就是2-3-4树包含三种结点\n        * 1)2结点包含一个元素和两个孩子(或者没有孩子)。\n    ①左子树包含的元素小于该结点的元素值，右子树包含的元素大于该结点的元素值\n    ②2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子\n        * 2)3结点包含一大一小两个元素和三个孩子(或者没有孩子)。\n    ①左子树包含的元素小于该结点较小的元素值，右子树包含的元素大于该结点较大的元素值，中间子树包含的元素介于这两个元素值之间。\n    ②3结点要不有三个孩子，要不就没有孩子，不允许有一个或两个孩子\n        * 3)4结点包含小中大三个元素和四个孩子(或者没有孩子)。\n    ①左子树包含的元素小于该结点最小的元素值，第二个子树包含大于最小的元素值小于中间元素值的元素，第三个子树包含大于中间元素值小于最大元素值的元素，右子树包含的元素大于该结点最大的元素值。   \n    ②4结点要不有四个孩子，要不就没有孩子，不允许有一个或两个或三个孩子\n        * 4)2-3-4树所有叶子结点都在同一层次\n* B树\n    * B树也是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例，我们把树中结点最大的孩子数目称为B树的阶。通常记为m。\n一棵m阶B树或为空树，或为满足如下特性的m叉树：\n        * 1）树中每个结点至多有m棵子树。（即至多含有m-1个关键字) (\"两棵子树指针夹着一个关键字\")\n        * 2）若根结点不是终端结点，则至少有两棵子树。(至少一个关键字)\n        * 3）除根结点外的所有非叶结点至少有 ⌈m/2⌉棵子树。（即至少含有⌈m/2⌉-1个关键字）\n        * 4）所有非叶结点的结构如下：\n        * 5）所有的叶子结点出现在同一层次上，不带信息。(就像是折半查找判断树中查找失败的结点)\n    * 1.B树的查找操作\n        * 查找过程：①先让待查找关键字key和结点的中的关键字比较，如果等于其中某个关键字，则查找成功。\n                  ②如果和所有关键字都不相等，则看key处在哪个范围内，然后去对应的指针所指向的子树中查找。\n                      Eg:如果Key比第一个关键字K1还小，则去P0指针所指向的子树中查找，如果比最后一个关键字Kn还大，则去Pn指针所指向的子树中查找。\n\n    * 2.B树的插入操作\n        * 分裂的方法：取这个关键字数组中的中间关键字(⌈n/2⌉)作为新的结点，然后其他关键字形成两个结点作为新结点的左右孩子。\n    * 3.B树的删除操作\n        * B树中的删除操作与插入操作类似，但要稍微复杂些，要使得删除后的结点中的关键字个数≥⌈m/2⌉-1 ，因此将涉及结点的“合并”问题。由于删除的关键字位置不同，可以分为关键字在终端结点和不在终端结点上两种情况。\n            * 1）如果删除的关键字在终端结点上（最底层非叶子结点）：\n      ①结点内关键字数量大于⌈m/2⌉-1 ，这时删除这个关键字不会破坏B树的定义要求。所以直接删除。\n      ②结点内关键字数量等于⌈m/2⌉-1 ，并且其左右兄弟结点中存在关键字数量大于⌈m/2⌉-1 的结点，则去兄弟阶段中借关键字。\n      ③结点内关键字数量等于⌈m/2⌉-1 ，并且其左右兄弟结点中不存在关键字数量大于⌈m/2⌉-1 的结点，则需要进行结点合并。\n\n            * 2）如果删除的关键字不在终端结点上（最底层非叶子结点）：需要先转换成在终端结点上，再按照在终端结点     上的情况来分别考虑对应的方法。\n                * 相邻关键字：对于不在终端结点上的关键字,它的相邻关键字是其左子树中值最大的关键字或者右子树中值最小的关键字。\n                * 第一种情况：存在关键字数量大于⌈m/2⌉-1 的左子树或者右子树，在对应子树上找到该关键字的相邻关键字，然后将相邻关键字替换待删除的关键字。\n                * 第二种情况：左右子树的关键字数量均等于⌈m/2⌉-1 ，则将这两个左右子树结点合并，然后删除待删除关键字。\n* B+树\n    * B+树是常用于数据库和操作系统的文件系统中的一种用于查找的数据结构\n    * m阶的B+树与m阶的B树的主要差异在于：\n1）在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；而在B树中，具有n个关键字的结点含有(n+1)棵子树。\n2）在B+树中，每个结点（非根内部结点）关键字个数n的范围是 ⌈m/2⌉≤n≤m（根结点1≤n≤m），在B树中，每个结点（非根内部结点）关键字个数n的范围是⌈m/2⌉ -1≤n≤m-1（根结点：1≤n≤m-1）。\n3）在B+树中，叶结点包含信息，所有非叶结点仅起到索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。\n4）在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。\n### 散列表\n* 散列表：根据给定的关键字来计算出关键字在表中的地址的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。\n* 散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr。\n* 散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为“冲突”，这些发生碰撞的不同关键字称为同义词。\n* 构造散列函数的tips：\n    * 1）散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。\n    * 2）散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间，从而减少冲突的发生。\n    * 3）散列函数应尽量简单，能够在较短的时间内就计算出任一关键字对应的散列地址。\n* 1.常用Hash函数的构造方法：\n    * 1.开放定址法：直接取关键字的某个线性函数值为散列地址，散列函数为H(key)=a×key+b。式中，a和b是常数。这种方法计算最简单，并且不会产生冲突\n    * 2.除留余数法：假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用以下公式把关键字转换成散列地址。散列函数为H(key)=key % p\n除留余数法的关键是选好p，使得每一个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性\n    * 3.数字分析法：设关键字是r进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，则应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合\n    * 4.平方取中法：顾名思义，取关键字的平方值的中间几位作为散列地址。具体取多少位要看实际情况而定。这种方法得到的散列地址与关键字的每一位都有关系，使得散列地址分布比较均匀。\n    * 5.折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以短一些），然后取这几部分的叠加和作为散列地址，这种方法称为折叠法。关键字位数很多，而且关键字中每一位上数字分布大致均匀时，可以采用折叠法得到散列地址。\n\n* 2.常用Hash函数的冲突处理办法：\n    * 1.开放定址法：将产生冲突的Hash地址作为自变量，通过某种冲突解决函数得到一个新的空闲的Hash地址。\n        * 1）线性探测法：冲突发生时，顺序查看表中下一个单元（当探测到表尾地址m-1时，下一个探测地址是表首地址0），直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。\n        * 2）平方探测法：设发生冲突的地址为d,平方探测法得到的新的地址序列为d+12，d-12，d+22，d-22......\n平方探测法是一种较好的处理冲突的方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。\n        * 3）再散列法：又称为双散列法。需要使用两个散列函数，当通过第一个散列函数H(Key)得到的地址发生冲突时，则利用第二个散列函数Hash2(Key)计算该关键字的地址增量。\n        * 4）伪随机序列法：当发生地址冲突时，地址增量为伪随机数序列，称为伪随机序列法。\n    * 2.拉链法：对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。拉链法适用于经常进行插入和删除的情况。\n    * 3.散列表的查找过程：类似于构造散列表，给定一个关键字Key。\n      先根据散列函数计算出其散列地址。然后检查散列地址位置有没有关键字。\n         1)如果没有，表明该关键字不存在，返回查找失败。\n         2)如果有，则检查该记录是否等于关键字。\n                 ①如果等于关键字，返回查找成功。\n                 ②如果不等于，则按照给定的冲突处理办法来计算下一个散列地址，再用该地址去执行上述过程。\n    * 4.散列表的查找性能：和装填因子有关。\n        *  \n        * α越大，表示装填的记录越“满”，发生冲突的可能性就越大，反之发生冲突的可能性越小\n## 第七章：排序\n### 排序的基本知识\n* 定义：排序就是将原本无序的序列重新排列成有序的序列。\n* 排序的稳定性\n    * 如果待排序表中有两个元素Ri、Rj，其对应的关键字keyi=keyj，且在排序前Ri在Rj前面，如果使用某一排序算法排序后，Ri仍然在Rj的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。\n### 插入类排序\n* 直接插入排序\n    * 直接插入排序：首先以一个元素为有序的序列，然后将后面的元素依次插入到有序的序列中合适的位置直到所有元素都插入有序序列。\n    * 时间复杂度为O(n)\n    * 直接插入排序是稳定性是稳定的。\n* 折半插入排序\n    * 折半插入排序将比较和移动这两个操作分离出来，也就是先利用折半查找找到插入的位置，然后一次性移动元素，再插入该元素。\n    * 折半插入排序的时间复杂度为O(n^2)\n    * 稳定性：和直接插入排序稳定性相同，是稳定的。\n* 希尔排序\n    * 希尔排序的基本思想：希尔排序本质上还是插入排序，只不过是把待排序序列分成几个子序列，再分别对这几个子序列进行直接插入排序。\n        * ①先以增量5来分割序列，也就是下标为0,5,10,15...的关键字分成一组，下标为1,6,11,16..分成一组,然后对这些组分别进行直接插入排序，这就完成了一轮希尔排序。\n        * ②缩小增量(d1=n/2，di+1= [di/2]，比如10个数据序列，第一次增量d1=10/2=5,第二次增量d2= [d1/2]= [5/2]=2,并且最后一个增量等于1),所以第二轮以增量为2进行类似的排序过程。\n        * ③接下来的第三轮，第四轮...都是类似的过程，直到最后一轮以增量为1。此时就是前面所说的直接插入排序。\n        * 概要:  \n    * 时间复杂度：...  希尔排序的时间复杂度约为O(n^1.3)    在最坏情况下希尔排序的时间复杂度为O(n^2)\n    * 空间复杂度：希尔排序的空间复杂度为O(1)\n    * 稳定性：不稳定，由于不同的增量可能就会把相等的关键字划分到两个直接插入排序中进行排序， 可能就会造成相对顺序变化。\n### 交换类排序\n* 冒泡排序\n    * 假设待排序表长为n，从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]>A[i]），则交换它们，直到序列比较完。我们称它为一趟冒泡，结果将最小的元素交换到待排序列的第一个位置。下一趟冒泡时，前一趟确定的最小元素不再参与比较，待排序列减少一个元素，每趟冒泡的结果把序列中的最小元素放到了序列的最终位置，……，这样最多做n-1趟冒泡就能把所有元素排好序。\n    * 空间复杂度：交换时开辟了存储空间来存储中间变量，所以空间复杂度为O(1)\n    * 时间复杂度\n    * 稳定性：当两个关键字相等，if判断条件不成立，所以不会发生数据移动。所以是稳定的。\n* 快速排序\n    * 快速排序是一种基于分治法的排序方法。\n每一趟快排选择序列中任一个元素作为枢轴(pivot)(通常选第一个元素)，将序列中比枢轴小的元素都移到枢轴前边，比枢轴大的元素都移到枢轴后边。\n        * 1\n        * 2\n    * 时间复杂度：\n最好情况下时间复杂度为O(nlogn) ,待排序序列越无序，算法效率越高。\n 最坏情况下时间复杂度为O(n^2)，待排序序列越有序，算法效率越低。\n    * 空间复杂度：\n由于快速排序是递归的，需要借助一个递归工作栈来保存每一层递归调用的必要信息，其容量应与递归调用的最大深度一致。\n最好情况下为 ⌈log2(n+1)⌉(每次partition都很均匀)递归树的深度O(logn)\n最坏情况下，因为要进行n-1次递归调用，所以栈的深度为O(n)；\n    * 稳定性：快速排序是不稳定的，是因为存在交换关键字。\n### 选择类排序\n* 简单选择排序\n    *  \n    * 空间复杂度：需要额外的存储空间仅为交换元素时借助的中间变量，所以空间复杂度是O(1)\n    * 时间复杂度：\n关键操作在于交换元素操作，整个算法由双重循环组成，外层循环从0到n-2一共n-2+1=n-1次，\n对于第i层外层循环，内层循环执行n-1-(i+1)+1=n-i-1次。\n                      当i=0,内层循环执行n-1次，当i=n-2,内层循环执行1次，所以是一个等差数列求和,一共为(1+n-1)(n-1)/2=n(n-1)/2 ,所以时间复杂度为O(n^2)\n    * 稳定性：不稳定   原因就在于交换部分会打破相对顺序\n* 堆排序\n    * 什么是堆？\n        * 堆是一棵完全二叉树，而且满足任何一个非叶结点的值都不大于(或不小于)其左右孩子结点的值。\n            * 如果是每个结点的值都不小于它的左右孩子结点的值，则称为大顶堆。\n            * 如果是每个结点的值都不大于它的左右孩子结点的值，则称为小顶堆。\n    * 什么是堆排序？\n        * 我们知道对于一个堆来说，它的根结点是整个堆中所有结点的值的最大值(大顶堆)或者最小值(小顶堆)。所以堆排序的思想就是每次将无序序列调节成一个堆，然后从堆中选择堆顶元素的值，这个值加入有序序列，无序序列减少一个，再反复调节无序序列，直到所有关键字都加入到有序序列。\n            *  \n            *  \n        * 时间复杂度：\n       堆排序的总时间可以分为①建堆部分+②n-1次向下调整堆\n\n       堆排序的时间复杂度为O(n)+O(nlog2n)=O(nlog2n)\n        * 堆排序不稳定\n### 归并排序\n* 假定待排序表含有n个记录，则可以看成是n个有序的子表，每个子表长度为1，然后两两归并，得到 ⌈n/2⌉个长度为2或1的有序表；再两两归并，……如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为2-路归并排序。\n    *   \n    *  \n* 例如：49 38 65 97 76 13 27\n    * ①首先将整个序列的每个关键字看成一个单独的有序的子序列\n    * ②两两归并，49和38归并成{38 49} ，65和97归并成{65 97}，76和13归并成{13 76}，27没有归并对象\n    * ③两两归并，{38 49}和{65 97}归并成{38 49 65 97}，{13,76}和27归并成{13 27 76}\n    * ④两两归并，{38 49 65 97}和{13 27 76}归并成{13 27 38 49 65 76 97}\n* 时间复杂度：O(nlog2n)\n* 空间复杂度:因为需要将这个待排序序列转存到一个数组，所以需要额外开辟大小为n的存储空间，即空间复杂度为O(n)\n* 稳定性：稳定\n### 基数排序\n* 基数排序(也叫桶排序)是一种很特别的排序方法，它不是基于比较进行排序的，而是采用多关键字排序思想（即基于关键字各位的大小进行排序的），借助“分配”和“收集”两种操作对单逻辑关键字进行排序。基数排序又分为最高位优先（MSD）排序和最低位优先（LSD）排序。\n* 例子：53, 3, 542, 748, 14, 214, 154, 63, 616\n    * 补充位数：053, 003, 542, 748, 014, 214, 154, 063, 616\n    * 桶实际是一个队列，先进先出(从桶的上面进，下面出)\n    * 关键字数量为n,关键字的位数为d,比如748 d=3，r为关键字的基的个数，就是组成关键字的数据的种类，比如十进制数字一共有0至9一共10个数字，即r=10\n* 空间复杂度：需要开辟关键字基的个数个队列，所以空间复杂度为O(r)\n* 时间复杂度：需要进行关键字位数d次\"分配\"和\"收集\"，一次\"分配\"需要将n个关键字放进各个队列中，一次\"收集\"需要将r个桶都收集一遍。所以一次\"分配\"和一次\"收集\"时间复杂度为O(n+r)。d次就需要O(d(n+r))的时间复杂度。\n* 稳定性：由于是队列，先进先出的性质，所以在分配的时候是按照先后顺序分配，也就是稳定的，所以收集的时候也是保持稳定的。即基数排序是稳定的排序算法。\n### 外部排序\n* 需要将待排序的记录存储在外存上，排序时再把数据一部分一部分的调入内存进行排序。在排序过程中需要多次进行内存和外存之间的交换，对外存文件中的记录进行排序后的结果仍然被放到原有文件中。这种排序的方法就叫做外部排序。\n* 如何得到初始的归并段\n    * 置换选择排序：解决排序段放入内存的问题\n* 如何减少多个归并段的归并次数\n    * 最佳归并树：最少的归并次数（I/O次数）\n* 如何每次m路归并快速得到最小的关键字\n    * 败者树：减少比较次数\n* 概要: 内存容量无法容纳大量数据\n## 二叉树与树与森林\n### 树与二叉树\n* 如何将一棵树转化成二叉树？\n    * 树的孩子兄弟表示法与二叉树的二叉链表表示法都是用到两个指针\n        * 将孩子兄弟表示法理解成二叉链表\n    * 树转换成二叉树的手动模拟方法：\n        * ①将同一结点的各个孩子用线串连起来\n        * ②将每个结点的子树分支，从左往右，除了第一个以外全部删除\n        * 概要: 例子\n* 如何将一棵二叉树转化成树？\n    * 二叉树转换成树的手动模拟方法：\n        * ①将二叉树从上到下分层，并调节成水平方向。\n(分层方法：每遇到左孩子则为一层)\n        * ②找到每一层的双亲结点，方法为它的上一层相连的那个结点就是双亲结点。\n例如bcd这一层，与它相连的上一层结点即为a,所以bcd这三个结点的双亲结点都是a.\n        * ③将每一层结点和其双亲结点相连，同时删除该双亲结点各个孩子结点之间的联系。\n        * 概要: 例子\n### 森林与二叉树\n* 森林：森林是m（m≥0）棵互不相交的树的集合\n* 如何将森林转换成二叉树？\n    * 森林转换成树的手动模拟方法：\n        * ①将森林中每棵树都转换成二叉树\n        * ②将第二棵树作为第一棵树的根结点的右子树，将第三棵树作为第二棵树的根结点的右子树..依次类推\n        * 概要: 例子\n* 如何将二叉树转换成森林？\n    * 二叉树转换成森林的手动模拟方法：\n        * 反复断开二叉树根结点的右孩子的右子树指针，直到不存在根结点有右孩子的二叉树为止。\n        * 概要: 例子\n### 树与森林的遍历\n* 先序：先访问根结点，再访问根结点的每棵子树。           访问子树也是按照先序的要求\n* 后序：先访问根结点的每棵子树，再访问根结点。           访问子树也是按照先序的要求\n* 树的先序遍历等于它对应二叉树的先序遍历，后序遍历等于它对应的二叉树的中序遍历\n* 概要: 例子\n","source":"_posts/2023-06-14-数据结构.md","raw":"# 数据结构\n## 第一章：数据结构的\n基本概念\n### 定义\n* 在任何问题中，数据元素都不是孤立存在的，而是在它们之间存在着某种关系，这种数据元素相互之间的关系称为结构（Structure）。数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。\n### 逻辑结构\n* 逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的\n* 数据的逻辑结构分为线性结构和非线性结构\n    * 集合 结构中的数据元素之间除了“同属于一个集合”的关系外，别无其他关系。 类似于数学上的集合\n    * 线性结构 结构中的数据元素之间只存在一对一的关系。比如排队\n    * 树形结构 结构中的数据元素之间存在一对多的关系。比如家族族谱\n    * 图状结构或网状结构 结构中的数据元素之间存在多对多的关系。 比如地图\n### 物理结构\n* 存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。数据的存储结构主要有：顺序存储、链式存储、索引存储和散列存储。\n    * 顺序存储：存储的物理位置相邻。（p.s. 物理位置即信息在计算机中的位置。）\n    * 链接存储：存储的物理位置未必相邻，通过记录相邻元素的物理位置来找到相邻元素。\n    * 索引存储：类似于目录，以后可以联系操作系统的文件系统章节来理解。\n    * 散列存储：通过关键字直接计算出元素的物理地址（以后详解）。\n### 算法的五个特征\n* 1，有穷性：有限步之后结束\n* 2，确定性：不存在二义性，即没有歧义\n* 3，可行性：比如受限于计算机的计算能力，有些算法虽然理论上可行，但实际上无法完成。\n* 4，输入：能被计算机处理的各种类型数据，如数字，音频，图像等等。\n* 5，输出：一至多个程序输出结果。\n### 算法的复杂度\n* 时间复杂度：\n    * • 它用来衡量算法随着问题规模增大，算法执行时间增长的快慢；\n    * • 是问题规模的函数：T(n)是时间规模函数 时间复杂度主要分析T(n)的数量级\n    * • T(n)=O(f(n)) f(n)是算法中基本运算的频度 一般我们考虑最坏情况下的时间复杂度\n* 空间复杂度：\n    * • 它用来衡量算法随着问题规模增大，算法所需空间的快慢；\n    * • 是问题规模的函数：S(n)=O(g(n)) ；算法所需空间的增长率和g(n)的增长率相同。\n### 概要: 复杂度计算为重点\n* 常用的时间复杂度大小关系：\n* 复杂度如何计算\n    * 时间复杂度计算（单个循环体）\n        * 直接关注循环体的执行次数，设为k \n    * 时间复杂度计算（多个循环体）\n        * 两个运算规则：乘法规则，加法规则。\n## 第二章：线性表\n### 线性表的逻辑结构\n* 定义：线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列。其中n为表长。当n=0时 线性表是一个空表\n* 特点：线性表中第一个元素称为表头元素；最后一个元素称为表尾元素。\n除第一个元素外，每个元素有且仅有一个直接前驱。\n除最后一个元素外，每个元素有且仅有一个直接后继。\n### 线性表的顺序存储结构\n* 线性表的顺序存储又称为顺序表。\n它是用一组地址连续的存储单元（比如C语言里面的数组），依次存储线性表中的数据元素，从而使得逻\n辑上相邻的两个元素在物理位置上也相邻。\n* 建立顺序表的三个属性: \n1.存储空间的起始位置（数组名data）\n2.顺序表最大存储容量（MaxSize）\n3.顺序表当前的长度（length）\n* 其实数组还可以动态分配空间，存储数组的空间是在程序执行过程中通过动态存储分配语句分配\n* 总结：\n    * 1.顺序表最主要的特点是随机访问（C语言中基于数组），即通过首地址和元素序号可以在O(1)的时间内找到指定的元素。\n    * 2.顺序表的存储密度高，每个结点只存储数据元素。无需给表中元素花费空间建立它们之间的逻辑关系（因为物理位置相邻特性决定）\n    * 3.顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。\n### 顺序表的操作\n* 1.插入\n    * 算法思路：\n        * 1.判断i的值是否正确\n        * 2.判断表长是否超过数组长度\n        * 3.从后向前到第i个位置，分别将这些元素都向后移动一位\n        * 4.将该元素插入位置i 并修改表长\n    * 代码\n    * 分析：\n        * 最好情况：在表尾插入（即i=n+1），元素后移语句将不执行，时间复杂度为O(1)。\n        * 最坏情况：在表头插入（即i=1），元素后移语句将执行\nn次，时间复杂度为O(n)。\n        * 平均情况：假设pi（pi=1/(n+1) ）是在第i个位置上插入\n一个结点的概率，则在长度为n的线性表中插入一个结\n点时所需移动结点的平均次数为\n* 2.删除\n    * 算法思路：\n        * 1.判断i的值是否正确\n        * 2.取删除的元素\n        * 3.将被删元素后面的所有元素都依次向前移动一位\n        * 4.修改表长\n    * 代码\n    * 分析\n        * 最好情况：删除表尾元素（即i=n），无须移动元素，时间复杂度为O(1)。\n        * 最坏情况：删除表头元素（即i=1），需要移动除第一个元素外的所有元素，时间复杂度为O(n)。\n        * 平均情况：假设pi(pi=1/n)是删除第i个位置上结点的概率，则在长度为n的线性表中删除一个结点时所需移动结点的平均次数为\n### 线性表的链式存储结构\n* 线性表的链式存储是指通过一组任意的存储单元来存储线性表中的数据元素。\n* 头结点和头指针的区别？\n    * 不管带不带头结点，头指针始终指向链表的第一个结点，而头结点是带头结点链表中的第一个结点，结点内通常不存储信息\n* 为什么要设置头结点？\n    * 1.处理操作起来方便 例如：对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了\n    * 2.无论链表是否为空，其头指针是指向头结点的非空指针，因此空表和非空表的处理也就统一了。\n### 单链表的操作\n* 1.头插法建立单链表：\n    * 建立新的结点分配内存空间，将新结点插入到当前链表的表头\n    * 代码\n* 2.尾插法建立单链表：\n    * 建立新的结点分配内存空间，将新结点插入到当前链表的表尾\n    * 代码\n* 3.按序号查找结点\n    * 在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止,否则返回最后一个结点指针域NULL。\n    * 代码\n* 4.按值查找结点\n    * 从单链表第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针；若整个单链表中没有这样的结点，则返回NULL。\n    * 代码\n* 5．插入\n    * 插入操作是将值为x的新结点插入到单链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i−1个结点，再在其后插入新结点。\n    * 算法思路：\n1.取指向插入位置的前驱结点的指针\n① p=GetElem(L,i-1);\n2.令新结点*s的指针域指向*p的后继结点\n② s->next=p->next;\n3.令结点*p的指针域指向新插入的结点*s\n③ p->next=s; \n* 6．删除\n    * 删除操作是将单链表的第i个结点删除。先检查删除位置的合法性，然后查找表中第i−1个结点，即被删结点的前驱结点，再将其删除。\n    * 算法思路：\n1.取指向删除位置的前驱结点的指针 p=GetElem(L,i-1);\n2.取指向删除位置的指针 q=p->next;\n3.p指向结点的后继指向被删除结点的后继 p->next=q->next\n4.释放删除结点 free(q);\n### 双链表\n* 定义\n* 1.插入：(方法不唯一)\n① s->next=p->next;\n② p->next->prior=s;\n③ s->prior=p;\n④ p->next=s;\n* 2.删除：\n① p->next=q->next;\n② q->next->prior=p;\n③ free(q);\n\n### 循环链表&&静态链表\n* 循环单链表：循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环\n* 循环双链表：类比循环单链表，循环双链表链表区别于双链表就是首尾结点构成环\n    * 当循环双链表为空表时，其头结点的prior域和next域都等于Head。\n* 静态链表：静态链表是用数组来描述线性表的链式存储结构。\n    * 数组第一个元素不存储数据，它的指针域存储第一个元素所在的数组下标。链表最后一个元素的指针域值为-1。\n    * 例子\n## 第三章：栈和队列\n### 栈\n* 栈（Stack）：只允许在一端进行插入或删除操作的线性表。\n* 栈顶（Top）：线性表允许进行插入和删除的那一端。\n* 栈底（Bottom）：固定的，不允许进行插入和删除的另一端\n* 特点：\n1.栈是受限的线性表，所以自然具有线性关\n系。\n2.栈中元素后进去的必然先出来，即后进先出\nLIFO（Last In First Out）\n    * 栈中元素后进\n去的必然先出\n来，即后进先\n出LIFO（Last In\nFirst Out）\n* 顺序栈\n    * 栈是线性表的特例，那栈的顺序存储也是线性表顺序存储的简化。栈的顺序存储结构也叫作顺序栈。\n    * 顺序栈的操作\n        * 1.判空：\n        * 2.进栈：\n        * 3.出栈：\n        * 4.读取栈顶元素：\n* 共享栈\n    * 顺序栈的存储空间大小需要事先开辟好，很多时候对每个栈各自单独开辟存储空间的利用率不如将各个栈的存储空间共享\n    * 示意图\n    * 共享栈的结构\n    * 共享栈的操作：（进栈）\n* 链式栈\n    * 栈是线性表的特例，线性表的存储结构还有链式存储结构，所以也可以用链表的方式来实现栈。栈的链式存储结构也叫作链栈。\n    * 特点\n1.链栈一般不存在栈满的情况。\n2.空栈的判定条件通常定为top==NULL；\n    * 结构\n    * 链式栈的操作\n        * 1.进栈\n        * 2.出栈\n### 队列\n* 队列是只允许在一端进行插入，而在另一端进行删除的线性表\n* 队头（Front）：允许删除的一端，又称为队首。\n* 队尾（Rear）： 允许插入的一端。\n* 先进入队列的元素必然先离开队列，即先进先出（First In First Out）简称FIFO\n* 顺序队列\n    * 用数组来实现队列，可以将队首放在数组下标为0的位置。\n* 循环队列\n    * 把数组“掰弯”，形成一个环。Rear指针到了下标为4的位置还能继续指回到下标为0的地方。这样首尾相连的顺序存储的队列就叫循环队列\n    * 入队：rear=(rear+1)%MaxSize\n    * 出队：front=(front+1)%MaxSize\n    * 循环队列的操作\n        * 1.入队：\n        * 2.出队：\n    * 概要: 那如何分辨队列是空还是满呢？\n        * 方法一：设置标志位flag，当flag=0且rear等于front时为队列空，当flag=1且rear等于front时为队列满。\n        * 方法二：我们把front=rear仅作为队空的判定条件。当队列满的时候，令数组中仍然保留一个空余单元。我们认为这种情况就是队列满了。\n* 链式队列\n    * 队列的链式存储结构，其实就是线性表的单链表，只不过需要加点限制，只能表尾插入元素，表头删除元素。\n    * 为了方便操作，我们分别设置队头指针和队尾指针，队头指针指向头结点，队尾指针指向尾结点。\n    * 链式队列的操作\n        * 1.入队：我们知道队列只能从队尾插入元素，队头删除元素。于是入队就是在队尾指针进行插入结点操作。链队的插入操作和单链表的插入操作是一致的。\n\n        * 2.出队：出队就是头结点的后继结点出队，然后将头结点的后继改为它后面的结点。\n* 双端队列\n    * 双端队列是指允许两端都可以进行入队和出队操作的队列\n### 栈的应用\n* 1、括号匹配：假设有两种括号，一种圆的()，一种方的[]，嵌套的顺序是任意的。\n    * 算法思想：若是左括号，入栈；若是右括号，出栈一个左括号判断是否与之匹配；检验到字符串尾，还要检查栈是否为空。只有栈空，整个字符串才是括号匹配的。\n\n    * 代码\n* 2、表达式求值：\n    *  \n    * 规则：从左到右扫描表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈然后跟这个符号进行运算，最后将运算结果进栈，直到最终获得结果。\n* 3、递归：\n    * 要理解递归，你要先理解递归，直到你能理解递归。\n如果在一个函数、过程或数据结构的定义中又应用了它自身，那么这个函数、过程或数据结构称为是递归定义的，简称递归。递归最重要的是递归式和递归边界。\n    * 1.阶乘\n        * 时间复杂度：O(NlogN)\n    * 2.斐波那契数列\n        * 时间复杂度   O(2^n)\n* 概要: 如何将中缀表达式转换成后缀表达式？\n    * 1.按运算符优先级对所有运算符和它的运算数加括号。(原本的括号不用加)\n    * 2.把运算符移到对应的括号后。\n    * 3.去掉括号。\n    * 例子\n## 第四章：树\n### 树的基本概念\n* 树是递归定义的结构\n* 结点\n    * 根节点：树只有一个根结点\n    * 结点的度：结点拥有的子树的数量\n        * 度为0：叶子结点或者终端结点\n        * 度不为0：分支结点或者非终端结点\n            * 分支结点除去根结点也称为内部结点\n* 树的度：树中所有结点的度数的最大值\n* 结点关系\n    * 祖先结点\n        * 根结点到该结点的唯一路径的任意结点\n    * 子孙结点\n    * 双亲结点\n        * 根结点到该结点的唯一路径上最接近该结点的结点\n    * 孩子结点\n    * 兄弟结点\n        * 有相同双亲结点的结点\n* 层次，高度，深度，树的高度\n    * 层次：根为第一层，它的孩子为第二层，以此类推\n    * 结点的深度：根结点开始自顶向下累加\n    * 结点的高度：叶节点开始自底向上累加\n    * 树的高度（深度）：树中结点的最大层数\n* 树的性质\n    * 1.树中的结点数等于所有结点的度数加1。\n        * 证明：不难想象，除根结点以外，每个结点有且仅有一个指向它的前驱结点。也就是说每个结点和指向它的分支一一对应。\n假设树中一共有b个分支，那么除了根结点，整个树就包含有b个结点，所以整个树的结点数就是这b个结点加上根结点，设为n，则n=b+1。而分支数b也就是所有结点的度数，证毕。\n    * 2.度为m的树中第i层上至多有m^(i−1)个结点（i≥1）。\n        * 证明：（数学归纳法）\n首先考虑i=1的情况：第一层只有根结点，即一个结点，i=1带入式子满足。\n假设第i-1层满足这个性质，第i-1层最多有m i-2个结点。\n……… ..........\ni-1层\n………\n又因为树的度为m,所以对于第i-1层的每个结点，最多\n有m个孩子结点。所以第i层的结点数最多是i-1层的m\n倍，所以第i层上最多有m ^(i-1)个结点。\n    * 3.高度为h的m叉树至多有(m^h-1)/(m-1)个结点\n    * 4.具有n个结点的m叉树的最小高度为logm(n(m-1)+1) \n### 树的存储结构\n* 顺序存储结构\n    * 双亲表示法：用一组连续的存储空间存储树的结点，同时在每个结点中，用一个变量存储该结点的双亲结点在数组中的位置。\n* 链式存储结构\n    * 孩子表示法：把每个结点的孩子结点排列起来存储成一个单链表。所以n个结点就有n个链表；\n如果是叶子结点，那这个结点的孩子单链表就是空的；\n然后n个单链表的的头指针又存储在一个顺序表（数组）中。\n\n    * 孩子兄弟表示法：顾名思义就是要存储孩子和孩子结点的兄弟，具体来说，就是设置两个指针，分别指向该结\n点的第一个孩子结点和这个孩子结点的右兄弟结点。\n### 二叉树\n* 定义\n    * 二叉树是n（n≥0）个结点的有限集合：\n① 或者为空二叉树，即n=0。\n② 或者由一个根结点和两个互不相交的被称为根的左子树\n和右子树组成。左子树和右子树又分别是一棵二叉树。 \n        * 1.每个结点最多有两棵子树。\n        * 2.左右子树有顺序\n* 二叉树的五种基本形态：\n    * 1.空树\n    * 2.只有一个根结点\n    * 3.根结点只有左子树\n    * 4.根结点只有右子树\n    * 5.根结点既有左子树又有右子树\n* 特殊二叉树\n    * 1.斜树\n    * 2.满二叉树:\n    * 3.完全二叉树\n* 二叉树的性质\n    * 1.非空二叉树上叶子结点数等于度为2的结点数加1\n    * 2.非空二叉树上第K层上至多有2^k−1个结点（K≥1）\n    * 3.高度为H的二叉树至多有2^H-1个结点（H≥1）\n    * 4.具有N个（N>0）结点的完全二叉树的高度为 [log2(N+1)]或[log2N] +1。\n### 二叉树的存储结构\n* 顺序存储\n    * 二叉树的顺序存储结构就是用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素。\n* 链式存储\n    * 二叉树每个结点最多两个孩子，所以设计二叉树的结点结构时考虑两个指针指向该结点的两个孩子。\n### 二叉树的遍历\n* 先序遍历：\n1）访问根结点；\n2）先序遍历左子树；\n3）先序遍历右子树。\n    * 递归\n    * 非递归\n* 中序遍历：\n1）中序遍历左子树；\n2）访问根结点；\n3）中序遍历右子树。\n    * 递归\n    * 非递归\n* 后序遍历：\n1）后序遍历左子树；\n2）后序遍历右子树；\n3）访问根结点。\n    * 递归\n    * 非递归\n* 层次遍历：\n若树为空，则什么都不做直接返回。\n否则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。\n\n### 线索二叉树\n* N个结点的二叉链表，每个结点都有指向左右孩子的\n结点指针，所以一共有2N个指针，而N个结点的二叉\n树一共有N-1条分支，也就是说存在2N-(N-1)=N+1个空指针。比如左图二叉树中有6个结点，那么就有7个空\n指针。\n\n* 大量的空余指针能否利用起来？\n    * 指向前驱和后继的指针称为线索，加上线索的二叉链表就称为线索链表，相应的二叉树就称为线索二叉树\n    * 对二叉树以某种次序遍历使其变为线索二叉树的过程就叫做线索化\n### 哈夫曼树和哈夫曼编码\n* 算法的描述如下：\n1）将这N个结点分别作为N棵仅含一个结点的二叉树，构成森林F。\n2）构造一个新结点，并从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值\n置为左、右子树上根结点的权值之和。\n3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中。\n4）重复步骤2）和3），直至F中只剩下一棵树为止。\n\n## 第五章：图\n### 图的基本概念\n* 定义：\n树是N（N≥0）个结点的有限集合，N=0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：\n1）有且仅有一个特定的称为根的结点。\n2）当N>1时，其余结点可分为m（m>0）个互不相交的有限集合T1，T2，…，Tm，其中每一个集合本身又是一棵树，并且称为根结点的子树。\n    * 图G由顶点集V和边集E组成，记为G=(V，E)\n        * V(G)表示图G中顶点的有限非空集。\n用|V|表示图G中顶点的个数，也称为图G的阶\n        * E(G)表示图G中顶点之间的关系（边）集合。\n用|E|表示图G中边的条数。\n* 分类\n    * 有向图\n        * 有向边（弧）的有限集合\n            * 弧是顶点的有序对\n            * <v,w>\n            * v是弧尾，w是弧头\n            * v邻接到w或w邻接自v\n    * 无向图\n        * 无向边的有限集合\n            * 边是顶点的无序对\n            * （v,w）\n            * （v,w）=(w,v)\n            * w，v互为邻接点\n* 简单图\n    * 1.不存在顶点到自身的边\n    * 2.同一条边不重复出现\n* 多重图\n    * 若图G中某两个结点之间的边数多于一条，又允许顶点通过通过同一个边和自己关联\n* 完全图\n    * 无向完全图\n        * 如果任意两个顶点之间都存在边\n    * 有向完全图\n        * 如果任意两个顶点之间都存在方向相反的两条弧\n* 子图\n* 连通图：图中任意两个顶点都是连通的\n* 连通分量：无向图中的极大连通子图\n    * 连通\n        * 顶点A到顶点B有路径\n    * 极大\n        * 1.顶点足够多\n        * 2.极大连通子图包含这些依附这些顶点的所有边\n    * 结论1:如果一个图有n个顶点，并且有小于n-1条边，则此图必是非连通图。\n    * 概要: 找连通分量的方法：\n从选取一个顶点开始，以这个顶点作为一个子图，然后逐个添加与这个子图相连的顶点和边直到所有相连的顶点都加入该子图\n* 强连通：顶点V到顶点W和顶点W到顶点V都有路径\n* 强连通图：图中任一对顶点都是强连通的\n* 连通图的生成树：包含图中全部n个顶点，但是只有n-1条边的极小连通子图\n    * 结论2:生成树去掉一条边则变成非连通图，加上一条边就会形成回路。\n* 度：以该顶点为一个端点的边数目\n    * 无向图中顶点V的度是指依附于该顶点的边的条数，记为TD(v)\n    * 有向图中顶点V的度分为出度和入度\n        * 入度（ID）是以顶点v为终点的有向边的数目\n        * 出度（OD）是以顶点V为起点的有向边的数目\n* 简单路径和简单回路：顶点不重复出现的路径称为简单路径。对于回路，除了第一个和最后一个顶点其余顶点不重复出现的回路称为简单回路\n* 权和网：图中每条边考研赋予一定意义的数值，这个数值叫做这条边的权，有权值得图称为带权图，也叫做网\n* 路径和路径长度：顶点p到q之间的路径是指顶点序列怕保存的，p,a,b,c,d,……q。路径上边的数目就是路径长度\n* 回路（环）：第一个和最后一个顶点相同的路径称为回路或者环\n* 距离：从顶点u到v的最短路径长度。不存在路径则为无穷\n### 图的存储结构\n* 邻接矩阵（顺序存储）\n* 邻接表（链式存储）\n    * 十字链表（有向图）\n    * 邻接多重表（无向图）\n### 图的遍历\n* 深度优先遍历\n    * 深度优先搜索(DFS:Depth-First-Search):深度优先搜索类似于树的先序遍历算法\n        * 空间复杂度：由于DFS是一个递归算法，递归是需要一个工作栈来辅助工作，最多需要图中所有顶点进栈，所以时间复杂度为O(|V|)\n        * 时间复杂度：1)邻接表：遍历过程的主要操作是对顶点遍历它的邻接点，由于通过访问边表来查找邻接点，所以时间复杂度为O(|E|),访问顶点时间为O(|V|),所以总的时间复杂度为O(|V|+|E|)\n                      2)邻接矩阵：查找每个顶点的邻接点时间复杂度为O(|V|),对每个顶点都进行查找，所以总的时间复杂度为O(|V|2)\n* 广度优先遍历\n    * 广度优先搜索(BFS:Breadth-First-Search):广度优先搜索类似于树的层序遍历算法\n        * 空间复杂度：BFS需要借助一个队列，n个顶点均需要入队一次，所以最坏情况下n个顶点在队列，那么则需要O(|V|)的空间复杂度。    \n        * 时间复杂度：\n1)邻接表：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，就需要访问这个顶点的所有边，所以时间复杂度为O(|E|)。所以总的时间复杂度为O(|V|+|E|)\n2)邻接矩阵：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，需要遍历一遍矩阵的一行，所以时间复杂度为O(|V|),所以总的时间复杂度为O(|V|2)\n\n### 图的应用\n* 最小生成树\n    * 普利姆（Prlm）\n        * ①从图中找第一个起始顶点v0，作为生成树的第一个顶点，然后从这个顶点到其他顶点的所有边中选一条权值最小的边。然后把这条边的另一个顶点v和这条边加入到生成树中。\n        * ②对剩下的其他所有顶点，分别检查这些顶点与顶点v的权值是否比这些顶点在lowcost数组中对应的权值小，如果更小，则用较小的权值更新lowcost数组。\n        * ③从更新后的lowcost数组中继续挑选权值最小而且不在生成树中的边，然后加入到生成树。\n        * ④反复执行②③直到所有所有顶点都加入到生成树中。\n        * 概要:  \n            * 双重循环，外层循环次数为n-1，内层并列的两个循环次数都是n。故普利姆算法时间复杂度为O(n2)\n而且时间复杂度只和n有关，所以适合稠密图\n    * 克鲁斯卡尔（Kruskal）\n        * 将图中边按照权值从小到大排列，然后从最小的边开始扫描，设置一个边的集合来记录，如果该边并入不构成回路的话，则将该边并入当前生成树。直到所有的边都检测完为止。\n        * 概要:  \n            * \n            *  \n            * 概要: 克鲁斯卡尔算法操作分为对边的权值排序部分和一个单重for循环，它们是并列关系，由于排序耗费时间大于单重循环，所以克鲁斯卡尔算法的主要时间耗费在排序上。排序和图中边的数量有关系，所以适合稀疏图\n* 最短路径\n    * 迪杰斯特拉\n        * 一个源点到其余顶点的最短路径\n            * 该算法设置一个集合S记录已求得的最短路径的顶点，可用一个数组s[]来实现，初始化为0，当s[vi]=1时表示将顶点vi放入S中，初始时把源点v0放入S中。此外，在构造过程中还设置了两个辅助数组：\ndist[]：记录了从源点v0到其他各顶点当前的最短路径长度，dist[i]初值为arcs[v0][i]。\npath[]：path[i]表示从源点到顶点i之间的最短路径的前驱结点，在算法结束时，可根据其值追溯得到源点v0到顶点vi的最短路径。\n\n假设从顶点0出发，也就是顶点0为源点，集合S最初只包含顶点0，邻接矩阵arcs表示带权有向图，arcs[i][j]表示有向边<i，j>的权值，若不存在有向边<i，j>，则arcs[i][j]为∞。Dijkstra算法的步骤如下：\n1）初始化：集合S初始为{0}，dist[]的初始值dist[i]=arcs[0][i]，i=1，2，…，n-1。\n2）找出dist[]中的最小值dist[j]，将顶点j加入集合S，即修改s[vj]=1。\n3）修改从v0出发到集合V-S上任一顶点vk可达的最短路径长度：如果dist[j] + arcs[j][k]< dist[k]，则令dist[k]=dist[j] + arcs[j][k]。另外更新path[k]=j(也就是顶点j加入集合之后如果有新的路径使得到顶点k路径变短的话就将到顶点k的路径长度修改成较短的)\n4）重复2）～3）操作共n-1次，直到所有的顶点都包含在S中。\n    * 弗洛伊德\n        * 所有顶点到所有顶点的最短路径\n            * 算法思想：\n递推产生一个n阶方阵序列A(−1)，A(0)，…，A(k)，…，A(n−1)\n其中A(k)[i][j]表示从顶点vi到顶点vj的路径长度，k表示绕行第k个顶点的运算步骤。初始时，对于任意两个顶点vi和vj，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以∞作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点k(k=0，1，…，n-1)作为中间顶点。如果增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径\n    * 非带权图\n        * 两点之间经过边数最少的路径\n    * 带权图\n        * 两点之间经过的边上权值之和最小的路径\n* 拓扑排序\n    * AOV\n        * 如果我们把每个环节看成图中一个顶点，在这样一个有向图中，用顶点表示活动，用弧表示活动之间的优先关系，那么这样的有向图称为AOV网(Activity On Vertex)\n\n    * 拓扑排序就是对一个有向图构造拓扑序列的过程，构造会有两种结果：\n如果此图全部顶点都被输出了，说明它是不存在回路的AOV网；\n如果没有输出全部顶点，则说明这个图存在回路，不是AOV网。\n    * 拓扑排序算法：\n     从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为弧尾的弧。重复这个步骤直到输出图中全部顶点，或者找不到入度为0的顶点为止。\n\n* 关键路径\n    * AOE(Activity On Edge):在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网称为AOE网。\n\n## 第六章：查找\n### 查找的基本概念和顺序查找\n* 查找定义：在数据集合中寻找满足某种条件的数据元素的过程称为查找\n* 关键字：数据元素中某个可以以唯一标识该元素的数据项\n* 平均查找长度（ASL：Average Search Length）:在查找的过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值\n* 顺序查找(线性查找)，主要用于在线性表中进行查找。从查找表的一端开始，顺序扫描查找表，依次将扫描到的关键字和待查找的值key进行比较。如果相等，则查找成功。如果扫描结束仍然没有发现相等的数据元素，则查找失败。\n    * 1\n    * 2\n    * 3 \n    * 4\n    * 时间复杂度为O(n)\n### 折半查找\n* 算法思路：\n    * 首先将给定值key与表中中间位置元素的关键字比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分中。然后在缩小的范围内继续进行同样的查找，如此重复直到找到为止，或者确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。\n* 折半查找分析\n    * 折半查找判定树\n        * 对于折半查找，查找的比较次数就是从根结点到该结点经历的结点数\n        * 时间复杂度为O(logn)\n        * 概要: 具有N个（N>0）结点的完全二叉树的高度为 [log2(N+1)] 或 [log2N] +1。\n\n### 分块查找\n* 分块查找又称为索引顺序查找\n* 分块查找思想：\n    * ①确定待查找值在哪个块（折半查找）\n\n②在确定的块中查找待查找值（顺序查找）\n* 分块查找分析\n    * 由于分块查找实际是进行两次查找，所以整个算法的平均查找长度是两次查找的平均查找长度之和。\n即ASL分块=ASL折半+ASL顺序\n        *  \n### 二叉排序树\n* 二叉排序树(Binary Search Tree 也叫二叉搜索树)或者是一棵空树，或者是具有以下性质的二叉树\n①若左子树不空，则左子树上所有结点的值均小于它的根结点的值。\n②若右子树不空，则右子树上所有结点的值均大于它的根结点的值。\n③它的左右子树也是一棵二叉排序树。\n* 算法思想\n    * 由于二叉排序树的特点(左子树<根结点<右子树),所以每次查找一个关键字，需要先和根结点进行比较：\n如果这个关键字小于根结点的值，则再到这个根结点的左子树进行同样的比较操作一直进行下去直到找到该关键字，表示查找成功，或者是空指针，表示查找失败。\n如果这个关键字大于根结点的值，则再到这个根结点的右子树进行同样的比较操作一直进行下去直到找到该关键字，表示查找成功，或者是空指针，表示查找失败。\n        * 查找关键字代码\n            * 1 \n            * 2\n        * 插入关键字代码\n            * 1)空树：直接插入新结点返回成功\n2)树不空：检查是否存在关键字重复的结点：\n①存在：返回插入失败\n②不存在：检查根结点的值和待插入关键字值的大小关系递归插入左右子树\n            *  \n        * 构造代码\n            *  \n        * 删除结点\n            * ①删除的是叶子结点\n                * 方法：直接删去该结点即可\n            * ②删除的是仅有左子树或者右子树的结点\n                * 方法：“子承父业”\n            * ③删除的是左右子树都有的结点\n                * 仿照②类型，先将一个孩子“继承父业”，另一个孩子“归顺”于这个孩子\n方法：找到待删除结点的直接前驱或者直接后继结点，用该结点来替换待删除结点，再删除该结点。\n* 二叉排序树分析\n    * 查找时间复杂度是O(n)\n* 概要: “左小右大”\n### 平衡二叉树(AVL树)\n* 平衡二叉树(AVL树)是特殊的二叉排序树，特殊的地方在于左右子树的高度之差绝对值不超过1，而且左右子树又是一棵平衡二叉树。\n* 平衡因子\n    * 定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是−1、0或1。\n* 平衡调整\n    * 平衡二叉树的建立过程和二叉排序树的建立过程是相似的，都是从一棵空树开始陆续插入结点。不同的地方在于对于平衡二叉树的建立过程中，由于插入结点可能会破坏结点的平衡性，所以需要进行平衡调整。\n\n        * LL调整(左孩子的左子树上插入结点导致)\n            * 最小不平衡子树根结点的平衡因子为2>0\n它的左孩子结点平衡因子为1>0\n两个都大于0，所以直接右旋就可以调整\n            * 概要: “正则右旋”\n        * RR调整(右孩子的右子树上插入结点导致)\n            *  最小不平衡子树根结点的平衡因子为-2<0\n它的右孩子结点平衡因子为-1<0\n两个都小于0，所以直接左旋就可以调整\n            * 概要: “负则左旋”\n        * LR调整(左孩子的右子树上插入结点导致)\n        * RL调整(右孩子的左子树上插入结点导致)\n        * 概要: 先局部转换为LL或RR，最后进行调整\n* 分析\n    * 含有n个结点平衡二叉树的最大深度为O(log2n)，因此，平衡二叉树的平均查找长度为O(log2n) \n### B树和B+树\n* 2-3树\n    * 2-3树是一种多路查找树：2和3的意思就是2-3树包含两种结点\n        * 1)2结点包含一个元素和两个孩子(或者没有孩子)。\n    ①左子树包含的元素小于该结点的元素值，右子树包含的元素大于该结点的元素值\n    ②2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子\n        * 2)3结点包含一大一小两个元素和三个孩子(或者没有孩子)。(两个元素按大小顺序排列好)\n    ①左子树包含的元素小于该结点较小的元素值，右子树包含的元素大于该结点较大的元素值，中间子树包含的元素介于这两个元素值之间。\n    ②3结点要不有三个孩子，要不就没有孩子，不允许有一个或两个孩子\n        * 3)2-3树所有叶子结点都在同一层次\n* 2-3-4树\n    * 2-3-4树也是一种多路查找树：2和3和4的意思就是2-3-4树包含三种结点\n        * 1)2结点包含一个元素和两个孩子(或者没有孩子)。\n    ①左子树包含的元素小于该结点的元素值，右子树包含的元素大于该结点的元素值\n    ②2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子\n        * 2)3结点包含一大一小两个元素和三个孩子(或者没有孩子)。\n    ①左子树包含的元素小于该结点较小的元素值，右子树包含的元素大于该结点较大的元素值，中间子树包含的元素介于这两个元素值之间。\n    ②3结点要不有三个孩子，要不就没有孩子，不允许有一个或两个孩子\n        * 3)4结点包含小中大三个元素和四个孩子(或者没有孩子)。\n    ①左子树包含的元素小于该结点最小的元素值，第二个子树包含大于最小的元素值小于中间元素值的元素，第三个子树包含大于中间元素值小于最大元素值的元素，右子树包含的元素大于该结点最大的元素值。   \n    ②4结点要不有四个孩子，要不就没有孩子，不允许有一个或两个或三个孩子\n        * 4)2-3-4树所有叶子结点都在同一层次\n* B树\n    * B树也是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例，我们把树中结点最大的孩子数目称为B树的阶。通常记为m。\n一棵m阶B树或为空树，或为满足如下特性的m叉树：\n        * 1）树中每个结点至多有m棵子树。（即至多含有m-1个关键字) (\"两棵子树指针夹着一个关键字\")\n        * 2）若根结点不是终端结点，则至少有两棵子树。(至少一个关键字)\n        * 3）除根结点外的所有非叶结点至少有 ⌈m/2⌉棵子树。（即至少含有⌈m/2⌉-1个关键字）\n        * 4）所有非叶结点的结构如下：\n        * 5）所有的叶子结点出现在同一层次上，不带信息。(就像是折半查找判断树中查找失败的结点)\n    * 1.B树的查找操作\n        * 查找过程：①先让待查找关键字key和结点的中的关键字比较，如果等于其中某个关键字，则查找成功。\n                  ②如果和所有关键字都不相等，则看key处在哪个范围内，然后去对应的指针所指向的子树中查找。\n                      Eg:如果Key比第一个关键字K1还小，则去P0指针所指向的子树中查找，如果比最后一个关键字Kn还大，则去Pn指针所指向的子树中查找。\n\n    * 2.B树的插入操作\n        * 分裂的方法：取这个关键字数组中的中间关键字(⌈n/2⌉)作为新的结点，然后其他关键字形成两个结点作为新结点的左右孩子。\n    * 3.B树的删除操作\n        * B树中的删除操作与插入操作类似，但要稍微复杂些，要使得删除后的结点中的关键字个数≥⌈m/2⌉-1 ，因此将涉及结点的“合并”问题。由于删除的关键字位置不同，可以分为关键字在终端结点和不在终端结点上两种情况。\n            * 1）如果删除的关键字在终端结点上（最底层非叶子结点）：\n      ①结点内关键字数量大于⌈m/2⌉-1 ，这时删除这个关键字不会破坏B树的定义要求。所以直接删除。\n      ②结点内关键字数量等于⌈m/2⌉-1 ，并且其左右兄弟结点中存在关键字数量大于⌈m/2⌉-1 的结点，则去兄弟阶段中借关键字。\n      ③结点内关键字数量等于⌈m/2⌉-1 ，并且其左右兄弟结点中不存在关键字数量大于⌈m/2⌉-1 的结点，则需要进行结点合并。\n\n            * 2）如果删除的关键字不在终端结点上（最底层非叶子结点）：需要先转换成在终端结点上，再按照在终端结点     上的情况来分别考虑对应的方法。\n                * 相邻关键字：对于不在终端结点上的关键字,它的相邻关键字是其左子树中值最大的关键字或者右子树中值最小的关键字。\n                * 第一种情况：存在关键字数量大于⌈m/2⌉-1 的左子树或者右子树，在对应子树上找到该关键字的相邻关键字，然后将相邻关键字替换待删除的关键字。\n                * 第二种情况：左右子树的关键字数量均等于⌈m/2⌉-1 ，则将这两个左右子树结点合并，然后删除待删除关键字。\n* B+树\n    * B+树是常用于数据库和操作系统的文件系统中的一种用于查找的数据结构\n    * m阶的B+树与m阶的B树的主要差异在于：\n1）在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；而在B树中，具有n个关键字的结点含有(n+1)棵子树。\n2）在B+树中，每个结点（非根内部结点）关键字个数n的范围是 ⌈m/2⌉≤n≤m（根结点1≤n≤m），在B树中，每个结点（非根内部结点）关键字个数n的范围是⌈m/2⌉ -1≤n≤m-1（根结点：1≤n≤m-1）。\n3）在B+树中，叶结点包含信息，所有非叶结点仅起到索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。\n4）在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。\n### 散列表\n* 散列表：根据给定的关键字来计算出关键字在表中的地址的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。\n* 散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr。\n* 散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为“冲突”，这些发生碰撞的不同关键字称为同义词。\n* 构造散列函数的tips：\n    * 1）散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。\n    * 2）散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间，从而减少冲突的发生。\n    * 3）散列函数应尽量简单，能够在较短的时间内就计算出任一关键字对应的散列地址。\n* 1.常用Hash函数的构造方法：\n    * 1.开放定址法：直接取关键字的某个线性函数值为散列地址，散列函数为H(key)=a×key+b。式中，a和b是常数。这种方法计算最简单，并且不会产生冲突\n    * 2.除留余数法：假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用以下公式把关键字转换成散列地址。散列函数为H(key)=key % p\n除留余数法的关键是选好p，使得每一个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性\n    * 3.数字分析法：设关键字是r进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，则应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合\n    * 4.平方取中法：顾名思义，取关键字的平方值的中间几位作为散列地址。具体取多少位要看实际情况而定。这种方法得到的散列地址与关键字的每一位都有关系，使得散列地址分布比较均匀。\n    * 5.折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以短一些），然后取这几部分的叠加和作为散列地址，这种方法称为折叠法。关键字位数很多，而且关键字中每一位上数字分布大致均匀时，可以采用折叠法得到散列地址。\n\n* 2.常用Hash函数的冲突处理办法：\n    * 1.开放定址法：将产生冲突的Hash地址作为自变量，通过某种冲突解决函数得到一个新的空闲的Hash地址。\n        * 1）线性探测法：冲突发生时，顺序查看表中下一个单元（当探测到表尾地址m-1时，下一个探测地址是表首地址0），直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。\n        * 2）平方探测法：设发生冲突的地址为d,平方探测法得到的新的地址序列为d+12，d-12，d+22，d-22......\n平方探测法是一种较好的处理冲突的方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。\n        * 3）再散列法：又称为双散列法。需要使用两个散列函数，当通过第一个散列函数H(Key)得到的地址发生冲突时，则利用第二个散列函数Hash2(Key)计算该关键字的地址增量。\n        * 4）伪随机序列法：当发生地址冲突时，地址增量为伪随机数序列，称为伪随机序列法。\n    * 2.拉链法：对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。拉链法适用于经常进行插入和删除的情况。\n    * 3.散列表的查找过程：类似于构造散列表，给定一个关键字Key。\n      先根据散列函数计算出其散列地址。然后检查散列地址位置有没有关键字。\n         1)如果没有，表明该关键字不存在，返回查找失败。\n         2)如果有，则检查该记录是否等于关键字。\n                 ①如果等于关键字，返回查找成功。\n                 ②如果不等于，则按照给定的冲突处理办法来计算下一个散列地址，再用该地址去执行上述过程。\n    * 4.散列表的查找性能：和装填因子有关。\n        *  \n        * α越大，表示装填的记录越“满”，发生冲突的可能性就越大，反之发生冲突的可能性越小\n## 第七章：排序\n### 排序的基本知识\n* 定义：排序就是将原本无序的序列重新排列成有序的序列。\n* 排序的稳定性\n    * 如果待排序表中有两个元素Ri、Rj，其对应的关键字keyi=keyj，且在排序前Ri在Rj前面，如果使用某一排序算法排序后，Ri仍然在Rj的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。\n### 插入类排序\n* 直接插入排序\n    * 直接插入排序：首先以一个元素为有序的序列，然后将后面的元素依次插入到有序的序列中合适的位置直到所有元素都插入有序序列。\n    * 时间复杂度为O(n)\n    * 直接插入排序是稳定性是稳定的。\n* 折半插入排序\n    * 折半插入排序将比较和移动这两个操作分离出来，也就是先利用折半查找找到插入的位置，然后一次性移动元素，再插入该元素。\n    * 折半插入排序的时间复杂度为O(n^2)\n    * 稳定性：和直接插入排序稳定性相同，是稳定的。\n* 希尔排序\n    * 希尔排序的基本思想：希尔排序本质上还是插入排序，只不过是把待排序序列分成几个子序列，再分别对这几个子序列进行直接插入排序。\n        * ①先以增量5来分割序列，也就是下标为0,5,10,15...的关键字分成一组，下标为1,6,11,16..分成一组,然后对这些组分别进行直接插入排序，这就完成了一轮希尔排序。\n        * ②缩小增量(d1=n/2，di+1= [di/2]，比如10个数据序列，第一次增量d1=10/2=5,第二次增量d2= [d1/2]= [5/2]=2,并且最后一个增量等于1),所以第二轮以增量为2进行类似的排序过程。\n        * ③接下来的第三轮，第四轮...都是类似的过程，直到最后一轮以增量为1。此时就是前面所说的直接插入排序。\n        * 概要:  \n    * 时间复杂度：...  希尔排序的时间复杂度约为O(n^1.3)    在最坏情况下希尔排序的时间复杂度为O(n^2)\n    * 空间复杂度：希尔排序的空间复杂度为O(1)\n    * 稳定性：不稳定，由于不同的增量可能就会把相等的关键字划分到两个直接插入排序中进行排序， 可能就会造成相对顺序变化。\n### 交换类排序\n* 冒泡排序\n    * 假设待排序表长为n，从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]>A[i]），则交换它们，直到序列比较完。我们称它为一趟冒泡，结果将最小的元素交换到待排序列的第一个位置。下一趟冒泡时，前一趟确定的最小元素不再参与比较，待排序列减少一个元素，每趟冒泡的结果把序列中的最小元素放到了序列的最终位置，……，这样最多做n-1趟冒泡就能把所有元素排好序。\n    * 空间复杂度：交换时开辟了存储空间来存储中间变量，所以空间复杂度为O(1)\n    * 时间复杂度\n    * 稳定性：当两个关键字相等，if判断条件不成立，所以不会发生数据移动。所以是稳定的。\n* 快速排序\n    * 快速排序是一种基于分治法的排序方法。\n每一趟快排选择序列中任一个元素作为枢轴(pivot)(通常选第一个元素)，将序列中比枢轴小的元素都移到枢轴前边，比枢轴大的元素都移到枢轴后边。\n        * 1\n        * 2\n    * 时间复杂度：\n最好情况下时间复杂度为O(nlogn) ,待排序序列越无序，算法效率越高。\n 最坏情况下时间复杂度为O(n^2)，待排序序列越有序，算法效率越低。\n    * 空间复杂度：\n由于快速排序是递归的，需要借助一个递归工作栈来保存每一层递归调用的必要信息，其容量应与递归调用的最大深度一致。\n最好情况下为 ⌈log2(n+1)⌉(每次partition都很均匀)递归树的深度O(logn)\n最坏情况下，因为要进行n-1次递归调用，所以栈的深度为O(n)；\n    * 稳定性：快速排序是不稳定的，是因为存在交换关键字。\n### 选择类排序\n* 简单选择排序\n    *  \n    * 空间复杂度：需要额外的存储空间仅为交换元素时借助的中间变量，所以空间复杂度是O(1)\n    * 时间复杂度：\n关键操作在于交换元素操作，整个算法由双重循环组成，外层循环从0到n-2一共n-2+1=n-1次，\n对于第i层外层循环，内层循环执行n-1-(i+1)+1=n-i-1次。\n                      当i=0,内层循环执行n-1次，当i=n-2,内层循环执行1次，所以是一个等差数列求和,一共为(1+n-1)(n-1)/2=n(n-1)/2 ,所以时间复杂度为O(n^2)\n    * 稳定性：不稳定   原因就在于交换部分会打破相对顺序\n* 堆排序\n    * 什么是堆？\n        * 堆是一棵完全二叉树，而且满足任何一个非叶结点的值都不大于(或不小于)其左右孩子结点的值。\n            * 如果是每个结点的值都不小于它的左右孩子结点的值，则称为大顶堆。\n            * 如果是每个结点的值都不大于它的左右孩子结点的值，则称为小顶堆。\n    * 什么是堆排序？\n        * 我们知道对于一个堆来说，它的根结点是整个堆中所有结点的值的最大值(大顶堆)或者最小值(小顶堆)。所以堆排序的思想就是每次将无序序列调节成一个堆，然后从堆中选择堆顶元素的值，这个值加入有序序列，无序序列减少一个，再反复调节无序序列，直到所有关键字都加入到有序序列。\n            *  \n            *  \n        * 时间复杂度：\n       堆排序的总时间可以分为①建堆部分+②n-1次向下调整堆\n\n       堆排序的时间复杂度为O(n)+O(nlog2n)=O(nlog2n)\n        * 堆排序不稳定\n### 归并排序\n* 假定待排序表含有n个记录，则可以看成是n个有序的子表，每个子表长度为1，然后两两归并，得到 ⌈n/2⌉个长度为2或1的有序表；再两两归并，……如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为2-路归并排序。\n    *   \n    *  \n* 例如：49 38 65 97 76 13 27\n    * ①首先将整个序列的每个关键字看成一个单独的有序的子序列\n    * ②两两归并，49和38归并成{38 49} ，65和97归并成{65 97}，76和13归并成{13 76}，27没有归并对象\n    * ③两两归并，{38 49}和{65 97}归并成{38 49 65 97}，{13,76}和27归并成{13 27 76}\n    * ④两两归并，{38 49 65 97}和{13 27 76}归并成{13 27 38 49 65 76 97}\n* 时间复杂度：O(nlog2n)\n* 空间复杂度:因为需要将这个待排序序列转存到一个数组，所以需要额外开辟大小为n的存储空间，即空间复杂度为O(n)\n* 稳定性：稳定\n### 基数排序\n* 基数排序(也叫桶排序)是一种很特别的排序方法，它不是基于比较进行排序的，而是采用多关键字排序思想（即基于关键字各位的大小进行排序的），借助“分配”和“收集”两种操作对单逻辑关键字进行排序。基数排序又分为最高位优先（MSD）排序和最低位优先（LSD）排序。\n* 例子：53, 3, 542, 748, 14, 214, 154, 63, 616\n    * 补充位数：053, 003, 542, 748, 014, 214, 154, 063, 616\n    * 桶实际是一个队列，先进先出(从桶的上面进，下面出)\n    * 关键字数量为n,关键字的位数为d,比如748 d=3，r为关键字的基的个数，就是组成关键字的数据的种类，比如十进制数字一共有0至9一共10个数字，即r=10\n* 空间复杂度：需要开辟关键字基的个数个队列，所以空间复杂度为O(r)\n* 时间复杂度：需要进行关键字位数d次\"分配\"和\"收集\"，一次\"分配\"需要将n个关键字放进各个队列中，一次\"收集\"需要将r个桶都收集一遍。所以一次\"分配\"和一次\"收集\"时间复杂度为O(n+r)。d次就需要O(d(n+r))的时间复杂度。\n* 稳定性：由于是队列，先进先出的性质，所以在分配的时候是按照先后顺序分配，也就是稳定的，所以收集的时候也是保持稳定的。即基数排序是稳定的排序算法。\n### 外部排序\n* 需要将待排序的记录存储在外存上，排序时再把数据一部分一部分的调入内存进行排序。在排序过程中需要多次进行内存和外存之间的交换，对外存文件中的记录进行排序后的结果仍然被放到原有文件中。这种排序的方法就叫做外部排序。\n* 如何得到初始的归并段\n    * 置换选择排序：解决排序段放入内存的问题\n* 如何减少多个归并段的归并次数\n    * 最佳归并树：最少的归并次数（I/O次数）\n* 如何每次m路归并快速得到最小的关键字\n    * 败者树：减少比较次数\n* 概要: 内存容量无法容纳大量数据\n## 二叉树与树与森林\n### 树与二叉树\n* 如何将一棵树转化成二叉树？\n    * 树的孩子兄弟表示法与二叉树的二叉链表表示法都是用到两个指针\n        * 将孩子兄弟表示法理解成二叉链表\n    * 树转换成二叉树的手动模拟方法：\n        * ①将同一结点的各个孩子用线串连起来\n        * ②将每个结点的子树分支，从左往右，除了第一个以外全部删除\n        * 概要: 例子\n* 如何将一棵二叉树转化成树？\n    * 二叉树转换成树的手动模拟方法：\n        * ①将二叉树从上到下分层，并调节成水平方向。\n(分层方法：每遇到左孩子则为一层)\n        * ②找到每一层的双亲结点，方法为它的上一层相连的那个结点就是双亲结点。\n例如bcd这一层，与它相连的上一层结点即为a,所以bcd这三个结点的双亲结点都是a.\n        * ③将每一层结点和其双亲结点相连，同时删除该双亲结点各个孩子结点之间的联系。\n        * 概要: 例子\n### 森林与二叉树\n* 森林：森林是m（m≥0）棵互不相交的树的集合\n* 如何将森林转换成二叉树？\n    * 森林转换成树的手动模拟方法：\n        * ①将森林中每棵树都转换成二叉树\n        * ②将第二棵树作为第一棵树的根结点的右子树，将第三棵树作为第二棵树的根结点的右子树..依次类推\n        * 概要: 例子\n* 如何将二叉树转换成森林？\n    * 二叉树转换成森林的手动模拟方法：\n        * 反复断开二叉树根结点的右孩子的右子树指针，直到不存在根结点有右孩子的二叉树为止。\n        * 概要: 例子\n### 树与森林的遍历\n* 先序：先访问根结点，再访问根结点的每棵子树。           访问子树也是按照先序的要求\n* 后序：先访问根结点的每棵子树，再访问根结点。           访问子树也是按照先序的要求\n* 树的先序遍历等于它对应二叉树的先序遍历，后序遍历等于它对应的二叉树的中序遍历\n* 概要: 例子\n","slug":"2023-06-14-数据结构","published":1,"date":"2023-12-15T02:31:42.283Z","updated":"2023-12-15T02:31:42.303Z","_id":"clq60joxn000c4zgs6cb2agjn","title":"","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h2 id=\"第一章：数据结构的\"><a href=\"#第一章：数据结构的\" class=\"headerlink\" title=\"第一章：数据结构的\"></a>第一章：数据结构的</h2><p>基本概念</p>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><ul>\n<li>在任何问题中，数据元素都不是孤立存在的，而是在它们之间存在着某种关系，这种数据元素相互之间的关系称为结构（Structure）。数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。</li>\n</ul>\n<h3 id=\"逻辑结构\"><a href=\"#逻辑结构\" class=\"headerlink\" title=\"逻辑结构\"></a>逻辑结构</h3><ul>\n<li>逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的</li>\n<li>数据的逻辑结构分为线性结构和非线性结构<ul>\n<li>集合 结构中的数据元素之间除了“同属于一个集合”的关系外，别无其他关系。 类似于数学上的集合</li>\n<li>线性结构 结构中的数据元素之间只存在一对一的关系。比如排队</li>\n<li>树形结构 结构中的数据元素之间存在一对多的关系。比如家族族谱</li>\n<li>图状结构或网状结构 结构中的数据元素之间存在多对多的关系。 比如地图</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"物理结构\"><a href=\"#物理结构\" class=\"headerlink\" title=\"物理结构\"></a>物理结构</h3><ul>\n<li>存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。数据的存储结构主要有：顺序存储、链式存储、索引存储和散列存储。<ul>\n<li>顺序存储：存储的物理位置相邻。（p.s. 物理位置即信息在计算机中的位置。）</li>\n<li>链接存储：存储的物理位置未必相邻，通过记录相邻元素的物理位置来找到相邻元素。</li>\n<li>索引存储：类似于目录，以后可以联系操作系统的文件系统章节来理解。</li>\n<li>散列存储：通过关键字直接计算出元素的物理地址（以后详解）。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"算法的五个特征\"><a href=\"#算法的五个特征\" class=\"headerlink\" title=\"算法的五个特征\"></a>算法的五个特征</h3><ul>\n<li>1，有穷性：有限步之后结束</li>\n<li>2，确定性：不存在二义性，即没有歧义</li>\n<li>3，可行性：比如受限于计算机的计算能力，有些算法虽然理论上可行，但实际上无法完成。</li>\n<li>4，输入：能被计算机处理的各种类型数据，如数字，音频，图像等等。</li>\n<li>5，输出：一至多个程序输出结果。</li>\n</ul>\n<h3 id=\"算法的复杂度\"><a href=\"#算法的复杂度\" class=\"headerlink\" title=\"算法的复杂度\"></a>算法的复杂度</h3><ul>\n<li>时间复杂度：<ul>\n<li>• 它用来衡量算法随着问题规模增大，算法执行时间增长的快慢；</li>\n<li>• 是问题规模的函数：T(n)是时间规模函数 时间复杂度主要分析T(n)的数量级</li>\n<li>• T(n)&#x3D;O(f(n)) f(n)是算法中基本运算的频度 一般我们考虑最坏情况下的时间复杂度</li>\n</ul>\n</li>\n<li>空间复杂度：<ul>\n<li>• 它用来衡量算法随着问题规模增大，算法所需空间的快慢；</li>\n<li>• 是问题规模的函数：S(n)&#x3D;O(g(n)) ；算法所需空间的增长率和g(n)的增长率相同。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"概要-复杂度计算为重点\"><a href=\"#概要-复杂度计算为重点\" class=\"headerlink\" title=\"概要: 复杂度计算为重点\"></a>概要: 复杂度计算为重点</h3><ul>\n<li>常用的时间复杂度大小关系：</li>\n<li>复杂度如何计算<ul>\n<li>时间复杂度计算（单个循环体）<ul>\n<li>直接关注循环体的执行次数，设为k</li>\n</ul>\n</li>\n<li>时间复杂度计算（多个循环体）<ul>\n<li>两个运算规则：乘法规则，加法规则。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二章：线性表\"><a href=\"#第二章：线性表\" class=\"headerlink\" title=\"第二章：线性表\"></a>第二章：线性表</h2><h3 id=\"线性表的逻辑结构\"><a href=\"#线性表的逻辑结构\" class=\"headerlink\" title=\"线性表的逻辑结构\"></a>线性表的逻辑结构</h3><ul>\n<li>定义：线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列。其中n为表长。当n&#x3D;0时 线性表是一个空表</li>\n<li>特点：线性表中第一个元素称为表头元素；最后一个元素称为表尾元素。<br>除第一个元素外，每个元素有且仅有一个直接前驱。<br>除最后一个元素外，每个元素有且仅有一个直接后继。</li>\n</ul>\n<h3 id=\"线性表的顺序存储结构\"><a href=\"#线性表的顺序存储结构\" class=\"headerlink\" title=\"线性表的顺序存储结构\"></a>线性表的顺序存储结构</h3><ul>\n<li>线性表的顺序存储又称为顺序表。<br>它是用一组地址连续的存储单元（比如C语言里面的数组），依次存储线性表中的数据元素，从而使得逻<br>辑上相邻的两个元素在物理位置上也相邻。</li>\n<li>建立顺序表的三个属性:<br>1.存储空间的起始位置（数组名data）<br>2.顺序表最大存储容量（MaxSize）<br>3.顺序表当前的长度（length）</li>\n<li>其实数组还可以动态分配空间，存储数组的空间是在程序执行过程中通过动态存储分配语句分配</li>\n<li>总结：<ul>\n<li>1.顺序表最主要的特点是随机访问（C语言中基于数组），即通过首地址和元素序号可以在O(1)的时间内找到指定的元素。</li>\n<li>2.顺序表的存储密度高，每个结点只存储数据元素。无需给表中元素花费空间建立它们之间的逻辑关系（因为物理位置相邻特性决定）</li>\n<li>3.顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"顺序表的操作\"><a href=\"#顺序表的操作\" class=\"headerlink\" title=\"顺序表的操作\"></a>顺序表的操作</h3><ul>\n<li>1.插入<ul>\n<li>算法思路：<ul>\n<li>1.判断i的值是否正确</li>\n<li>2.判断表长是否超过数组长度</li>\n<li>3.从后向前到第i个位置，分别将这些元素都向后移动一位</li>\n<li>4.将该元素插入位置i 并修改表长</li>\n</ul>\n</li>\n<li>代码</li>\n<li>分析：<ul>\n<li>最好情况：在表尾插入（即i&#x3D;n+1），元素后移语句将不执行，时间复杂度为O(1)。</li>\n<li>最坏情况：在表头插入（即i&#x3D;1），元素后移语句将执行</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>n次，时间复杂度为O(n)。<br>        * 平均情况：假设pi（pi&#x3D;1&#x2F;(n+1) ）是在第i个位置上插入<br>一个结点的概率，则在长度为n的线性表中插入一个结<br>点时所需移动结点的平均次数为</p>\n<ul>\n<li>2.删除<ul>\n<li>算法思路：<ul>\n<li>1.判断i的值是否正确</li>\n<li>2.取删除的元素</li>\n<li>3.将被删元素后面的所有元素都依次向前移动一位</li>\n<li>4.修改表长</li>\n</ul>\n</li>\n<li>代码</li>\n<li>分析<ul>\n<li>最好情况：删除表尾元素（即i&#x3D;n），无须移动元素，时间复杂度为O(1)。</li>\n<li>最坏情况：删除表头元素（即i&#x3D;1），需要移动除第一个元素外的所有元素，时间复杂度为O(n)。</li>\n<li>平均情况：假设pi(pi&#x3D;1&#x2F;n)是删除第i个位置上结点的概率，则在长度为n的线性表中删除一个结点时所需移动结点的平均次数为</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线性表的链式存储结构\"><a href=\"#线性表的链式存储结构\" class=\"headerlink\" title=\"线性表的链式存储结构\"></a>线性表的链式存储结构</h3><ul>\n<li>线性表的链式存储是指通过一组任意的存储单元来存储线性表中的数据元素。</li>\n<li>头结点和头指针的区别？<ul>\n<li>不管带不带头结点，头指针始终指向链表的第一个结点，而头结点是带头结点链表中的第一个结点，结点内通常不存储信息</li>\n</ul>\n</li>\n<li>为什么要设置头结点？<ul>\n<li>1.处理操作起来方便 例如：对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了</li>\n<li>2.无论链表是否为空，其头指针是指向头结点的非空指针，因此空表和非空表的处理也就统一了。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"单链表的操作\"><a href=\"#单链表的操作\" class=\"headerlink\" title=\"单链表的操作\"></a>单链表的操作</h3><ul>\n<li>1.头插法建立单链表：<ul>\n<li>建立新的结点分配内存空间，将新结点插入到当前链表的表头</li>\n<li>代码</li>\n</ul>\n</li>\n<li>2.尾插法建立单链表：<ul>\n<li>建立新的结点分配内存空间，将新结点插入到当前链表的表尾</li>\n<li>代码</li>\n</ul>\n</li>\n<li>3.按序号查找结点<ul>\n<li>在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止,否则返回最后一个结点指针域NULL。</li>\n<li>代码</li>\n</ul>\n</li>\n<li>4.按值查找结点<ul>\n<li>从单链表第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针；若整个单链表中没有这样的结点，则返回NULL。</li>\n<li>代码</li>\n</ul>\n</li>\n<li>5．插入<ul>\n<li>插入操作是将值为x的新结点插入到单链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i−1个结点，再在其后插入新结点。</li>\n<li>算法思路：<br>1.取指向插入位置的前驱结点的指针<br>① p&#x3D;GetElem(L,i-1);<br>2.令新结点<em>s的指针域指向</em>p的后继结点<br>② s-&gt;next&#x3D;p-&gt;next;<br>3.令结点<em>p的指针域指向新插入的结点</em>s<br>③ p-&gt;next&#x3D;s;</li>\n</ul>\n</li>\n<li>6．删除<ul>\n<li>删除操作是将单链表的第i个结点删除。先检查删除位置的合法性，然后查找表中第i−1个结点，即被删结点的前驱结点，再将其删除。</li>\n<li>算法思路：<br>1.取指向删除位置的前驱结点的指针 p&#x3D;GetElem(L,i-1);<br>2.取指向删除位置的指针 q&#x3D;p-&gt;next;<br>3.p指向结点的后继指向被删除结点的后继 p-&gt;next&#x3D;q-&gt;next<br>4.释放删除结点 free(q);</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"双链表\"><a href=\"#双链表\" class=\"headerlink\" title=\"双链表\"></a>双链表</h3><ul>\n<li>定义</li>\n<li>1.插入：(方法不唯一)<br>① s-&gt;next&#x3D;p-&gt;next;<br>② p-&gt;next-&gt;prior&#x3D;s;<br>③ s-&gt;prior&#x3D;p;<br>④ p-&gt;next&#x3D;s;</li>\n<li>2.删除：<br>① p-&gt;next&#x3D;q-&gt;next;<br>② q-&gt;next-&gt;prior&#x3D;p;<br>③ free(q);</li>\n</ul>\n<h3 id=\"循环链表-静态链表\"><a href=\"#循环链表-静态链表\" class=\"headerlink\" title=\"循环链表&amp;&amp;静态链表\"></a>循环链表&amp;&amp;静态链表</h3><ul>\n<li>循环单链表：循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环</li>\n<li>循环双链表：类比循环单链表，循环双链表链表区别于双链表就是首尾结点构成环<ul>\n<li>当循环双链表为空表时，其头结点的prior域和next域都等于Head。</li>\n</ul>\n</li>\n<li>静态链表：静态链表是用数组来描述线性表的链式存储结构。<ul>\n<li>数组第一个元素不存储数据，它的指针域存储第一个元素所在的数组下标。链表最后一个元素的指针域值为-1。</li>\n<li>例子</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第三章：栈和队列\"><a href=\"#第三章：栈和队列\" class=\"headerlink\" title=\"第三章：栈和队列\"></a>第三章：栈和队列</h2><h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><ul>\n<li>栈（Stack）：只允许在一端进行插入或删除操作的线性表。</li>\n<li>栈顶（Top）：线性表允许进行插入和删除的那一端。</li>\n<li>栈底（Bottom）：固定的，不允许进行插入和删除的另一端</li>\n<li>特点：<br>1.栈是受限的线性表，所以自然具有线性关<br>系。<br>2.栈中元素后进去的必然先出来，即后进先出<br>LIFO（Last In First Out）<ul>\n<li>栈中元素后进<br>去的必然先出<br>来，即后进先<br>出LIFO（Last In<br>First Out）</li>\n</ul>\n</li>\n<li>顺序栈<ul>\n<li>栈是线性表的特例，那栈的顺序存储也是线性表顺序存储的简化。栈的顺序存储结构也叫作顺序栈。</li>\n<li>顺序栈的操作<ul>\n<li>1.判空：</li>\n<li>2.进栈：</li>\n<li>3.出栈：</li>\n<li>4.读取栈顶元素：</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>共享栈<ul>\n<li>顺序栈的存储空间大小需要事先开辟好，很多时候对每个栈各自单独开辟存储空间的利用率不如将各个栈的存储空间共享</li>\n<li>示意图</li>\n<li>共享栈的结构</li>\n<li>共享栈的操作：（进栈）</li>\n</ul>\n</li>\n<li>链式栈<ul>\n<li>栈是线性表的特例，线性表的存储结构还有链式存储结构，所以也可以用链表的方式来实现栈。栈的链式存储结构也叫作链栈。</li>\n<li>特点<br>1.链栈一般不存在栈满的情况。<br>2.空栈的判定条件通常定为top&#x3D;&#x3D;NULL；</li>\n<li>结构</li>\n<li>链式栈的操作<ul>\n<li>1.进栈</li>\n<li>2.出栈</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><ul>\n<li>队列是只允许在一端进行插入，而在另一端进行删除的线性表</li>\n<li>队头（Front）：允许删除的一端，又称为队首。</li>\n<li>队尾（Rear）： 允许插入的一端。</li>\n<li>先进入队列的元素必然先离开队列，即先进先出（First In First Out）简称FIFO</li>\n<li>顺序队列<ul>\n<li>用数组来实现队列，可以将队首放在数组下标为0的位置。</li>\n</ul>\n</li>\n<li>循环队列<ul>\n<li>把数组“掰弯”，形成一个环。Rear指针到了下标为4的位置还能继续指回到下标为0的地方。这样首尾相连的顺序存储的队列就叫循环队列</li>\n<li>入队：rear&#x3D;(rear+1)%MaxSize</li>\n<li>出队：front&#x3D;(front+1)%MaxSize</li>\n<li>循环队列的操作<ul>\n<li>1.入队：</li>\n<li>2.出队：</li>\n</ul>\n</li>\n<li>概要: 那如何分辨队列是空还是满呢？<ul>\n<li>方法一：设置标志位flag，当flag&#x3D;0且rear等于front时为队列空，当flag&#x3D;1且rear等于front时为队列满。</li>\n<li>方法二：我们把front&#x3D;rear仅作为队空的判定条件。当队列满的时候，令数组中仍然保留一个空余单元。我们认为这种情况就是队列满了。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>链式队列<ul>\n<li>队列的链式存储结构，其实就是线性表的单链表，只不过需要加点限制，只能表尾插入元素，表头删除元素。</li>\n<li>为了方便操作，我们分别设置队头指针和队尾指针，队头指针指向头结点，队尾指针指向尾结点。</li>\n<li>链式队列的操作<ul>\n<li><p>1.入队：我们知道队列只能从队尾插入元素，队头删除元素。于是入队就是在队尾指针进行插入结点操作。链队的插入操作和单链表的插入操作是一致的。</p>\n</li>\n<li><p>2.出队：出队就是头结点的后继结点出队，然后将头结点的后继改为它后面的结点。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>双端队列<ul>\n<li>双端队列是指允许两端都可以进行入队和出队操作的队列</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"栈的应用\"><a href=\"#栈的应用\" class=\"headerlink\" title=\"栈的应用\"></a>栈的应用</h3><ul>\n<li>1、括号匹配：假设有两种括号，一种圆的()，一种方的[]，嵌套的顺序是任意的。<ul>\n<li><p>算法思想：若是左括号，入栈；若是右括号，出栈一个左括号判断是否与之匹配；检验到字符串尾，还要检查栈是否为空。只有栈空，整个字符串才是括号匹配的。</p>\n</li>\n<li><p>代码</p>\n</li>\n</ul>\n</li>\n<li>2、表达式求值：<ul>\n<li></li>\n<li>规则：从左到右扫描表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈然后跟这个符号进行运算，最后将运算结果进栈，直到最终获得结果。</li>\n</ul>\n</li>\n<li>3、递归：<ul>\n<li>要理解递归，你要先理解递归，直到你能理解递归。<br>如果在一个函数、过程或数据结构的定义中又应用了它自身，那么这个函数、过程或数据结构称为是递归定义的，简称递归。递归最重要的是递归式和递归边界。</li>\n<li>1.阶乘<ul>\n<li>时间复杂度：O(NlogN)</li>\n</ul>\n</li>\n<li>2.斐波那契数列<ul>\n<li>时间复杂度   O(2^n)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>概要: 如何将中缀表达式转换成后缀表达式？<ul>\n<li>1.按运算符优先级对所有运算符和它的运算数加括号。(原本的括号不用加)</li>\n<li>2.把运算符移到对应的括号后。</li>\n<li>3.去掉括号。</li>\n<li>例子</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第四章：树\"><a href=\"#第四章：树\" class=\"headerlink\" title=\"第四章：树\"></a>第四章：树</h2><h3 id=\"树的基本概念\"><a href=\"#树的基本概念\" class=\"headerlink\" title=\"树的基本概念\"></a>树的基本概念</h3><ul>\n<li>树是递归定义的结构</li>\n<li>结点<ul>\n<li>根节点：树只有一个根结点</li>\n<li>结点的度：结点拥有的子树的数量<ul>\n<li>度为0：叶子结点或者终端结点</li>\n<li>度不为0：分支结点或者非终端结点<ul>\n<li>分支结点除去根结点也称为内部结点</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>树的度：树中所有结点的度数的最大值</li>\n<li>结点关系<ul>\n<li>祖先结点<ul>\n<li>根结点到该结点的唯一路径的任意结点</li>\n</ul>\n</li>\n<li>子孙结点</li>\n<li>双亲结点<ul>\n<li>根结点到该结点的唯一路径上最接近该结点的结点</li>\n</ul>\n</li>\n<li>孩子结点</li>\n<li>兄弟结点<ul>\n<li>有相同双亲结点的结点</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>层次，高度，深度，树的高度<ul>\n<li>层次：根为第一层，它的孩子为第二层，以此类推</li>\n<li>结点的深度：根结点开始自顶向下累加</li>\n<li>结点的高度：叶节点开始自底向上累加</li>\n<li>树的高度（深度）：树中结点的最大层数</li>\n</ul>\n</li>\n<li>树的性质<ul>\n<li>1.树中的结点数等于所有结点的度数加1。<ul>\n<li>证明：不难想象，除根结点以外，每个结点有且仅有一个指向它的前驱结点。也就是说每个结点和指向它的分支一一对应。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>假设树中一共有b个分支，那么除了根结点，整个树就包含有b个结点，所以整个树的结点数就是这b个结点加上根结点，设为n，则n&#x3D;b+1。而分支数b也就是所有结点的度数，证毕。<br>    * 2.度为m的树中第i层上至多有m^(i−1)个结点（i≥1）。<br>        * 证明：（数学归纳法）<br>首先考虑i&#x3D;1的情况：第一层只有根结点，即一个结点，i&#x3D;1带入式子满足。<br>假设第i-1层满足这个性质，第i-1层最多有m i-2个结点。<br>……… ……….<br>i-1层<br>………<br>又因为树的度为m,所以对于第i-1层的每个结点，最多<br>有m个孩子结点。所以第i层的结点数最多是i-1层的m<br>倍，所以第i层上最多有m ^(i-1)个结点。<br>    * 3.高度为h的m叉树至多有(m^h-1)&#x2F;(m-1)个结点<br>    * 4.具有n个结点的m叉树的最小高度为logm(n(m-1)+1) </p>\n<h3 id=\"树的存储结构\"><a href=\"#树的存储结构\" class=\"headerlink\" title=\"树的存储结构\"></a>树的存储结构</h3><ul>\n<li>顺序存储结构<ul>\n<li>双亲表示法：用一组连续的存储空间存储树的结点，同时在每个结点中，用一个变量存储该结点的双亲结点在数组中的位置。</li>\n</ul>\n</li>\n<li>链式存储结构<ul>\n<li><p>孩子表示法：把每个结点的孩子结点排列起来存储成一个单链表。所以n个结点就有n个链表；<br>如果是叶子结点，那这个结点的孩子单链表就是空的；<br>然后n个单链表的的头指针又存储在一个顺序表（数组）中。</p>\n</li>\n<li><p>孩子兄弟表示法：顾名思义就是要存储孩子和孩子结点的兄弟，具体来说，就是设置两个指针，分别指向该结</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>点的第一个孩子结点和这个孩子结点的右兄弟结点。</p>\n<h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><ul>\n<li>定义<ul>\n<li>二叉树是n（n≥0）个结点的有限集合：<br>① 或者为空二叉树，即n&#x3D;0。<br>② 或者由一个根结点和两个互不相交的被称为根的左子树<br>和右子树组成。左子树和右子树又分别是一棵二叉树。 <ul>\n<li>1.每个结点最多有两棵子树。</li>\n<li>2.左右子树有顺序</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>二叉树的五种基本形态：<ul>\n<li>1.空树</li>\n<li>2.只有一个根结点</li>\n<li>3.根结点只有左子树</li>\n<li>4.根结点只有右子树</li>\n<li>5.根结点既有左子树又有右子树</li>\n</ul>\n</li>\n<li>特殊二叉树<ul>\n<li>1.斜树</li>\n<li>2.满二叉树:</li>\n<li>3.完全二叉树</li>\n</ul>\n</li>\n<li>二叉树的性质<ul>\n<li>1.非空二叉树上叶子结点数等于度为2的结点数加1</li>\n<li>2.非空二叉树上第K层上至多有2^k−1个结点（K≥1）</li>\n<li>3.高度为H的二叉树至多有2^H-1个结点（H≥1）</li>\n<li>4.具有N个（N&gt;0）结点的完全二叉树的高度为 [log2(N+1)]或[log2N] +1。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二叉树的存储结构\"><a href=\"#二叉树的存储结构\" class=\"headerlink\" title=\"二叉树的存储结构\"></a>二叉树的存储结构</h3><ul>\n<li>顺序存储<ul>\n<li>二叉树的顺序存储结构就是用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素。</li>\n</ul>\n</li>\n<li>链式存储<ul>\n<li>二叉树每个结点最多两个孩子，所以设计二叉树的结点结构时考虑两个指针指向该结点的两个孩子。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h3><ul>\n<li>先序遍历：<br>1）访问根结点；<br>2）先序遍历左子树；<br>3）先序遍历右子树。<ul>\n<li>递归</li>\n<li>非递归</li>\n</ul>\n</li>\n<li>中序遍历：<br>1）中序遍历左子树；<br>2）访问根结点；<br>3）中序遍历右子树。<ul>\n<li>递归</li>\n<li>非递归</li>\n</ul>\n</li>\n<li>后序遍历：<br>1）后序遍历左子树；<br>2）后序遍历右子树；<br>3）访问根结点。<ul>\n<li>递归</li>\n<li>非递归</li>\n</ul>\n</li>\n<li>层次遍历：<br>若树为空，则什么都不做直接返回。<br>否则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</li>\n</ul>\n<h3 id=\"线索二叉树\"><a href=\"#线索二叉树\" class=\"headerlink\" title=\"线索二叉树\"></a>线索二叉树</h3><ul>\n<li><p>N个结点的二叉链表，每个结点都有指向左右孩子的<br>结点指针，所以一共有2N个指针，而N个结点的二叉<br>树一共有N-1条分支，也就是说存在2N-(N-1)&#x3D;N+1个空指针。比如左图二叉树中有6个结点，那么就有7个空<br>指针。</p>\n</li>\n<li><p>大量的空余指针能否利用起来？</p>\n<ul>\n<li>指向前驱和后继的指针称为线索，加上线索的二叉链表就称为线索链表，相应的二叉树就称为线索二叉树</li>\n<li>对二叉树以某种次序遍历使其变为线索二叉树的过程就叫做线索化</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"哈夫曼树和哈夫曼编码\"><a href=\"#哈夫曼树和哈夫曼编码\" class=\"headerlink\" title=\"哈夫曼树和哈夫曼编码\"></a>哈夫曼树和哈夫曼编码</h3><ul>\n<li>算法的描述如下：<br>1）将这N个结点分别作为N棵仅含一个结点的二叉树，构成森林F。<br>2）构造一个新结点，并从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值<br>置为左、右子树上根结点的权值之和。<br>3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中。<br>4）重复步骤2）和3），直至F中只剩下一棵树为止。</li>\n</ul>\n<h2 id=\"第五章：图\"><a href=\"#第五章：图\" class=\"headerlink\" title=\"第五章：图\"></a>第五章：图</h2><h3 id=\"图的基本概念\"><a href=\"#图的基本概念\" class=\"headerlink\" title=\"图的基本概念\"></a>图的基本概念</h3><ul>\n<li>定义：<br>树是N（N≥0）个结点的有限集合，N&#x3D;0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：<br>1）有且仅有一个特定的称为根的结点。<br>2）当N&gt;1时，其余结点可分为m（m&gt;0）个互不相交的有限集合T1，T2，…，Tm，其中每一个集合本身又是一棵树，并且称为根结点的子树。<ul>\n<li>图G由顶点集V和边集E组成，记为G&#x3D;(V，E)<ul>\n<li>V(G)表示图G中顶点的有限非空集。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>用|V|表示图G中顶点的个数，也称为图G的阶<br>        * E(G)表示图G中顶点之间的关系（边）集合。<br>用|E|表示图G中边的条数。</p>\n<ul>\n<li>分类<ul>\n<li>有向图<ul>\n<li>有向边（弧）的有限集合<ul>\n<li>弧是顶点的有序对</li>\n<li>&lt;v,w&gt;</li>\n<li>v是弧尾，w是弧头</li>\n<li>v邻接到w或w邻接自v</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>无向图<ul>\n<li>无向边的有限集合<ul>\n<li>边是顶点的无序对</li>\n<li>（v,w）</li>\n<li>（v,w）&#x3D;(w,v)</li>\n<li>w，v互为邻接点</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>简单图<ul>\n<li>1.不存在顶点到自身的边</li>\n<li>2.同一条边不重复出现</li>\n</ul>\n</li>\n<li>多重图<ul>\n<li>若图G中某两个结点之间的边数多于一条，又允许顶点通过通过同一个边和自己关联</li>\n</ul>\n</li>\n<li>完全图<ul>\n<li>无向完全图<ul>\n<li>如果任意两个顶点之间都存在边</li>\n</ul>\n</li>\n<li>有向完全图<ul>\n<li>如果任意两个顶点之间都存在方向相反的两条弧</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>子图</li>\n<li>连通图：图中任意两个顶点都是连通的</li>\n<li>连通分量：无向图中的极大连通子图<ul>\n<li>连通<ul>\n<li>顶点A到顶点B有路径</li>\n</ul>\n</li>\n<li>极大<ul>\n<li>1.顶点足够多</li>\n<li>2.极大连通子图包含这些依附这些顶点的所有边</li>\n</ul>\n</li>\n<li>结论1:如果一个图有n个顶点，并且有小于n-1条边，则此图必是非连通图。</li>\n<li>概要: 找连通分量的方法：<br>从选取一个顶点开始，以这个顶点作为一个子图，然后逐个添加与这个子图相连的顶点和边直到所有相连的顶点都加入该子图</li>\n</ul>\n</li>\n<li>强连通：顶点V到顶点W和顶点W到顶点V都有路径</li>\n<li>强连通图：图中任一对顶点都是强连通的</li>\n<li>连通图的生成树：包含图中全部n个顶点，但是只有n-1条边的极小连通子图<ul>\n<li>结论2:生成树去掉一条边则变成非连通图，加上一条边就会形成回路。</li>\n</ul>\n</li>\n<li>度：以该顶点为一个端点的边数目<ul>\n<li>无向图中顶点V的度是指依附于该顶点的边的条数，记为TD(v)</li>\n<li>有向图中顶点V的度分为出度和入度<ul>\n<li>入度（ID）是以顶点v为终点的有向边的数目</li>\n<li>出度（OD）是以顶点V为起点的有向边的数目</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>简单路径和简单回路：顶点不重复出现的路径称为简单路径。对于回路，除了第一个和最后一个顶点其余顶点不重复出现的回路称为简单回路</li>\n<li>权和网：图中每条边考研赋予一定意义的数值，这个数值叫做这条边的权，有权值得图称为带权图，也叫做网</li>\n<li>路径和路径长度：顶点p到q之间的路径是指顶点序列怕保存的，p,a,b,c,d,……q。路径上边的数目就是路径长度</li>\n<li>回路（环）：第一个和最后一个顶点相同的路径称为回路或者环</li>\n<li>距离：从顶点u到v的最短路径长度。不存在路径则为无穷</li>\n</ul>\n<h3 id=\"图的存储结构\"><a href=\"#图的存储结构\" class=\"headerlink\" title=\"图的存储结构\"></a>图的存储结构</h3><ul>\n<li>邻接矩阵（顺序存储）</li>\n<li>邻接表（链式存储）<ul>\n<li>十字链表（有向图）</li>\n<li>邻接多重表（无向图）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"图的遍历\"><a href=\"#图的遍历\" class=\"headerlink\" title=\"图的遍历\"></a>图的遍历</h3><ul>\n<li>深度优先遍历<ul>\n<li>深度优先搜索(DFS:Depth-First-Search):深度优先搜索类似于树的先序遍历算法<ul>\n<li>空间复杂度：由于DFS是一个递归算法，递归是需要一个工作栈来辅助工作，最多需要图中所有顶点进栈，所以时间复杂度为O(|V|)</li>\n<li>时间复杂度：1)邻接表：遍历过程的主要操作是对顶点遍历它的邻接点，由于通过访问边表来查找邻接点，所以时间复杂度为O(|E|),访问顶点时间为O(|V|),所以总的时间复杂度为O(|V|+|E|)<br>        2)邻接矩阵：查找每个顶点的邻接点时间复杂度为O(|V|),对每个顶点都进行查找，所以总的时间复杂度为O(|V|2)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>广度优先遍历<ul>\n<li>广度优先搜索(BFS:Breadth-First-Search):广度优先搜索类似于树的层序遍历算法<ul>\n<li>空间复杂度：BFS需要借助一个队列，n个顶点均需要入队一次，所以最坏情况下n个顶点在队列，那么则需要O(|V|)的空间复杂度。    </li>\n<li>时间复杂度：</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>1)邻接表：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，就需要访问这个顶点的所有边，所以时间复杂度为O(|E|)。所以总的时间复杂度为O(|V|+|E|)<br>2)邻接矩阵：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，需要遍历一遍矩阵的一行，所以时间复杂度为O(|V|),所以总的时间复杂度为O(|V|2)</p>\n<h3 id=\"图的应用\"><a href=\"#图的应用\" class=\"headerlink\" title=\"图的应用\"></a>图的应用</h3><ul>\n<li>最小生成树<ul>\n<li>普利姆（Prlm）<ul>\n<li>①从图中找第一个起始顶点v0，作为生成树的第一个顶点，然后从这个顶点到其他顶点的所有边中选一条权值最小的边。然后把这条边的另一个顶点v和这条边加入到生成树中。</li>\n<li>②对剩下的其他所有顶点，分别检查这些顶点与顶点v的权值是否比这些顶点在lowcost数组中对应的权值小，如果更小，则用较小的权值更新lowcost数组。</li>\n<li>③从更新后的lowcost数组中继续挑选权值最小而且不在生成树中的边，然后加入到生成树。</li>\n<li>④反复执行②③直到所有所有顶点都加入到生成树中。</li>\n<li>概要:  <ul>\n<li>双重循环，外层循环次数为n-1，内层并列的两个循环次数都是n。故普利姆算法时间复杂度为O(n2)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>而且时间复杂度只和n有关，所以适合稠密图<br>    * 克鲁斯卡尔（Kruskal）<br>        * 将图中边按照权值从小到大排列，然后从最小的边开始扫描，设置一个边的集合来记录，如果该边并入不构成回路的话，则将该边并入当前生成树。直到所有的边都检测完为止。<br>        * 概要:<br>            *<br>            *<br>            * 概要: 克鲁斯卡尔算法操作分为对边的权值排序部分和一个单重for循环，它们是并列关系，由于排序耗费时间大于单重循环，所以克鲁斯卡尔算法的主要时间耗费在排序上。排序和图中边的数量有关系，所以适合稀疏图</p>\n<ul>\n<li>最短路径<ul>\n<li>迪杰斯特拉<ul>\n<li>一个源点到其余顶点的最短路径<ul>\n<li>该算法设置一个集合S记录已求得的最短路径的顶点，可用一个数组s[]来实现，初始化为0，当s[vi]&#x3D;1时表示将顶点vi放入S中，初始时把源点v0放入S中。此外，在构造过程中还设置了两个辅助数组：</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>dist[]：记录了从源点v0到其他各顶点当前的最短路径长度，dist[i]初值为arcs[v0][i]。<br>path[]：path[i]表示从源点到顶点i之间的最短路径的前驱结点，在算法结束时，可根据其值追溯得到源点v0到顶点vi的最短路径。</p>\n<p>假设从顶点0出发，也就是顶点0为源点，集合S最初只包含顶点0，邻接矩阵arcs表示带权有向图，arcs[i][j]表示有向边&lt;i，j&gt;的权值，若不存在有向边&lt;i，j&gt;，则arcs[i][j]为∞。Dijkstra算法的步骤如下：<br>1）初始化：集合S初始为{0}，dist[]的初始值dist[i]&#x3D;arcs[0][i]，i&#x3D;1，2，…，n-1。<br>2）找出dist[]中的最小值dist[j]，将顶点j加入集合S，即修改s[vj]&#x3D;1。<br>3）修改从v0出发到集合V-S上任一顶点vk可达的最短路径长度：如果dist[j] + arcs[j][k]&lt; dist[k]，则令dist[k]&#x3D;dist[j] + arcs[j][k]。另外更新path[k]&#x3D;j(也就是顶点j加入集合之后如果有新的路径使得到顶点k路径变短的话就将到顶点k的路径长度修改成较短的)<br>4）重复2）～3）操作共n-1次，直到所有的顶点都包含在S中。<br>    * 弗洛伊德<br>        * 所有顶点到所有顶点的最短路径<br>            * 算法思想：<br>递推产生一个n阶方阵序列A(−1)，A(0)，…，A(k)，…，A(n−1)<br>其中A(k)[i][j]表示从顶点vi到顶点vj的路径长度，k表示绕行第k个顶点的运算步骤。初始时，对于任意两个顶点vi和vj，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以∞作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点k(k&#x3D;0，1，…，n-1)作为中间顶点。如果增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径<br>    * 非带权图<br>        * 两点之间经过边数最少的路径<br>    * 带权图<br>        * 两点之间经过的边上权值之和最小的路径</p>\n<ul>\n<li>拓扑排序<ul>\n<li><p>AOV</p>\n<ul>\n<li>如果我们把每个环节看成图中一个顶点，在这样一个有向图中，用顶点表示活动，用弧表示活动之间的优先关系，那么这样的有向图称为AOV网(Activity On Vertex)</li>\n</ul>\n</li>\n<li><p>拓扑排序就是对一个有向图构造拓扑序列的过程，构造会有两种结果：</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>如果此图全部顶点都被输出了，说明它是不存在回路的AOV网；<br>如果没有输出全部顶点，则说明这个图存在回路，不是AOV网。<br>    * 拓扑排序算法：<br>     从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为弧尾的弧。重复这个步骤直到输出图中全部顶点，或者找不到入度为0的顶点为止。</p>\n<ul>\n<li>关键路径<ul>\n<li>AOE(Activity On Edge):在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网称为AOE网。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第六章：查找\"><a href=\"#第六章：查找\" class=\"headerlink\" title=\"第六章：查找\"></a>第六章：查找</h2><h3 id=\"查找的基本概念和顺序查找\"><a href=\"#查找的基本概念和顺序查找\" class=\"headerlink\" title=\"查找的基本概念和顺序查找\"></a>查找的基本概念和顺序查找</h3><ul>\n<li>查找定义：在数据集合中寻找满足某种条件的数据元素的过程称为查找</li>\n<li>关键字：数据元素中某个可以以唯一标识该元素的数据项</li>\n<li>平均查找长度（ASL：Average Search Length）:在查找的过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值</li>\n<li>顺序查找(线性查找)，主要用于在线性表中进行查找。从查找表的一端开始，顺序扫描查找表，依次将扫描到的关键字和待查找的值key进行比较。如果相等，则查找成功。如果扫描结束仍然没有发现相等的数据元素，则查找失败。<ul>\n<li>1</li>\n<li>2</li>\n<li>3 </li>\n<li>4</li>\n<li>时间复杂度为O(n)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"折半查找\"><a href=\"#折半查找\" class=\"headerlink\" title=\"折半查找\"></a>折半查找</h3><ul>\n<li>算法思路：<ul>\n<li>首先将给定值key与表中中间位置元素的关键字比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分中。然后在缩小的范围内继续进行同样的查找，如此重复直到找到为止，或者确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。</li>\n</ul>\n</li>\n<li>折半查找分析<ul>\n<li>折半查找判定树<ul>\n<li>对于折半查找，查找的比较次数就是从根结点到该结点经历的结点数</li>\n<li>时间复杂度为O(logn)</li>\n<li>概要: 具有N个（N&gt;0）结点的完全二叉树的高度为 [log2(N+1)] 或 [log2N] +1。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分块查找\"><a href=\"#分块查找\" class=\"headerlink\" title=\"分块查找\"></a>分块查找</h3><ul>\n<li>分块查找又称为索引顺序查找</li>\n<li>分块查找思想：<ul>\n<li>①确定待查找值在哪个块（折半查找）</li>\n</ul>\n</li>\n</ul>\n<p>②在确定的块中查找待查找值（顺序查找）</p>\n<ul>\n<li>分块查找分析<ul>\n<li>由于分块查找实际是进行两次查找，所以整个算法的平均查找长度是两次查找的平均查找长度之和。<br>即ASL分块&#x3D;ASL折半+ASL顺序<ul>\n<li></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二叉排序树\"><a href=\"#二叉排序树\" class=\"headerlink\" title=\"二叉排序树\"></a>二叉排序树</h3><ul>\n<li>二叉排序树(Binary Search Tree 也叫二叉搜索树)或者是一棵空树，或者是具有以下性质的二叉树<br>①若左子树不空，则左子树上所有结点的值均小于它的根结点的值。<br>②若右子树不空，则右子树上所有结点的值均大于它的根结点的值。<br>③它的左右子树也是一棵二叉排序树。</li>\n<li>算法思想<ul>\n<li>由于二叉排序树的特点(左子树&lt;根结点&lt;右子树),所以每次查找一个关键字，需要先和根结点进行比较：<br>如果这个关键字小于根结点的值，则再到这个根结点的左子树进行同样的比较操作一直进行下去直到找到该关键字，表示查找成功，或者是空指针，表示查找失败。<br>如果这个关键字大于根结点的值，则再到这个根结点的右子树进行同样的比较操作一直进行下去直到找到该关键字，表示查找成功，或者是空指针，表示查找失败。<ul>\n<li>查找关键字代码<ul>\n<li>1 </li>\n<li>2</li>\n</ul>\n</li>\n<li>插入关键字代码<ul>\n<li>1)空树：直接插入新结点返回成功</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>2)树不空：检查是否存在关键字重复的结点：<br>①存在：返回插入失败<br>②不存在：检查根结点的值和待插入关键字值的大小关系递归插入左右子树<br>            *<br>        * 构造代码<br>            *<br>        * 删除结点<br>            * ①删除的是叶子结点<br>                * 方法：直接删去该结点即可<br>            * ②删除的是仅有左子树或者右子树的结点<br>                * 方法：“子承父业”<br>            * ③删除的是左右子树都有的结点<br>                * 仿照②类型，先将一个孩子“继承父业”，另一个孩子“归顺”于这个孩子<br>方法：找到待删除结点的直接前驱或者直接后继结点，用该结点来替换待删除结点，再删除该结点。</p>\n<ul>\n<li>二叉排序树分析<ul>\n<li>查找时间复杂度是O(n)</li>\n</ul>\n</li>\n<li>概要: “左小右大”</li>\n</ul>\n<h3 id=\"平衡二叉树-AVL树\"><a href=\"#平衡二叉树-AVL树\" class=\"headerlink\" title=\"平衡二叉树(AVL树)\"></a>平衡二叉树(AVL树)</h3><ul>\n<li>平衡二叉树(AVL树)是特殊的二叉排序树，特殊的地方在于左右子树的高度之差绝对值不超过1，而且左右子树又是一棵平衡二叉树。</li>\n<li>平衡因子<ul>\n<li>定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是−1、0或1。</li>\n</ul>\n</li>\n<li>平衡调整<ul>\n<li><p>平衡二叉树的建立过程和二叉排序树的建立过程是相似的，都是从一棵空树开始陆续插入结点。不同的地方在于对于平衡二叉树的建立过程中，由于插入结点可能会破坏结点的平衡性，所以需要进行平衡调整。</p>\n<ul>\n<li>LL调整(左孩子的左子树上插入结点导致)<ul>\n<li>最小不平衡子树根结点的平衡因子为2&gt;0</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>它的左孩子结点平衡因子为1&gt;0<br>两个都大于0，所以直接右旋就可以调整<br>            * 概要: “正则右旋”<br>        * RR调整(右孩子的右子树上插入结点导致)<br>            *  最小不平衡子树根结点的平衡因子为-2&lt;0<br>它的右孩子结点平衡因子为-1&lt;0<br>两个都小于0，所以直接左旋就可以调整<br>            * 概要: “负则左旋”<br>        * LR调整(左孩子的右子树上插入结点导致)<br>        * RL调整(右孩子的左子树上插入结点导致)<br>        * 概要: 先局部转换为LL或RR，最后进行调整</p>\n<ul>\n<li>分析<ul>\n<li>含有n个结点平衡二叉树的最大深度为O(log2n)，因此，平衡二叉树的平均查找长度为O(log2n)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"B树和B-树\"><a href=\"#B树和B-树\" class=\"headerlink\" title=\"B树和B+树\"></a>B树和B+树</h3><ul>\n<li>2-3树<ul>\n<li>2-3树是一种多路查找树：2和3的意思就是2-3树包含两种结点<ul>\n<li>1)2结点包含一个元素和两个孩子(或者没有孩子)。<br>  ①左子树包含的元素小于该结点的元素值，右子树包含的元素大于该结点的元素值<br>  ②2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子</li>\n<li>2)3结点包含一大一小两个元素和三个孩子(或者没有孩子)。(两个元素按大小顺序排列好)<br>  ①左子树包含的元素小于该结点较小的元素值，右子树包含的元素大于该结点较大的元素值，中间子树包含的元素介于这两个元素值之间。<br>  ②3结点要不有三个孩子，要不就没有孩子，不允许有一个或两个孩子</li>\n<li>3)2-3树所有叶子结点都在同一层次</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>2-3-4树<ul>\n<li>2-3-4树也是一种多路查找树：2和3和4的意思就是2-3-4树包含三种结点<ul>\n<li>1)2结点包含一个元素和两个孩子(或者没有孩子)。<br>  ①左子树包含的元素小于该结点的元素值，右子树包含的元素大于该结点的元素值<br>  ②2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子</li>\n<li>2)3结点包含一大一小两个元素和三个孩子(或者没有孩子)。<br>  ①左子树包含的元素小于该结点较小的元素值，右子树包含的元素大于该结点较大的元素值，中间子树包含的元素介于这两个元素值之间。<br>  ②3结点要不有三个孩子，要不就没有孩子，不允许有一个或两个孩子</li>\n<li>3)4结点包含小中大三个元素和四个孩子(或者没有孩子)。<br>  ①左子树包含的元素小于该结点最小的元素值，第二个子树包含大于最小的元素值小于中间元素值的元素，第三个子树包含大于中间元素值小于最大元素值的元素，右子树包含的元素大于该结点最大的元素值。<br>  ②4结点要不有四个孩子，要不就没有孩子，不允许有一个或两个或三个孩子</li>\n<li>4)2-3-4树所有叶子结点都在同一层次</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>B树<ul>\n<li><p>B树也是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例，我们把树中结点最大的孩子数目称为B树的阶。通常记为m。<br>一棵m阶B树或为空树，或为满足如下特性的m叉树：</p>\n<ul>\n<li>1）树中每个结点至多有m棵子树。（即至多含有m-1个关键字) (“两棵子树指针夹着一个关键字”)</li>\n<li>2）若根结点不是终端结点，则至少有两棵子树。(至少一个关键字)</li>\n<li>3）除根结点外的所有非叶结点至少有 ⌈m&#x2F;2⌉棵子树。（即至少含有⌈m&#x2F;2⌉-1个关键字）</li>\n<li>4）所有非叶结点的结构如下：</li>\n<li>5）所有的叶子结点出现在同一层次上，不带信息。(就像是折半查找判断树中查找失败的结点)</li>\n</ul>\n</li>\n<li><p>1.B树的查找操作</p>\n<ul>\n<li>查找过程：①先让待查找关键字key和结点的中的关键字比较，如果等于其中某个关键字，则查找成功。<br>    ②如果和所有关键字都不相等，则看key处在哪个范围内，然后去对应的指针所指向的子树中查找。<br>        Eg:如果Key比第一个关键字K1还小，则去P0指针所指向的子树中查找，如果比最后一个关键字Kn还大，则去Pn指针所指向的子树中查找。</li>\n</ul>\n</li>\n<li><p>2.B树的插入操作</p>\n<ul>\n<li>分裂的方法：取这个关键字数组中的中间关键字(⌈n&#x2F;2⌉)作为新的结点，然后其他关键字形成两个结点作为新结点的左右孩子。</li>\n</ul>\n</li>\n<li><p>3.B树的删除操作</p>\n<ul>\n<li>B树中的删除操作与插入操作类似，但要稍微复杂些，要使得删除后的结点中的关键字个数≥⌈m&#x2F;2⌉-1 ，因此将涉及结点的“合并”问题。由于删除的关键字位置不同，可以分为关键字在终端结点和不在终端结点上两种情况。<ul>\n<li><p>1）如果删除的关键字在终端结点上（最底层非叶子结点）：<br>①结点内关键字数量大于⌈m&#x2F;2⌉-1 ，这时删除这个关键字不会破坏B树的定义要求。所以直接删除。<br>②结点内关键字数量等于⌈m&#x2F;2⌉-1 ，并且其左右兄弟结点中存在关键字数量大于⌈m&#x2F;2⌉-1 的结点，则去兄弟阶段中借关键字。<br>③结点内关键字数量等于⌈m&#x2F;2⌉-1 ，并且其左右兄弟结点中不存在关键字数量大于⌈m&#x2F;2⌉-1 的结点，则需要进行结点合并。</p>\n</li>\n<li><p>2）如果删除的关键字不在终端结点上（最底层非叶子结点）：需要先转换成在终端结点上，再按照在终端结点     上的情况来分别考虑对应的方法。</p>\n<ul>\n<li>相邻关键字：对于不在终端结点上的关键字,它的相邻关键字是其左子树中值最大的关键字或者右子树中值最小的关键字。</li>\n<li>第一种情况：存在关键字数量大于⌈m&#x2F;2⌉-1 的左子树或者右子树，在对应子树上找到该关键字的相邻关键字，然后将相邻关键字替换待删除的关键字。</li>\n<li>第二种情况：左右子树的关键字数量均等于⌈m&#x2F;2⌉-1 ，则将这两个左右子树结点合并，然后删除待删除关键字。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>B+树<ul>\n<li>B+树是常用于数据库和操作系统的文件系统中的一种用于查找的数据结构</li>\n<li>m阶的B+树与m阶的B树的主要差异在于：<br>1）在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；而在B树中，具有n个关键字的结点含有(n+1)棵子树。<br>2）在B+树中，每个结点（非根内部结点）关键字个数n的范围是 ⌈m&#x2F;2⌉≤n≤m（根结点1≤n≤m），在B树中，每个结点（非根内部结点）关键字个数n的范围是⌈m&#x2F;2⌉ -1≤n≤m-1（根结点：1≤n≤m-1）。<br>3）在B+树中，叶结点包含信息，所有非叶结点仅起到索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。<br>4）在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h3><ul>\n<li><p>散列表：根据给定的关键字来计算出关键字在表中的地址的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。</p>\n</li>\n<li><p>散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)&#x3D;Addr。</p>\n</li>\n<li><p>散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为“冲突”，这些发生碰撞的不同关键字称为同义词。</p>\n</li>\n<li><p>构造散列函数的tips：</p>\n<ul>\n<li>1）散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。</li>\n<li>2）散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间，从而减少冲突的发生。</li>\n<li>3）散列函数应尽量简单，能够在较短的时间内就计算出任一关键字对应的散列地址。</li>\n</ul>\n</li>\n<li><p>1.常用Hash函数的构造方法：</p>\n<ul>\n<li>1.开放定址法：直接取关键字的某个线性函数值为散列地址，散列函数为H(key)&#x3D;a×key+b。式中，a和b是常数。这种方法计算最简单，并且不会产生冲突</li>\n<li>2.除留余数法：假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用以下公式把关键字转换成散列地址。散列函数为H(key)&#x3D;key % p<br>除留余数法的关键是选好p，使得每一个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性</li>\n<li>3.数字分析法：设关键字是r进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，则应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合</li>\n<li>4.平方取中法：顾名思义，取关键字的平方值的中间几位作为散列地址。具体取多少位要看实际情况而定。这种方法得到的散列地址与关键字的每一位都有关系，使得散列地址分布比较均匀。</li>\n<li>5.折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以短一些），然后取这几部分的叠加和作为散列地址，这种方法称为折叠法。关键字位数很多，而且关键字中每一位上数字分布大致均匀时，可以采用折叠法得到散列地址。</li>\n</ul>\n</li>\n<li><p>2.常用Hash函数的冲突处理办法：</p>\n<ul>\n<li>1.开放定址法：将产生冲突的Hash地址作为自变量，通过某种冲突解决函数得到一个新的空闲的Hash地址。<ul>\n<li>1）线性探测法：冲突发生时，顺序查看表中下一个单元（当探测到表尾地址m-1时，下一个探测地址是表首地址0），直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。</li>\n<li>2）平方探测法：设发生冲突的地址为d,平方探测法得到的新的地址序列为d+12，d-12，d+22，d-22……</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>平方探测法是一种较好的处理冲突的方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。<br>        * 3）再散列法：又称为双散列法。需要使用两个散列函数，当通过第一个散列函数H(Key)得到的地址发生冲突时，则利用第二个散列函数Hash2(Key)计算该关键字的地址增量。<br>        * 4）伪随机序列法：当发生地址冲突时，地址增量为伪随机数序列，称为伪随机序列法。<br>    * 2.拉链法：对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。拉链法适用于经常进行插入和删除的情况。<br>    * 3.散列表的查找过程：类似于构造散列表，给定一个关键字Key。<br>      先根据散列函数计算出其散列地址。然后检查散列地址位置有没有关键字。<br>         1)如果没有，表明该关键字不存在，返回查找失败。<br>         2)如果有，则检查该记录是否等于关键字。<br>                 ①如果等于关键字，返回查找成功。<br>                 ②如果不等于，则按照给定的冲突处理办法来计算下一个散列地址，再用该地址去执行上述过程。<br>    * 4.散列表的查找性能：和装填因子有关。<br>        *<br>        * α越大，表示装填的记录越“满”，发生冲突的可能性就越大，反之发生冲突的可能性越小</p>\n<h2 id=\"第七章：排序\"><a href=\"#第七章：排序\" class=\"headerlink\" title=\"第七章：排序\"></a>第七章：排序</h2><h3 id=\"排序的基本知识\"><a href=\"#排序的基本知识\" class=\"headerlink\" title=\"排序的基本知识\"></a>排序的基本知识</h3><ul>\n<li>定义：排序就是将原本无序的序列重新排列成有序的序列。</li>\n<li>排序的稳定性<ul>\n<li>如果待排序表中有两个元素Ri、Rj，其对应的关键字keyi&#x3D;keyj，且在排序前Ri在Rj前面，如果使用某一排序算法排序后，Ri仍然在Rj的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"插入类排序\"><a href=\"#插入类排序\" class=\"headerlink\" title=\"插入类排序\"></a>插入类排序</h3><ul>\n<li>直接插入排序<ul>\n<li>直接插入排序：首先以一个元素为有序的序列，然后将后面的元素依次插入到有序的序列中合适的位置直到所有元素都插入有序序列。</li>\n<li>时间复杂度为O(n)</li>\n<li>直接插入排序是稳定性是稳定的。</li>\n</ul>\n</li>\n<li>折半插入排序<ul>\n<li>折半插入排序将比较和移动这两个操作分离出来，也就是先利用折半查找找到插入的位置，然后一次性移动元素，再插入该元素。</li>\n<li>折半插入排序的时间复杂度为O(n^2)</li>\n<li>稳定性：和直接插入排序稳定性相同，是稳定的。</li>\n</ul>\n</li>\n<li>希尔排序<ul>\n<li>希尔排序的基本思想：希尔排序本质上还是插入排序，只不过是把待排序序列分成几个子序列，再分别对这几个子序列进行直接插入排序。<ul>\n<li>①先以增量5来分割序列，也就是下标为0,5,10,15…的关键字分成一组，下标为1,6,11,16..分成一组,然后对这些组分别进行直接插入排序，这就完成了一轮希尔排序。</li>\n<li>②缩小增量(d1&#x3D;n&#x2F;2，di+1&#x3D; [di&#x2F;2]，比如10个数据序列，第一次增量d1&#x3D;10&#x2F;2&#x3D;5,第二次增量d2&#x3D; [d1&#x2F;2]&#x3D; [5&#x2F;2]&#x3D;2,并且最后一个增量等于1),所以第二轮以增量为2进行类似的排序过程。</li>\n<li>③接下来的第三轮，第四轮…都是类似的过程，直到最后一轮以增量为1。此时就是前面所说的直接插入排序。</li>\n<li>概要:</li>\n</ul>\n</li>\n<li>时间复杂度：…  希尔排序的时间复杂度约为O(n^1.3)    在最坏情况下希尔排序的时间复杂度为O(n^2)</li>\n<li>空间复杂度：希尔排序的空间复杂度为O(1)</li>\n<li>稳定性：不稳定，由于不同的增量可能就会把相等的关键字划分到两个直接插入排序中进行排序， 可能就会造成相对顺序变化。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"交换类排序\"><a href=\"#交换类排序\" class=\"headerlink\" title=\"交换类排序\"></a>交换类排序</h3><ul>\n<li>冒泡排序<ul>\n<li>假设待排序表长为n，从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]&gt;A[i]），则交换它们，直到序列比较完。我们称它为一趟冒泡，结果将最小的元素交换到待排序列的第一个位置。下一趟冒泡时，前一趟确定的最小元素不再参与比较，待排序列减少一个元素，每趟冒泡的结果把序列中的最小元素放到了序列的最终位置，……，这样最多做n-1趟冒泡就能把所有元素排好序。</li>\n<li>空间复杂度：交换时开辟了存储空间来存储中间变量，所以空间复杂度为O(1)</li>\n<li>时间复杂度</li>\n<li>稳定性：当两个关键字相等，if判断条件不成立，所以不会发生数据移动。所以是稳定的。</li>\n</ul>\n</li>\n<li>快速排序<ul>\n<li>快速排序是一种基于分治法的排序方法。<br>每一趟快排选择序列中任一个元素作为枢轴(pivot)(通常选第一个元素)，将序列中比枢轴小的元素都移到枢轴前边，比枢轴大的元素都移到枢轴后边。<ul>\n<li>1</li>\n<li>2</li>\n</ul>\n</li>\n<li>时间复杂度：<br>最好情况下时间复杂度为O(nlogn) ,待排序序列越无序，算法效率越高。<br> 最坏情况下时间复杂度为O(n^2)，待排序序列越有序，算法效率越低。</li>\n<li>空间复杂度：<br>由于快速排序是递归的，需要借助一个递归工作栈来保存每一层递归调用的必要信息，其容量应与递归调用的最大深度一致。<br>最好情况下为 ⌈log2(n+1)⌉(每次partition都很均匀)递归树的深度O(logn)<br>最坏情况下，因为要进行n-1次递归调用，所以栈的深度为O(n)；</li>\n<li>稳定性：快速排序是不稳定的，是因为存在交换关键字。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"选择类排序\"><a href=\"#选择类排序\" class=\"headerlink\" title=\"选择类排序\"></a>选择类排序</h3><ul>\n<li>简单选择排序<ul>\n<li></li>\n<li>空间复杂度：需要额外的存储空间仅为交换元素时借助的中间变量，所以空间复杂度是O(1)</li>\n<li>时间复杂度：<br>关键操作在于交换元素操作，整个算法由双重循环组成，外层循环从0到n-2一共n-2+1&#x3D;n-1次，<br>对于第i层外层循环，内层循环执行n-1-(i+1)+1&#x3D;n-i-1次。<br>            当i&#x3D;0,内层循环执行n-1次，当i&#x3D;n-2,内层循环执行1次，所以是一个等差数列求和,一共为(1+n-1)(n-1)&#x2F;2&#x3D;n(n-1)&#x2F;2 ,所以时间复杂度为O(n^2)</li>\n<li>稳定性：不稳定   原因就在于交换部分会打破相对顺序</li>\n</ul>\n</li>\n<li>堆排序<ul>\n<li><p>什么是堆？</p>\n<ul>\n<li>堆是一棵完全二叉树，而且满足任何一个非叶结点的值都不大于(或不小于)其左右孩子结点的值。<ul>\n<li>如果是每个结点的值都不小于它的左右孩子结点的值，则称为大顶堆。</li>\n<li>如果是每个结点的值都不大于它的左右孩子结点的值，则称为小顶堆。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>什么是堆排序？</p>\n<ul>\n<li>我们知道对于一个堆来说，它的根结点是整个堆中所有结点的值的最大值(大顶堆)或者最小值(小顶堆)。所以堆排序的思想就是每次将无序序列调节成一个堆，然后从堆中选择堆顶元素的值，这个值加入有序序列，无序序列减少一个，再反复调节无序序列，直到所有关键字都加入到有序序列。<ul>\n<li></li>\n<li></li>\n</ul>\n</li>\n<li>时间复杂度：<br> 堆排序的总时间可以分为①建堆部分+②n-1次向下调整堆</li>\n</ul>\n<p> 堆排序的时间复杂度为O(n)+O(nlog2n)&#x3D;O(nlog2n)</p>\n<ul>\n<li>堆排序不稳定</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><ul>\n<li>假定待排序表含有n个记录，则可以看成是n个有序的子表，每个子表长度为1，然后两两归并，得到 ⌈n&#x2F;2⌉个长度为2或1的有序表；再两两归并，……如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为2-路归并排序。<ul>\n<li></li>\n<li></li>\n</ul>\n</li>\n<li>例如：49 38 65 97 76 13 27<ul>\n<li>①首先将整个序列的每个关键字看成一个单独的有序的子序列</li>\n<li>②两两归并，49和38归并成{38 49} ，65和97归并成{65 97}，76和13归并成{13 76}，27没有归并对象</li>\n<li>③两两归并，{38 49}和{65 97}归并成{38 49 65 97}，{13,76}和27归并成{13 27 76}</li>\n<li>④两两归并，{38 49 65 97}和{13 27 76}归并成{13 27 38 49 65 76 97}</li>\n</ul>\n</li>\n<li>时间复杂度：O(nlog2n)</li>\n<li>空间复杂度:因为需要将这个待排序序列转存到一个数组，所以需要额外开辟大小为n的存储空间，即空间复杂度为O(n)</li>\n<li>稳定性：稳定</li>\n</ul>\n<h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><ul>\n<li>基数排序(也叫桶排序)是一种很特别的排序方法，它不是基于比较进行排序的，而是采用多关键字排序思想（即基于关键字各位的大小进行排序的），借助“分配”和“收集”两种操作对单逻辑关键字进行排序。基数排序又分为最高位优先（MSD）排序和最低位优先（LSD）排序。</li>\n<li>例子：53, 3, 542, 748, 14, 214, 154, 63, 616<ul>\n<li>补充位数：053, 003, 542, 748, 014, 214, 154, 063, 616</li>\n<li>桶实际是一个队列，先进先出(从桶的上面进，下面出)</li>\n<li>关键字数量为n,关键字的位数为d,比如748 d&#x3D;3，r为关键字的基的个数，就是组成关键字的数据的种类，比如十进制数字一共有0至9一共10个数字，即r&#x3D;10</li>\n</ul>\n</li>\n<li>空间复杂度：需要开辟关键字基的个数个队列，所以空间复杂度为O(r)</li>\n<li>时间复杂度：需要进行关键字位数d次”分配”和”收集”，一次”分配”需要将n个关键字放进各个队列中，一次”收集”需要将r个桶都收集一遍。所以一次”分配”和一次”收集”时间复杂度为O(n+r)。d次就需要O(d(n+r))的时间复杂度。</li>\n<li>稳定性：由于是队列，先进先出的性质，所以在分配的时候是按照先后顺序分配，也就是稳定的，所以收集的时候也是保持稳定的。即基数排序是稳定的排序算法。</li>\n</ul>\n<h3 id=\"外部排序\"><a href=\"#外部排序\" class=\"headerlink\" title=\"外部排序\"></a>外部排序</h3><ul>\n<li>需要将待排序的记录存储在外存上，排序时再把数据一部分一部分的调入内存进行排序。在排序过程中需要多次进行内存和外存之间的交换，对外存文件中的记录进行排序后的结果仍然被放到原有文件中。这种排序的方法就叫做外部排序。</li>\n<li>如何得到初始的归并段<ul>\n<li>置换选择排序：解决排序段放入内存的问题</li>\n</ul>\n</li>\n<li>如何减少多个归并段的归并次数<ul>\n<li>最佳归并树：最少的归并次数（I&#x2F;O次数）</li>\n</ul>\n</li>\n<li>如何每次m路归并快速得到最小的关键字<ul>\n<li>败者树：减少比较次数</li>\n</ul>\n</li>\n<li>概要: 内存容量无法容纳大量数据</li>\n</ul>\n<h2 id=\"二叉树与树与森林\"><a href=\"#二叉树与树与森林\" class=\"headerlink\" title=\"二叉树与树与森林\"></a>二叉树与树与森林</h2><h3 id=\"树与二叉树\"><a href=\"#树与二叉树\" class=\"headerlink\" title=\"树与二叉树\"></a>树与二叉树</h3><ul>\n<li>如何将一棵树转化成二叉树？<ul>\n<li>树的孩子兄弟表示法与二叉树的二叉链表表示法都是用到两个指针<ul>\n<li>将孩子兄弟表示法理解成二叉链表</li>\n</ul>\n</li>\n<li>树转换成二叉树的手动模拟方法：<ul>\n<li>①将同一结点的各个孩子用线串连起来</li>\n<li>②将每个结点的子树分支，从左往右，除了第一个以外全部删除</li>\n<li>概要: 例子</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>如何将一棵二叉树转化成树？<ul>\n<li>二叉树转换成树的手动模拟方法：<ul>\n<li>①将二叉树从上到下分层，并调节成水平方向。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>(分层方法：每遇到左孩子则为一层)<br>        * ②找到每一层的双亲结点，方法为它的上一层相连的那个结点就是双亲结点。<br>例如bcd这一层，与它相连的上一层结点即为a,所以bcd这三个结点的双亲结点都是a.<br>        * ③将每一层结点和其双亲结点相连，同时删除该双亲结点各个孩子结点之间的联系。<br>        * 概要: 例子</p>\n<h3 id=\"森林与二叉树\"><a href=\"#森林与二叉树\" class=\"headerlink\" title=\"森林与二叉树\"></a>森林与二叉树</h3><ul>\n<li>森林：森林是m（m≥0）棵互不相交的树的集合</li>\n<li>如何将森林转换成二叉树？<ul>\n<li>森林转换成树的手动模拟方法：<ul>\n<li>①将森林中每棵树都转换成二叉树</li>\n<li>②将第二棵树作为第一棵树的根结点的右子树，将第三棵树作为第二棵树的根结点的右子树..依次类推</li>\n<li>概要: 例子</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>如何将二叉树转换成森林？<ul>\n<li>二叉树转换成森林的手动模拟方法：<ul>\n<li>反复断开二叉树根结点的右孩子的右子树指针，直到不存在根结点有右孩子的二叉树为止。</li>\n<li>概要: 例子</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"树与森林的遍历\"><a href=\"#树与森林的遍历\" class=\"headerlink\" title=\"树与森林的遍历\"></a>树与森林的遍历</h3><ul>\n<li>先序：先访问根结点，再访问根结点的每棵子树。           访问子树也是按照先序的要求</li>\n<li>后序：先访问根结点的每棵子树，再访问根结点。           访问子树也是按照先序的要求</li>\n<li>树的先序遍历等于它对应二叉树的先序遍历，后序遍历等于它对应的二叉树的中序遍历</li>\n<li>概要: 例子</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h2 id=\"第一章：数据结构的\"><a href=\"#第一章：数据结构的\" class=\"headerlink\" title=\"第一章：数据结构的\"></a>第一章：数据结构的</h2><p>基本概念</p>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><ul>\n<li>在任何问题中，数据元素都不是孤立存在的，而是在它们之间存在着某种关系，这种数据元素相互之间的关系称为结构（Structure）。数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。</li>\n</ul>\n<h3 id=\"逻辑结构\"><a href=\"#逻辑结构\" class=\"headerlink\" title=\"逻辑结构\"></a>逻辑结构</h3><ul>\n<li>逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的</li>\n<li>数据的逻辑结构分为线性结构和非线性结构<ul>\n<li>集合 结构中的数据元素之间除了“同属于一个集合”的关系外，别无其他关系。 类似于数学上的集合</li>\n<li>线性结构 结构中的数据元素之间只存在一对一的关系。比如排队</li>\n<li>树形结构 结构中的数据元素之间存在一对多的关系。比如家族族谱</li>\n<li>图状结构或网状结构 结构中的数据元素之间存在多对多的关系。 比如地图</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"物理结构\"><a href=\"#物理结构\" class=\"headerlink\" title=\"物理结构\"></a>物理结构</h3><ul>\n<li>存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。数据的存储结构主要有：顺序存储、链式存储、索引存储和散列存储。<ul>\n<li>顺序存储：存储的物理位置相邻。（p.s. 物理位置即信息在计算机中的位置。）</li>\n<li>链接存储：存储的物理位置未必相邻，通过记录相邻元素的物理位置来找到相邻元素。</li>\n<li>索引存储：类似于目录，以后可以联系操作系统的文件系统章节来理解。</li>\n<li>散列存储：通过关键字直接计算出元素的物理地址（以后详解）。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"算法的五个特征\"><a href=\"#算法的五个特征\" class=\"headerlink\" title=\"算法的五个特征\"></a>算法的五个特征</h3><ul>\n<li>1，有穷性：有限步之后结束</li>\n<li>2，确定性：不存在二义性，即没有歧义</li>\n<li>3，可行性：比如受限于计算机的计算能力，有些算法虽然理论上可行，但实际上无法完成。</li>\n<li>4，输入：能被计算机处理的各种类型数据，如数字，音频，图像等等。</li>\n<li>5，输出：一至多个程序输出结果。</li>\n</ul>\n<h3 id=\"算法的复杂度\"><a href=\"#算法的复杂度\" class=\"headerlink\" title=\"算法的复杂度\"></a>算法的复杂度</h3><ul>\n<li>时间复杂度：<ul>\n<li>• 它用来衡量算法随着问题规模增大，算法执行时间增长的快慢；</li>\n<li>• 是问题规模的函数：T(n)是时间规模函数 时间复杂度主要分析T(n)的数量级</li>\n<li>• T(n)&#x3D;O(f(n)) f(n)是算法中基本运算的频度 一般我们考虑最坏情况下的时间复杂度</li>\n</ul>\n</li>\n<li>空间复杂度：<ul>\n<li>• 它用来衡量算法随着问题规模增大，算法所需空间的快慢；</li>\n<li>• 是问题规模的函数：S(n)&#x3D;O(g(n)) ；算法所需空间的增长率和g(n)的增长率相同。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"概要-复杂度计算为重点\"><a href=\"#概要-复杂度计算为重点\" class=\"headerlink\" title=\"概要: 复杂度计算为重点\"></a>概要: 复杂度计算为重点</h3><ul>\n<li>常用的时间复杂度大小关系：</li>\n<li>复杂度如何计算<ul>\n<li>时间复杂度计算（单个循环体）<ul>\n<li>直接关注循环体的执行次数，设为k</li>\n</ul>\n</li>\n<li>时间复杂度计算（多个循环体）<ul>\n<li>两个运算规则：乘法规则，加法规则。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二章：线性表\"><a href=\"#第二章：线性表\" class=\"headerlink\" title=\"第二章：线性表\"></a>第二章：线性表</h2><h3 id=\"线性表的逻辑结构\"><a href=\"#线性表的逻辑结构\" class=\"headerlink\" title=\"线性表的逻辑结构\"></a>线性表的逻辑结构</h3><ul>\n<li>定义：线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列。其中n为表长。当n&#x3D;0时 线性表是一个空表</li>\n<li>特点：线性表中第一个元素称为表头元素；最后一个元素称为表尾元素。<br>除第一个元素外，每个元素有且仅有一个直接前驱。<br>除最后一个元素外，每个元素有且仅有一个直接后继。</li>\n</ul>\n<h3 id=\"线性表的顺序存储结构\"><a href=\"#线性表的顺序存储结构\" class=\"headerlink\" title=\"线性表的顺序存储结构\"></a>线性表的顺序存储结构</h3><ul>\n<li>线性表的顺序存储又称为顺序表。<br>它是用一组地址连续的存储单元（比如C语言里面的数组），依次存储线性表中的数据元素，从而使得逻<br>辑上相邻的两个元素在物理位置上也相邻。</li>\n<li>建立顺序表的三个属性:<br>1.存储空间的起始位置（数组名data）<br>2.顺序表最大存储容量（MaxSize）<br>3.顺序表当前的长度（length）</li>\n<li>其实数组还可以动态分配空间，存储数组的空间是在程序执行过程中通过动态存储分配语句分配</li>\n<li>总结：<ul>\n<li>1.顺序表最主要的特点是随机访问（C语言中基于数组），即通过首地址和元素序号可以在O(1)的时间内找到指定的元素。</li>\n<li>2.顺序表的存储密度高，每个结点只存储数据元素。无需给表中元素花费空间建立它们之间的逻辑关系（因为物理位置相邻特性决定）</li>\n<li>3.顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"顺序表的操作\"><a href=\"#顺序表的操作\" class=\"headerlink\" title=\"顺序表的操作\"></a>顺序表的操作</h3><ul>\n<li>1.插入<ul>\n<li>算法思路：<ul>\n<li>1.判断i的值是否正确</li>\n<li>2.判断表长是否超过数组长度</li>\n<li>3.从后向前到第i个位置，分别将这些元素都向后移动一位</li>\n<li>4.将该元素插入位置i 并修改表长</li>\n</ul>\n</li>\n<li>代码</li>\n<li>分析：<ul>\n<li>最好情况：在表尾插入（即i&#x3D;n+1），元素后移语句将不执行，时间复杂度为O(1)。</li>\n<li>最坏情况：在表头插入（即i&#x3D;1），元素后移语句将执行</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>n次，时间复杂度为O(n)。<br>        * 平均情况：假设pi（pi&#x3D;1&#x2F;(n+1) ）是在第i个位置上插入<br>一个结点的概率，则在长度为n的线性表中插入一个结<br>点时所需移动结点的平均次数为</p>\n<ul>\n<li>2.删除<ul>\n<li>算法思路：<ul>\n<li>1.判断i的值是否正确</li>\n<li>2.取删除的元素</li>\n<li>3.将被删元素后面的所有元素都依次向前移动一位</li>\n<li>4.修改表长</li>\n</ul>\n</li>\n<li>代码</li>\n<li>分析<ul>\n<li>最好情况：删除表尾元素（即i&#x3D;n），无须移动元素，时间复杂度为O(1)。</li>\n<li>最坏情况：删除表头元素（即i&#x3D;1），需要移动除第一个元素外的所有元素，时间复杂度为O(n)。</li>\n<li>平均情况：假设pi(pi&#x3D;1&#x2F;n)是删除第i个位置上结点的概率，则在长度为n的线性表中删除一个结点时所需移动结点的平均次数为</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线性表的链式存储结构\"><a href=\"#线性表的链式存储结构\" class=\"headerlink\" title=\"线性表的链式存储结构\"></a>线性表的链式存储结构</h3><ul>\n<li>线性表的链式存储是指通过一组任意的存储单元来存储线性表中的数据元素。</li>\n<li>头结点和头指针的区别？<ul>\n<li>不管带不带头结点，头指针始终指向链表的第一个结点，而头结点是带头结点链表中的第一个结点，结点内通常不存储信息</li>\n</ul>\n</li>\n<li>为什么要设置头结点？<ul>\n<li>1.处理操作起来方便 例如：对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了</li>\n<li>2.无论链表是否为空，其头指针是指向头结点的非空指针，因此空表和非空表的处理也就统一了。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"单链表的操作\"><a href=\"#单链表的操作\" class=\"headerlink\" title=\"单链表的操作\"></a>单链表的操作</h3><ul>\n<li>1.头插法建立单链表：<ul>\n<li>建立新的结点分配内存空间，将新结点插入到当前链表的表头</li>\n<li>代码</li>\n</ul>\n</li>\n<li>2.尾插法建立单链表：<ul>\n<li>建立新的结点分配内存空间，将新结点插入到当前链表的表尾</li>\n<li>代码</li>\n</ul>\n</li>\n<li>3.按序号查找结点<ul>\n<li>在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止,否则返回最后一个结点指针域NULL。</li>\n<li>代码</li>\n</ul>\n</li>\n<li>4.按值查找结点<ul>\n<li>从单链表第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针；若整个单链表中没有这样的结点，则返回NULL。</li>\n<li>代码</li>\n</ul>\n</li>\n<li>5．插入<ul>\n<li>插入操作是将值为x的新结点插入到单链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i−1个结点，再在其后插入新结点。</li>\n<li>算法思路：<br>1.取指向插入位置的前驱结点的指针<br>① p&#x3D;GetElem(L,i-1);<br>2.令新结点<em>s的指针域指向</em>p的后继结点<br>② s-&gt;next&#x3D;p-&gt;next;<br>3.令结点<em>p的指针域指向新插入的结点</em>s<br>③ p-&gt;next&#x3D;s;</li>\n</ul>\n</li>\n<li>6．删除<ul>\n<li>删除操作是将单链表的第i个结点删除。先检查删除位置的合法性，然后查找表中第i−1个结点，即被删结点的前驱结点，再将其删除。</li>\n<li>算法思路：<br>1.取指向删除位置的前驱结点的指针 p&#x3D;GetElem(L,i-1);<br>2.取指向删除位置的指针 q&#x3D;p-&gt;next;<br>3.p指向结点的后继指向被删除结点的后继 p-&gt;next&#x3D;q-&gt;next<br>4.释放删除结点 free(q);</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"双链表\"><a href=\"#双链表\" class=\"headerlink\" title=\"双链表\"></a>双链表</h3><ul>\n<li>定义</li>\n<li>1.插入：(方法不唯一)<br>① s-&gt;next&#x3D;p-&gt;next;<br>② p-&gt;next-&gt;prior&#x3D;s;<br>③ s-&gt;prior&#x3D;p;<br>④ p-&gt;next&#x3D;s;</li>\n<li>2.删除：<br>① p-&gt;next&#x3D;q-&gt;next;<br>② q-&gt;next-&gt;prior&#x3D;p;<br>③ free(q);</li>\n</ul>\n<h3 id=\"循环链表-静态链表\"><a href=\"#循环链表-静态链表\" class=\"headerlink\" title=\"循环链表&amp;&amp;静态链表\"></a>循环链表&amp;&amp;静态链表</h3><ul>\n<li>循环单链表：循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环</li>\n<li>循环双链表：类比循环单链表，循环双链表链表区别于双链表就是首尾结点构成环<ul>\n<li>当循环双链表为空表时，其头结点的prior域和next域都等于Head。</li>\n</ul>\n</li>\n<li>静态链表：静态链表是用数组来描述线性表的链式存储结构。<ul>\n<li>数组第一个元素不存储数据，它的指针域存储第一个元素所在的数组下标。链表最后一个元素的指针域值为-1。</li>\n<li>例子</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第三章：栈和队列\"><a href=\"#第三章：栈和队列\" class=\"headerlink\" title=\"第三章：栈和队列\"></a>第三章：栈和队列</h2><h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><ul>\n<li>栈（Stack）：只允许在一端进行插入或删除操作的线性表。</li>\n<li>栈顶（Top）：线性表允许进行插入和删除的那一端。</li>\n<li>栈底（Bottom）：固定的，不允许进行插入和删除的另一端</li>\n<li>特点：<br>1.栈是受限的线性表，所以自然具有线性关<br>系。<br>2.栈中元素后进去的必然先出来，即后进先出<br>LIFO（Last In First Out）<ul>\n<li>栈中元素后进<br>去的必然先出<br>来，即后进先<br>出LIFO（Last In<br>First Out）</li>\n</ul>\n</li>\n<li>顺序栈<ul>\n<li>栈是线性表的特例，那栈的顺序存储也是线性表顺序存储的简化。栈的顺序存储结构也叫作顺序栈。</li>\n<li>顺序栈的操作<ul>\n<li>1.判空：</li>\n<li>2.进栈：</li>\n<li>3.出栈：</li>\n<li>4.读取栈顶元素：</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>共享栈<ul>\n<li>顺序栈的存储空间大小需要事先开辟好，很多时候对每个栈各自单独开辟存储空间的利用率不如将各个栈的存储空间共享</li>\n<li>示意图</li>\n<li>共享栈的结构</li>\n<li>共享栈的操作：（进栈）</li>\n</ul>\n</li>\n<li>链式栈<ul>\n<li>栈是线性表的特例，线性表的存储结构还有链式存储结构，所以也可以用链表的方式来实现栈。栈的链式存储结构也叫作链栈。</li>\n<li>特点<br>1.链栈一般不存在栈满的情况。<br>2.空栈的判定条件通常定为top&#x3D;&#x3D;NULL；</li>\n<li>结构</li>\n<li>链式栈的操作<ul>\n<li>1.进栈</li>\n<li>2.出栈</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><ul>\n<li>队列是只允许在一端进行插入，而在另一端进行删除的线性表</li>\n<li>队头（Front）：允许删除的一端，又称为队首。</li>\n<li>队尾（Rear）： 允许插入的一端。</li>\n<li>先进入队列的元素必然先离开队列，即先进先出（First In First Out）简称FIFO</li>\n<li>顺序队列<ul>\n<li>用数组来实现队列，可以将队首放在数组下标为0的位置。</li>\n</ul>\n</li>\n<li>循环队列<ul>\n<li>把数组“掰弯”，形成一个环。Rear指针到了下标为4的位置还能继续指回到下标为0的地方。这样首尾相连的顺序存储的队列就叫循环队列</li>\n<li>入队：rear&#x3D;(rear+1)%MaxSize</li>\n<li>出队：front&#x3D;(front+1)%MaxSize</li>\n<li>循环队列的操作<ul>\n<li>1.入队：</li>\n<li>2.出队：</li>\n</ul>\n</li>\n<li>概要: 那如何分辨队列是空还是满呢？<ul>\n<li>方法一：设置标志位flag，当flag&#x3D;0且rear等于front时为队列空，当flag&#x3D;1且rear等于front时为队列满。</li>\n<li>方法二：我们把front&#x3D;rear仅作为队空的判定条件。当队列满的时候，令数组中仍然保留一个空余单元。我们认为这种情况就是队列满了。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>链式队列<ul>\n<li>队列的链式存储结构，其实就是线性表的单链表，只不过需要加点限制，只能表尾插入元素，表头删除元素。</li>\n<li>为了方便操作，我们分别设置队头指针和队尾指针，队头指针指向头结点，队尾指针指向尾结点。</li>\n<li>链式队列的操作<ul>\n<li><p>1.入队：我们知道队列只能从队尾插入元素，队头删除元素。于是入队就是在队尾指针进行插入结点操作。链队的插入操作和单链表的插入操作是一致的。</p>\n</li>\n<li><p>2.出队：出队就是头结点的后继结点出队，然后将头结点的后继改为它后面的结点。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>双端队列<ul>\n<li>双端队列是指允许两端都可以进行入队和出队操作的队列</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"栈的应用\"><a href=\"#栈的应用\" class=\"headerlink\" title=\"栈的应用\"></a>栈的应用</h3><ul>\n<li>1、括号匹配：假设有两种括号，一种圆的()，一种方的[]，嵌套的顺序是任意的。<ul>\n<li><p>算法思想：若是左括号，入栈；若是右括号，出栈一个左括号判断是否与之匹配；检验到字符串尾，还要检查栈是否为空。只有栈空，整个字符串才是括号匹配的。</p>\n</li>\n<li><p>代码</p>\n</li>\n</ul>\n</li>\n<li>2、表达式求值：<ul>\n<li></li>\n<li>规则：从左到右扫描表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈然后跟这个符号进行运算，最后将运算结果进栈，直到最终获得结果。</li>\n</ul>\n</li>\n<li>3、递归：<ul>\n<li>要理解递归，你要先理解递归，直到你能理解递归。<br>如果在一个函数、过程或数据结构的定义中又应用了它自身，那么这个函数、过程或数据结构称为是递归定义的，简称递归。递归最重要的是递归式和递归边界。</li>\n<li>1.阶乘<ul>\n<li>时间复杂度：O(NlogN)</li>\n</ul>\n</li>\n<li>2.斐波那契数列<ul>\n<li>时间复杂度   O(2^n)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>概要: 如何将中缀表达式转换成后缀表达式？<ul>\n<li>1.按运算符优先级对所有运算符和它的运算数加括号。(原本的括号不用加)</li>\n<li>2.把运算符移到对应的括号后。</li>\n<li>3.去掉括号。</li>\n<li>例子</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第四章：树\"><a href=\"#第四章：树\" class=\"headerlink\" title=\"第四章：树\"></a>第四章：树</h2><h3 id=\"树的基本概念\"><a href=\"#树的基本概念\" class=\"headerlink\" title=\"树的基本概念\"></a>树的基本概念</h3><ul>\n<li>树是递归定义的结构</li>\n<li>结点<ul>\n<li>根节点：树只有一个根结点</li>\n<li>结点的度：结点拥有的子树的数量<ul>\n<li>度为0：叶子结点或者终端结点</li>\n<li>度不为0：分支结点或者非终端结点<ul>\n<li>分支结点除去根结点也称为内部结点</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>树的度：树中所有结点的度数的最大值</li>\n<li>结点关系<ul>\n<li>祖先结点<ul>\n<li>根结点到该结点的唯一路径的任意结点</li>\n</ul>\n</li>\n<li>子孙结点</li>\n<li>双亲结点<ul>\n<li>根结点到该结点的唯一路径上最接近该结点的结点</li>\n</ul>\n</li>\n<li>孩子结点</li>\n<li>兄弟结点<ul>\n<li>有相同双亲结点的结点</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>层次，高度，深度，树的高度<ul>\n<li>层次：根为第一层，它的孩子为第二层，以此类推</li>\n<li>结点的深度：根结点开始自顶向下累加</li>\n<li>结点的高度：叶节点开始自底向上累加</li>\n<li>树的高度（深度）：树中结点的最大层数</li>\n</ul>\n</li>\n<li>树的性质<ul>\n<li>1.树中的结点数等于所有结点的度数加1。<ul>\n<li>证明：不难想象，除根结点以外，每个结点有且仅有一个指向它的前驱结点。也就是说每个结点和指向它的分支一一对应。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>假设树中一共有b个分支，那么除了根结点，整个树就包含有b个结点，所以整个树的结点数就是这b个结点加上根结点，设为n，则n&#x3D;b+1。而分支数b也就是所有结点的度数，证毕。<br>    * 2.度为m的树中第i层上至多有m^(i−1)个结点（i≥1）。<br>        * 证明：（数学归纳法）<br>首先考虑i&#x3D;1的情况：第一层只有根结点，即一个结点，i&#x3D;1带入式子满足。<br>假设第i-1层满足这个性质，第i-1层最多有m i-2个结点。<br>……… ……….<br>i-1层<br>………<br>又因为树的度为m,所以对于第i-1层的每个结点，最多<br>有m个孩子结点。所以第i层的结点数最多是i-1层的m<br>倍，所以第i层上最多有m ^(i-1)个结点。<br>    * 3.高度为h的m叉树至多有(m^h-1)&#x2F;(m-1)个结点<br>    * 4.具有n个结点的m叉树的最小高度为logm(n(m-1)+1) </p>\n<h3 id=\"树的存储结构\"><a href=\"#树的存储结构\" class=\"headerlink\" title=\"树的存储结构\"></a>树的存储结构</h3><ul>\n<li>顺序存储结构<ul>\n<li>双亲表示法：用一组连续的存储空间存储树的结点，同时在每个结点中，用一个变量存储该结点的双亲结点在数组中的位置。</li>\n</ul>\n</li>\n<li>链式存储结构<ul>\n<li><p>孩子表示法：把每个结点的孩子结点排列起来存储成一个单链表。所以n个结点就有n个链表；<br>如果是叶子结点，那这个结点的孩子单链表就是空的；<br>然后n个单链表的的头指针又存储在一个顺序表（数组）中。</p>\n</li>\n<li><p>孩子兄弟表示法：顾名思义就是要存储孩子和孩子结点的兄弟，具体来说，就是设置两个指针，分别指向该结</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>点的第一个孩子结点和这个孩子结点的右兄弟结点。</p>\n<h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><ul>\n<li>定义<ul>\n<li>二叉树是n（n≥0）个结点的有限集合：<br>① 或者为空二叉树，即n&#x3D;0。<br>② 或者由一个根结点和两个互不相交的被称为根的左子树<br>和右子树组成。左子树和右子树又分别是一棵二叉树。 <ul>\n<li>1.每个结点最多有两棵子树。</li>\n<li>2.左右子树有顺序</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>二叉树的五种基本形态：<ul>\n<li>1.空树</li>\n<li>2.只有一个根结点</li>\n<li>3.根结点只有左子树</li>\n<li>4.根结点只有右子树</li>\n<li>5.根结点既有左子树又有右子树</li>\n</ul>\n</li>\n<li>特殊二叉树<ul>\n<li>1.斜树</li>\n<li>2.满二叉树:</li>\n<li>3.完全二叉树</li>\n</ul>\n</li>\n<li>二叉树的性质<ul>\n<li>1.非空二叉树上叶子结点数等于度为2的结点数加1</li>\n<li>2.非空二叉树上第K层上至多有2^k−1个结点（K≥1）</li>\n<li>3.高度为H的二叉树至多有2^H-1个结点（H≥1）</li>\n<li>4.具有N个（N&gt;0）结点的完全二叉树的高度为 [log2(N+1)]或[log2N] +1。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二叉树的存储结构\"><a href=\"#二叉树的存储结构\" class=\"headerlink\" title=\"二叉树的存储结构\"></a>二叉树的存储结构</h3><ul>\n<li>顺序存储<ul>\n<li>二叉树的顺序存储结构就是用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素。</li>\n</ul>\n</li>\n<li>链式存储<ul>\n<li>二叉树每个结点最多两个孩子，所以设计二叉树的结点结构时考虑两个指针指向该结点的两个孩子。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h3><ul>\n<li>先序遍历：<br>1）访问根结点；<br>2）先序遍历左子树；<br>3）先序遍历右子树。<ul>\n<li>递归</li>\n<li>非递归</li>\n</ul>\n</li>\n<li>中序遍历：<br>1）中序遍历左子树；<br>2）访问根结点；<br>3）中序遍历右子树。<ul>\n<li>递归</li>\n<li>非递归</li>\n</ul>\n</li>\n<li>后序遍历：<br>1）后序遍历左子树；<br>2）后序遍历右子树；<br>3）访问根结点。<ul>\n<li>递归</li>\n<li>非递归</li>\n</ul>\n</li>\n<li>层次遍历：<br>若树为空，则什么都不做直接返回。<br>否则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</li>\n</ul>\n<h3 id=\"线索二叉树\"><a href=\"#线索二叉树\" class=\"headerlink\" title=\"线索二叉树\"></a>线索二叉树</h3><ul>\n<li><p>N个结点的二叉链表，每个结点都有指向左右孩子的<br>结点指针，所以一共有2N个指针，而N个结点的二叉<br>树一共有N-1条分支，也就是说存在2N-(N-1)&#x3D;N+1个空指针。比如左图二叉树中有6个结点，那么就有7个空<br>指针。</p>\n</li>\n<li><p>大量的空余指针能否利用起来？</p>\n<ul>\n<li>指向前驱和后继的指针称为线索，加上线索的二叉链表就称为线索链表，相应的二叉树就称为线索二叉树</li>\n<li>对二叉树以某种次序遍历使其变为线索二叉树的过程就叫做线索化</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"哈夫曼树和哈夫曼编码\"><a href=\"#哈夫曼树和哈夫曼编码\" class=\"headerlink\" title=\"哈夫曼树和哈夫曼编码\"></a>哈夫曼树和哈夫曼编码</h3><ul>\n<li>算法的描述如下：<br>1）将这N个结点分别作为N棵仅含一个结点的二叉树，构成森林F。<br>2）构造一个新结点，并从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值<br>置为左、右子树上根结点的权值之和。<br>3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中。<br>4）重复步骤2）和3），直至F中只剩下一棵树为止。</li>\n</ul>\n<h2 id=\"第五章：图\"><a href=\"#第五章：图\" class=\"headerlink\" title=\"第五章：图\"></a>第五章：图</h2><h3 id=\"图的基本概念\"><a href=\"#图的基本概念\" class=\"headerlink\" title=\"图的基本概念\"></a>图的基本概念</h3><ul>\n<li>定义：<br>树是N（N≥0）个结点的有限集合，N&#x3D;0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：<br>1）有且仅有一个特定的称为根的结点。<br>2）当N&gt;1时，其余结点可分为m（m&gt;0）个互不相交的有限集合T1，T2，…，Tm，其中每一个集合本身又是一棵树，并且称为根结点的子树。<ul>\n<li>图G由顶点集V和边集E组成，记为G&#x3D;(V，E)<ul>\n<li>V(G)表示图G中顶点的有限非空集。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>用|V|表示图G中顶点的个数，也称为图G的阶<br>        * E(G)表示图G中顶点之间的关系（边）集合。<br>用|E|表示图G中边的条数。</p>\n<ul>\n<li>分类<ul>\n<li>有向图<ul>\n<li>有向边（弧）的有限集合<ul>\n<li>弧是顶点的有序对</li>\n<li>&lt;v,w&gt;</li>\n<li>v是弧尾，w是弧头</li>\n<li>v邻接到w或w邻接自v</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>无向图<ul>\n<li>无向边的有限集合<ul>\n<li>边是顶点的无序对</li>\n<li>（v,w）</li>\n<li>（v,w）&#x3D;(w,v)</li>\n<li>w，v互为邻接点</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>简单图<ul>\n<li>1.不存在顶点到自身的边</li>\n<li>2.同一条边不重复出现</li>\n</ul>\n</li>\n<li>多重图<ul>\n<li>若图G中某两个结点之间的边数多于一条，又允许顶点通过通过同一个边和自己关联</li>\n</ul>\n</li>\n<li>完全图<ul>\n<li>无向完全图<ul>\n<li>如果任意两个顶点之间都存在边</li>\n</ul>\n</li>\n<li>有向完全图<ul>\n<li>如果任意两个顶点之间都存在方向相反的两条弧</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>子图</li>\n<li>连通图：图中任意两个顶点都是连通的</li>\n<li>连通分量：无向图中的极大连通子图<ul>\n<li>连通<ul>\n<li>顶点A到顶点B有路径</li>\n</ul>\n</li>\n<li>极大<ul>\n<li>1.顶点足够多</li>\n<li>2.极大连通子图包含这些依附这些顶点的所有边</li>\n</ul>\n</li>\n<li>结论1:如果一个图有n个顶点，并且有小于n-1条边，则此图必是非连通图。</li>\n<li>概要: 找连通分量的方法：<br>从选取一个顶点开始，以这个顶点作为一个子图，然后逐个添加与这个子图相连的顶点和边直到所有相连的顶点都加入该子图</li>\n</ul>\n</li>\n<li>强连通：顶点V到顶点W和顶点W到顶点V都有路径</li>\n<li>强连通图：图中任一对顶点都是强连通的</li>\n<li>连通图的生成树：包含图中全部n个顶点，但是只有n-1条边的极小连通子图<ul>\n<li>结论2:生成树去掉一条边则变成非连通图，加上一条边就会形成回路。</li>\n</ul>\n</li>\n<li>度：以该顶点为一个端点的边数目<ul>\n<li>无向图中顶点V的度是指依附于该顶点的边的条数，记为TD(v)</li>\n<li>有向图中顶点V的度分为出度和入度<ul>\n<li>入度（ID）是以顶点v为终点的有向边的数目</li>\n<li>出度（OD）是以顶点V为起点的有向边的数目</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>简单路径和简单回路：顶点不重复出现的路径称为简单路径。对于回路，除了第一个和最后一个顶点其余顶点不重复出现的回路称为简单回路</li>\n<li>权和网：图中每条边考研赋予一定意义的数值，这个数值叫做这条边的权，有权值得图称为带权图，也叫做网</li>\n<li>路径和路径长度：顶点p到q之间的路径是指顶点序列怕保存的，p,a,b,c,d,……q。路径上边的数目就是路径长度</li>\n<li>回路（环）：第一个和最后一个顶点相同的路径称为回路或者环</li>\n<li>距离：从顶点u到v的最短路径长度。不存在路径则为无穷</li>\n</ul>\n<h3 id=\"图的存储结构\"><a href=\"#图的存储结构\" class=\"headerlink\" title=\"图的存储结构\"></a>图的存储结构</h3><ul>\n<li>邻接矩阵（顺序存储）</li>\n<li>邻接表（链式存储）<ul>\n<li>十字链表（有向图）</li>\n<li>邻接多重表（无向图）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"图的遍历\"><a href=\"#图的遍历\" class=\"headerlink\" title=\"图的遍历\"></a>图的遍历</h3><ul>\n<li>深度优先遍历<ul>\n<li>深度优先搜索(DFS:Depth-First-Search):深度优先搜索类似于树的先序遍历算法<ul>\n<li>空间复杂度：由于DFS是一个递归算法，递归是需要一个工作栈来辅助工作，最多需要图中所有顶点进栈，所以时间复杂度为O(|V|)</li>\n<li>时间复杂度：1)邻接表：遍历过程的主要操作是对顶点遍历它的邻接点，由于通过访问边表来查找邻接点，所以时间复杂度为O(|E|),访问顶点时间为O(|V|),所以总的时间复杂度为O(|V|+|E|)<br>        2)邻接矩阵：查找每个顶点的邻接点时间复杂度为O(|V|),对每个顶点都进行查找，所以总的时间复杂度为O(|V|2)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>广度优先遍历<ul>\n<li>广度优先搜索(BFS:Breadth-First-Search):广度优先搜索类似于树的层序遍历算法<ul>\n<li>空间复杂度：BFS需要借助一个队列，n个顶点均需要入队一次，所以最坏情况下n个顶点在队列，那么则需要O(|V|)的空间复杂度。    </li>\n<li>时间复杂度：</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>1)邻接表：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，就需要访问这个顶点的所有边，所以时间复杂度为O(|E|)。所以总的时间复杂度为O(|V|+|E|)<br>2)邻接矩阵：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，需要遍历一遍矩阵的一行，所以时间复杂度为O(|V|),所以总的时间复杂度为O(|V|2)</p>\n<h3 id=\"图的应用\"><a href=\"#图的应用\" class=\"headerlink\" title=\"图的应用\"></a>图的应用</h3><ul>\n<li>最小生成树<ul>\n<li>普利姆（Prlm）<ul>\n<li>①从图中找第一个起始顶点v0，作为生成树的第一个顶点，然后从这个顶点到其他顶点的所有边中选一条权值最小的边。然后把这条边的另一个顶点v和这条边加入到生成树中。</li>\n<li>②对剩下的其他所有顶点，分别检查这些顶点与顶点v的权值是否比这些顶点在lowcost数组中对应的权值小，如果更小，则用较小的权值更新lowcost数组。</li>\n<li>③从更新后的lowcost数组中继续挑选权值最小而且不在生成树中的边，然后加入到生成树。</li>\n<li>④反复执行②③直到所有所有顶点都加入到生成树中。</li>\n<li>概要:  <ul>\n<li>双重循环，外层循环次数为n-1，内层并列的两个循环次数都是n。故普利姆算法时间复杂度为O(n2)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>而且时间复杂度只和n有关，所以适合稠密图<br>    * 克鲁斯卡尔（Kruskal）<br>        * 将图中边按照权值从小到大排列，然后从最小的边开始扫描，设置一个边的集合来记录，如果该边并入不构成回路的话，则将该边并入当前生成树。直到所有的边都检测完为止。<br>        * 概要:<br>            *<br>            *<br>            * 概要: 克鲁斯卡尔算法操作分为对边的权值排序部分和一个单重for循环，它们是并列关系，由于排序耗费时间大于单重循环，所以克鲁斯卡尔算法的主要时间耗费在排序上。排序和图中边的数量有关系，所以适合稀疏图</p>\n<ul>\n<li>最短路径<ul>\n<li>迪杰斯特拉<ul>\n<li>一个源点到其余顶点的最短路径<ul>\n<li>该算法设置一个集合S记录已求得的最短路径的顶点，可用一个数组s[]来实现，初始化为0，当s[vi]&#x3D;1时表示将顶点vi放入S中，初始时把源点v0放入S中。此外，在构造过程中还设置了两个辅助数组：</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>dist[]：记录了从源点v0到其他各顶点当前的最短路径长度，dist[i]初值为arcs[v0][i]。<br>path[]：path[i]表示从源点到顶点i之间的最短路径的前驱结点，在算法结束时，可根据其值追溯得到源点v0到顶点vi的最短路径。</p>\n<p>假设从顶点0出发，也就是顶点0为源点，集合S最初只包含顶点0，邻接矩阵arcs表示带权有向图，arcs[i][j]表示有向边&lt;i，j&gt;的权值，若不存在有向边&lt;i，j&gt;，则arcs[i][j]为∞。Dijkstra算法的步骤如下：<br>1）初始化：集合S初始为{0}，dist[]的初始值dist[i]&#x3D;arcs[0][i]，i&#x3D;1，2，…，n-1。<br>2）找出dist[]中的最小值dist[j]，将顶点j加入集合S，即修改s[vj]&#x3D;1。<br>3）修改从v0出发到集合V-S上任一顶点vk可达的最短路径长度：如果dist[j] + arcs[j][k]&lt; dist[k]，则令dist[k]&#x3D;dist[j] + arcs[j][k]。另外更新path[k]&#x3D;j(也就是顶点j加入集合之后如果有新的路径使得到顶点k路径变短的话就将到顶点k的路径长度修改成较短的)<br>4）重复2）～3）操作共n-1次，直到所有的顶点都包含在S中。<br>    * 弗洛伊德<br>        * 所有顶点到所有顶点的最短路径<br>            * 算法思想：<br>递推产生一个n阶方阵序列A(−1)，A(0)，…，A(k)，…，A(n−1)<br>其中A(k)[i][j]表示从顶点vi到顶点vj的路径长度，k表示绕行第k个顶点的运算步骤。初始时，对于任意两个顶点vi和vj，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以∞作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点k(k&#x3D;0，1，…，n-1)作为中间顶点。如果增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径<br>    * 非带权图<br>        * 两点之间经过边数最少的路径<br>    * 带权图<br>        * 两点之间经过的边上权值之和最小的路径</p>\n<ul>\n<li>拓扑排序<ul>\n<li><p>AOV</p>\n<ul>\n<li>如果我们把每个环节看成图中一个顶点，在这样一个有向图中，用顶点表示活动，用弧表示活动之间的优先关系，那么这样的有向图称为AOV网(Activity On Vertex)</li>\n</ul>\n</li>\n<li><p>拓扑排序就是对一个有向图构造拓扑序列的过程，构造会有两种结果：</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>如果此图全部顶点都被输出了，说明它是不存在回路的AOV网；<br>如果没有输出全部顶点，则说明这个图存在回路，不是AOV网。<br>    * 拓扑排序算法：<br>     从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为弧尾的弧。重复这个步骤直到输出图中全部顶点，或者找不到入度为0的顶点为止。</p>\n<ul>\n<li>关键路径<ul>\n<li>AOE(Activity On Edge):在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网称为AOE网。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第六章：查找\"><a href=\"#第六章：查找\" class=\"headerlink\" title=\"第六章：查找\"></a>第六章：查找</h2><h3 id=\"查找的基本概念和顺序查找\"><a href=\"#查找的基本概念和顺序查找\" class=\"headerlink\" title=\"查找的基本概念和顺序查找\"></a>查找的基本概念和顺序查找</h3><ul>\n<li>查找定义：在数据集合中寻找满足某种条件的数据元素的过程称为查找</li>\n<li>关键字：数据元素中某个可以以唯一标识该元素的数据项</li>\n<li>平均查找长度（ASL：Average Search Length）:在查找的过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值</li>\n<li>顺序查找(线性查找)，主要用于在线性表中进行查找。从查找表的一端开始，顺序扫描查找表，依次将扫描到的关键字和待查找的值key进行比较。如果相等，则查找成功。如果扫描结束仍然没有发现相等的数据元素，则查找失败。<ul>\n<li>1</li>\n<li>2</li>\n<li>3 </li>\n<li>4</li>\n<li>时间复杂度为O(n)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"折半查找\"><a href=\"#折半查找\" class=\"headerlink\" title=\"折半查找\"></a>折半查找</h3><ul>\n<li>算法思路：<ul>\n<li>首先将给定值key与表中中间位置元素的关键字比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分中。然后在缩小的范围内继续进行同样的查找，如此重复直到找到为止，或者确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。</li>\n</ul>\n</li>\n<li>折半查找分析<ul>\n<li>折半查找判定树<ul>\n<li>对于折半查找，查找的比较次数就是从根结点到该结点经历的结点数</li>\n<li>时间复杂度为O(logn)</li>\n<li>概要: 具有N个（N&gt;0）结点的完全二叉树的高度为 [log2(N+1)] 或 [log2N] +1。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分块查找\"><a href=\"#分块查找\" class=\"headerlink\" title=\"分块查找\"></a>分块查找</h3><ul>\n<li>分块查找又称为索引顺序查找</li>\n<li>分块查找思想：<ul>\n<li>①确定待查找值在哪个块（折半查找）</li>\n</ul>\n</li>\n</ul>\n<p>②在确定的块中查找待查找值（顺序查找）</p>\n<ul>\n<li>分块查找分析<ul>\n<li>由于分块查找实际是进行两次查找，所以整个算法的平均查找长度是两次查找的平均查找长度之和。<br>即ASL分块&#x3D;ASL折半+ASL顺序<ul>\n<li></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二叉排序树\"><a href=\"#二叉排序树\" class=\"headerlink\" title=\"二叉排序树\"></a>二叉排序树</h3><ul>\n<li>二叉排序树(Binary Search Tree 也叫二叉搜索树)或者是一棵空树，或者是具有以下性质的二叉树<br>①若左子树不空，则左子树上所有结点的值均小于它的根结点的值。<br>②若右子树不空，则右子树上所有结点的值均大于它的根结点的值。<br>③它的左右子树也是一棵二叉排序树。</li>\n<li>算法思想<ul>\n<li>由于二叉排序树的特点(左子树&lt;根结点&lt;右子树),所以每次查找一个关键字，需要先和根结点进行比较：<br>如果这个关键字小于根结点的值，则再到这个根结点的左子树进行同样的比较操作一直进行下去直到找到该关键字，表示查找成功，或者是空指针，表示查找失败。<br>如果这个关键字大于根结点的值，则再到这个根结点的右子树进行同样的比较操作一直进行下去直到找到该关键字，表示查找成功，或者是空指针，表示查找失败。<ul>\n<li>查找关键字代码<ul>\n<li>1 </li>\n<li>2</li>\n</ul>\n</li>\n<li>插入关键字代码<ul>\n<li>1)空树：直接插入新结点返回成功</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>2)树不空：检查是否存在关键字重复的结点：<br>①存在：返回插入失败<br>②不存在：检查根结点的值和待插入关键字值的大小关系递归插入左右子树<br>            *<br>        * 构造代码<br>            *<br>        * 删除结点<br>            * ①删除的是叶子结点<br>                * 方法：直接删去该结点即可<br>            * ②删除的是仅有左子树或者右子树的结点<br>                * 方法：“子承父业”<br>            * ③删除的是左右子树都有的结点<br>                * 仿照②类型，先将一个孩子“继承父业”，另一个孩子“归顺”于这个孩子<br>方法：找到待删除结点的直接前驱或者直接后继结点，用该结点来替换待删除结点，再删除该结点。</p>\n<ul>\n<li>二叉排序树分析<ul>\n<li>查找时间复杂度是O(n)</li>\n</ul>\n</li>\n<li>概要: “左小右大”</li>\n</ul>\n<h3 id=\"平衡二叉树-AVL树\"><a href=\"#平衡二叉树-AVL树\" class=\"headerlink\" title=\"平衡二叉树(AVL树)\"></a>平衡二叉树(AVL树)</h3><ul>\n<li>平衡二叉树(AVL树)是特殊的二叉排序树，特殊的地方在于左右子树的高度之差绝对值不超过1，而且左右子树又是一棵平衡二叉树。</li>\n<li>平衡因子<ul>\n<li>定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是−1、0或1。</li>\n</ul>\n</li>\n<li>平衡调整<ul>\n<li><p>平衡二叉树的建立过程和二叉排序树的建立过程是相似的，都是从一棵空树开始陆续插入结点。不同的地方在于对于平衡二叉树的建立过程中，由于插入结点可能会破坏结点的平衡性，所以需要进行平衡调整。</p>\n<ul>\n<li>LL调整(左孩子的左子树上插入结点导致)<ul>\n<li>最小不平衡子树根结点的平衡因子为2&gt;0</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>它的左孩子结点平衡因子为1&gt;0<br>两个都大于0，所以直接右旋就可以调整<br>            * 概要: “正则右旋”<br>        * RR调整(右孩子的右子树上插入结点导致)<br>            *  最小不平衡子树根结点的平衡因子为-2&lt;0<br>它的右孩子结点平衡因子为-1&lt;0<br>两个都小于0，所以直接左旋就可以调整<br>            * 概要: “负则左旋”<br>        * LR调整(左孩子的右子树上插入结点导致)<br>        * RL调整(右孩子的左子树上插入结点导致)<br>        * 概要: 先局部转换为LL或RR，最后进行调整</p>\n<ul>\n<li>分析<ul>\n<li>含有n个结点平衡二叉树的最大深度为O(log2n)，因此，平衡二叉树的平均查找长度为O(log2n)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"B树和B-树\"><a href=\"#B树和B-树\" class=\"headerlink\" title=\"B树和B+树\"></a>B树和B+树</h3><ul>\n<li>2-3树<ul>\n<li>2-3树是一种多路查找树：2和3的意思就是2-3树包含两种结点<ul>\n<li>1)2结点包含一个元素和两个孩子(或者没有孩子)。<br>  ①左子树包含的元素小于该结点的元素值，右子树包含的元素大于该结点的元素值<br>  ②2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子</li>\n<li>2)3结点包含一大一小两个元素和三个孩子(或者没有孩子)。(两个元素按大小顺序排列好)<br>  ①左子树包含的元素小于该结点较小的元素值，右子树包含的元素大于该结点较大的元素值，中间子树包含的元素介于这两个元素值之间。<br>  ②3结点要不有三个孩子，要不就没有孩子，不允许有一个或两个孩子</li>\n<li>3)2-3树所有叶子结点都在同一层次</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>2-3-4树<ul>\n<li>2-3-4树也是一种多路查找树：2和3和4的意思就是2-3-4树包含三种结点<ul>\n<li>1)2结点包含一个元素和两个孩子(或者没有孩子)。<br>  ①左子树包含的元素小于该结点的元素值，右子树包含的元素大于该结点的元素值<br>  ②2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子</li>\n<li>2)3结点包含一大一小两个元素和三个孩子(或者没有孩子)。<br>  ①左子树包含的元素小于该结点较小的元素值，右子树包含的元素大于该结点较大的元素值，中间子树包含的元素介于这两个元素值之间。<br>  ②3结点要不有三个孩子，要不就没有孩子，不允许有一个或两个孩子</li>\n<li>3)4结点包含小中大三个元素和四个孩子(或者没有孩子)。<br>  ①左子树包含的元素小于该结点最小的元素值，第二个子树包含大于最小的元素值小于中间元素值的元素，第三个子树包含大于中间元素值小于最大元素值的元素，右子树包含的元素大于该结点最大的元素值。<br>  ②4结点要不有四个孩子，要不就没有孩子，不允许有一个或两个或三个孩子</li>\n<li>4)2-3-4树所有叶子结点都在同一层次</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>B树<ul>\n<li><p>B树也是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例，我们把树中结点最大的孩子数目称为B树的阶。通常记为m。<br>一棵m阶B树或为空树，或为满足如下特性的m叉树：</p>\n<ul>\n<li>1）树中每个结点至多有m棵子树。（即至多含有m-1个关键字) (“两棵子树指针夹着一个关键字”)</li>\n<li>2）若根结点不是终端结点，则至少有两棵子树。(至少一个关键字)</li>\n<li>3）除根结点外的所有非叶结点至少有 ⌈m&#x2F;2⌉棵子树。（即至少含有⌈m&#x2F;2⌉-1个关键字）</li>\n<li>4）所有非叶结点的结构如下：</li>\n<li>5）所有的叶子结点出现在同一层次上，不带信息。(就像是折半查找判断树中查找失败的结点)</li>\n</ul>\n</li>\n<li><p>1.B树的查找操作</p>\n<ul>\n<li>查找过程：①先让待查找关键字key和结点的中的关键字比较，如果等于其中某个关键字，则查找成功。<br>    ②如果和所有关键字都不相等，则看key处在哪个范围内，然后去对应的指针所指向的子树中查找。<br>        Eg:如果Key比第一个关键字K1还小，则去P0指针所指向的子树中查找，如果比最后一个关键字Kn还大，则去Pn指针所指向的子树中查找。</li>\n</ul>\n</li>\n<li><p>2.B树的插入操作</p>\n<ul>\n<li>分裂的方法：取这个关键字数组中的中间关键字(⌈n&#x2F;2⌉)作为新的结点，然后其他关键字形成两个结点作为新结点的左右孩子。</li>\n</ul>\n</li>\n<li><p>3.B树的删除操作</p>\n<ul>\n<li>B树中的删除操作与插入操作类似，但要稍微复杂些，要使得删除后的结点中的关键字个数≥⌈m&#x2F;2⌉-1 ，因此将涉及结点的“合并”问题。由于删除的关键字位置不同，可以分为关键字在终端结点和不在终端结点上两种情况。<ul>\n<li><p>1）如果删除的关键字在终端结点上（最底层非叶子结点）：<br>①结点内关键字数量大于⌈m&#x2F;2⌉-1 ，这时删除这个关键字不会破坏B树的定义要求。所以直接删除。<br>②结点内关键字数量等于⌈m&#x2F;2⌉-1 ，并且其左右兄弟结点中存在关键字数量大于⌈m&#x2F;2⌉-1 的结点，则去兄弟阶段中借关键字。<br>③结点内关键字数量等于⌈m&#x2F;2⌉-1 ，并且其左右兄弟结点中不存在关键字数量大于⌈m&#x2F;2⌉-1 的结点，则需要进行结点合并。</p>\n</li>\n<li><p>2）如果删除的关键字不在终端结点上（最底层非叶子结点）：需要先转换成在终端结点上，再按照在终端结点     上的情况来分别考虑对应的方法。</p>\n<ul>\n<li>相邻关键字：对于不在终端结点上的关键字,它的相邻关键字是其左子树中值最大的关键字或者右子树中值最小的关键字。</li>\n<li>第一种情况：存在关键字数量大于⌈m&#x2F;2⌉-1 的左子树或者右子树，在对应子树上找到该关键字的相邻关键字，然后将相邻关键字替换待删除的关键字。</li>\n<li>第二种情况：左右子树的关键字数量均等于⌈m&#x2F;2⌉-1 ，则将这两个左右子树结点合并，然后删除待删除关键字。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>B+树<ul>\n<li>B+树是常用于数据库和操作系统的文件系统中的一种用于查找的数据结构</li>\n<li>m阶的B+树与m阶的B树的主要差异在于：<br>1）在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；而在B树中，具有n个关键字的结点含有(n+1)棵子树。<br>2）在B+树中，每个结点（非根内部结点）关键字个数n的范围是 ⌈m&#x2F;2⌉≤n≤m（根结点1≤n≤m），在B树中，每个结点（非根内部结点）关键字个数n的范围是⌈m&#x2F;2⌉ -1≤n≤m-1（根结点：1≤n≤m-1）。<br>3）在B+树中，叶结点包含信息，所有非叶结点仅起到索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。<br>4）在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h3><ul>\n<li><p>散列表：根据给定的关键字来计算出关键字在表中的地址的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。</p>\n</li>\n<li><p>散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)&#x3D;Addr。</p>\n</li>\n<li><p>散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为“冲突”，这些发生碰撞的不同关键字称为同义词。</p>\n</li>\n<li><p>构造散列函数的tips：</p>\n<ul>\n<li>1）散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。</li>\n<li>2）散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间，从而减少冲突的发生。</li>\n<li>3）散列函数应尽量简单，能够在较短的时间内就计算出任一关键字对应的散列地址。</li>\n</ul>\n</li>\n<li><p>1.常用Hash函数的构造方法：</p>\n<ul>\n<li>1.开放定址法：直接取关键字的某个线性函数值为散列地址，散列函数为H(key)&#x3D;a×key+b。式中，a和b是常数。这种方法计算最简单，并且不会产生冲突</li>\n<li>2.除留余数法：假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用以下公式把关键字转换成散列地址。散列函数为H(key)&#x3D;key % p<br>除留余数法的关键是选好p，使得每一个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性</li>\n<li>3.数字分析法：设关键字是r进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，则应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合</li>\n<li>4.平方取中法：顾名思义，取关键字的平方值的中间几位作为散列地址。具体取多少位要看实际情况而定。这种方法得到的散列地址与关键字的每一位都有关系，使得散列地址分布比较均匀。</li>\n<li>5.折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以短一些），然后取这几部分的叠加和作为散列地址，这种方法称为折叠法。关键字位数很多，而且关键字中每一位上数字分布大致均匀时，可以采用折叠法得到散列地址。</li>\n</ul>\n</li>\n<li><p>2.常用Hash函数的冲突处理办法：</p>\n<ul>\n<li>1.开放定址法：将产生冲突的Hash地址作为自变量，通过某种冲突解决函数得到一个新的空闲的Hash地址。<ul>\n<li>1）线性探测法：冲突发生时，顺序查看表中下一个单元（当探测到表尾地址m-1时，下一个探测地址是表首地址0），直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。</li>\n<li>2）平方探测法：设发生冲突的地址为d,平方探测法得到的新的地址序列为d+12，d-12，d+22，d-22……</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>平方探测法是一种较好的处理冲突的方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。<br>        * 3）再散列法：又称为双散列法。需要使用两个散列函数，当通过第一个散列函数H(Key)得到的地址发生冲突时，则利用第二个散列函数Hash2(Key)计算该关键字的地址增量。<br>        * 4）伪随机序列法：当发生地址冲突时，地址增量为伪随机数序列，称为伪随机序列法。<br>    * 2.拉链法：对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。拉链法适用于经常进行插入和删除的情况。<br>    * 3.散列表的查找过程：类似于构造散列表，给定一个关键字Key。<br>      先根据散列函数计算出其散列地址。然后检查散列地址位置有没有关键字。<br>         1)如果没有，表明该关键字不存在，返回查找失败。<br>         2)如果有，则检查该记录是否等于关键字。<br>                 ①如果等于关键字，返回查找成功。<br>                 ②如果不等于，则按照给定的冲突处理办法来计算下一个散列地址，再用该地址去执行上述过程。<br>    * 4.散列表的查找性能：和装填因子有关。<br>        *<br>        * α越大，表示装填的记录越“满”，发生冲突的可能性就越大，反之发生冲突的可能性越小</p>\n<h2 id=\"第七章：排序\"><a href=\"#第七章：排序\" class=\"headerlink\" title=\"第七章：排序\"></a>第七章：排序</h2><h3 id=\"排序的基本知识\"><a href=\"#排序的基本知识\" class=\"headerlink\" title=\"排序的基本知识\"></a>排序的基本知识</h3><ul>\n<li>定义：排序就是将原本无序的序列重新排列成有序的序列。</li>\n<li>排序的稳定性<ul>\n<li>如果待排序表中有两个元素Ri、Rj，其对应的关键字keyi&#x3D;keyj，且在排序前Ri在Rj前面，如果使用某一排序算法排序后，Ri仍然在Rj的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"插入类排序\"><a href=\"#插入类排序\" class=\"headerlink\" title=\"插入类排序\"></a>插入类排序</h3><ul>\n<li>直接插入排序<ul>\n<li>直接插入排序：首先以一个元素为有序的序列，然后将后面的元素依次插入到有序的序列中合适的位置直到所有元素都插入有序序列。</li>\n<li>时间复杂度为O(n)</li>\n<li>直接插入排序是稳定性是稳定的。</li>\n</ul>\n</li>\n<li>折半插入排序<ul>\n<li>折半插入排序将比较和移动这两个操作分离出来，也就是先利用折半查找找到插入的位置，然后一次性移动元素，再插入该元素。</li>\n<li>折半插入排序的时间复杂度为O(n^2)</li>\n<li>稳定性：和直接插入排序稳定性相同，是稳定的。</li>\n</ul>\n</li>\n<li>希尔排序<ul>\n<li>希尔排序的基本思想：希尔排序本质上还是插入排序，只不过是把待排序序列分成几个子序列，再分别对这几个子序列进行直接插入排序。<ul>\n<li>①先以增量5来分割序列，也就是下标为0,5,10,15…的关键字分成一组，下标为1,6,11,16..分成一组,然后对这些组分别进行直接插入排序，这就完成了一轮希尔排序。</li>\n<li>②缩小增量(d1&#x3D;n&#x2F;2，di+1&#x3D; [di&#x2F;2]，比如10个数据序列，第一次增量d1&#x3D;10&#x2F;2&#x3D;5,第二次增量d2&#x3D; [d1&#x2F;2]&#x3D; [5&#x2F;2]&#x3D;2,并且最后一个增量等于1),所以第二轮以增量为2进行类似的排序过程。</li>\n<li>③接下来的第三轮，第四轮…都是类似的过程，直到最后一轮以增量为1。此时就是前面所说的直接插入排序。</li>\n<li>概要:</li>\n</ul>\n</li>\n<li>时间复杂度：…  希尔排序的时间复杂度约为O(n^1.3)    在最坏情况下希尔排序的时间复杂度为O(n^2)</li>\n<li>空间复杂度：希尔排序的空间复杂度为O(1)</li>\n<li>稳定性：不稳定，由于不同的增量可能就会把相等的关键字划分到两个直接插入排序中进行排序， 可能就会造成相对顺序变化。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"交换类排序\"><a href=\"#交换类排序\" class=\"headerlink\" title=\"交换类排序\"></a>交换类排序</h3><ul>\n<li>冒泡排序<ul>\n<li>假设待排序表长为n，从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]&gt;A[i]），则交换它们，直到序列比较完。我们称它为一趟冒泡，结果将最小的元素交换到待排序列的第一个位置。下一趟冒泡时，前一趟确定的最小元素不再参与比较，待排序列减少一个元素，每趟冒泡的结果把序列中的最小元素放到了序列的最终位置，……，这样最多做n-1趟冒泡就能把所有元素排好序。</li>\n<li>空间复杂度：交换时开辟了存储空间来存储中间变量，所以空间复杂度为O(1)</li>\n<li>时间复杂度</li>\n<li>稳定性：当两个关键字相等，if判断条件不成立，所以不会发生数据移动。所以是稳定的。</li>\n</ul>\n</li>\n<li>快速排序<ul>\n<li>快速排序是一种基于分治法的排序方法。<br>每一趟快排选择序列中任一个元素作为枢轴(pivot)(通常选第一个元素)，将序列中比枢轴小的元素都移到枢轴前边，比枢轴大的元素都移到枢轴后边。<ul>\n<li>1</li>\n<li>2</li>\n</ul>\n</li>\n<li>时间复杂度：<br>最好情况下时间复杂度为O(nlogn) ,待排序序列越无序，算法效率越高。<br> 最坏情况下时间复杂度为O(n^2)，待排序序列越有序，算法效率越低。</li>\n<li>空间复杂度：<br>由于快速排序是递归的，需要借助一个递归工作栈来保存每一层递归调用的必要信息，其容量应与递归调用的最大深度一致。<br>最好情况下为 ⌈log2(n+1)⌉(每次partition都很均匀)递归树的深度O(logn)<br>最坏情况下，因为要进行n-1次递归调用，所以栈的深度为O(n)；</li>\n<li>稳定性：快速排序是不稳定的，是因为存在交换关键字。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"选择类排序\"><a href=\"#选择类排序\" class=\"headerlink\" title=\"选择类排序\"></a>选择类排序</h3><ul>\n<li>简单选择排序<ul>\n<li></li>\n<li>空间复杂度：需要额外的存储空间仅为交换元素时借助的中间变量，所以空间复杂度是O(1)</li>\n<li>时间复杂度：<br>关键操作在于交换元素操作，整个算法由双重循环组成，外层循环从0到n-2一共n-2+1&#x3D;n-1次，<br>对于第i层外层循环，内层循环执行n-1-(i+1)+1&#x3D;n-i-1次。<br>            当i&#x3D;0,内层循环执行n-1次，当i&#x3D;n-2,内层循环执行1次，所以是一个等差数列求和,一共为(1+n-1)(n-1)&#x2F;2&#x3D;n(n-1)&#x2F;2 ,所以时间复杂度为O(n^2)</li>\n<li>稳定性：不稳定   原因就在于交换部分会打破相对顺序</li>\n</ul>\n</li>\n<li>堆排序<ul>\n<li><p>什么是堆？</p>\n<ul>\n<li>堆是一棵完全二叉树，而且满足任何一个非叶结点的值都不大于(或不小于)其左右孩子结点的值。<ul>\n<li>如果是每个结点的值都不小于它的左右孩子结点的值，则称为大顶堆。</li>\n<li>如果是每个结点的值都不大于它的左右孩子结点的值，则称为小顶堆。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>什么是堆排序？</p>\n<ul>\n<li>我们知道对于一个堆来说，它的根结点是整个堆中所有结点的值的最大值(大顶堆)或者最小值(小顶堆)。所以堆排序的思想就是每次将无序序列调节成一个堆，然后从堆中选择堆顶元素的值，这个值加入有序序列，无序序列减少一个，再反复调节无序序列，直到所有关键字都加入到有序序列。<ul>\n<li></li>\n<li></li>\n</ul>\n</li>\n<li>时间复杂度：<br> 堆排序的总时间可以分为①建堆部分+②n-1次向下调整堆</li>\n</ul>\n<p> 堆排序的时间复杂度为O(n)+O(nlog2n)&#x3D;O(nlog2n)</p>\n<ul>\n<li>堆排序不稳定</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><ul>\n<li>假定待排序表含有n个记录，则可以看成是n个有序的子表，每个子表长度为1，然后两两归并，得到 ⌈n&#x2F;2⌉个长度为2或1的有序表；再两两归并，……如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为2-路归并排序。<ul>\n<li></li>\n<li></li>\n</ul>\n</li>\n<li>例如：49 38 65 97 76 13 27<ul>\n<li>①首先将整个序列的每个关键字看成一个单独的有序的子序列</li>\n<li>②两两归并，49和38归并成{38 49} ，65和97归并成{65 97}，76和13归并成{13 76}，27没有归并对象</li>\n<li>③两两归并，{38 49}和{65 97}归并成{38 49 65 97}，{13,76}和27归并成{13 27 76}</li>\n<li>④两两归并，{38 49 65 97}和{13 27 76}归并成{13 27 38 49 65 76 97}</li>\n</ul>\n</li>\n<li>时间复杂度：O(nlog2n)</li>\n<li>空间复杂度:因为需要将这个待排序序列转存到一个数组，所以需要额外开辟大小为n的存储空间，即空间复杂度为O(n)</li>\n<li>稳定性：稳定</li>\n</ul>\n<h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><ul>\n<li>基数排序(也叫桶排序)是一种很特别的排序方法，它不是基于比较进行排序的，而是采用多关键字排序思想（即基于关键字各位的大小进行排序的），借助“分配”和“收集”两种操作对单逻辑关键字进行排序。基数排序又分为最高位优先（MSD）排序和最低位优先（LSD）排序。</li>\n<li>例子：53, 3, 542, 748, 14, 214, 154, 63, 616<ul>\n<li>补充位数：053, 003, 542, 748, 014, 214, 154, 063, 616</li>\n<li>桶实际是一个队列，先进先出(从桶的上面进，下面出)</li>\n<li>关键字数量为n,关键字的位数为d,比如748 d&#x3D;3，r为关键字的基的个数，就是组成关键字的数据的种类，比如十进制数字一共有0至9一共10个数字，即r&#x3D;10</li>\n</ul>\n</li>\n<li>空间复杂度：需要开辟关键字基的个数个队列，所以空间复杂度为O(r)</li>\n<li>时间复杂度：需要进行关键字位数d次”分配”和”收集”，一次”分配”需要将n个关键字放进各个队列中，一次”收集”需要将r个桶都收集一遍。所以一次”分配”和一次”收集”时间复杂度为O(n+r)。d次就需要O(d(n+r))的时间复杂度。</li>\n<li>稳定性：由于是队列，先进先出的性质，所以在分配的时候是按照先后顺序分配，也就是稳定的，所以收集的时候也是保持稳定的。即基数排序是稳定的排序算法。</li>\n</ul>\n<h3 id=\"外部排序\"><a href=\"#外部排序\" class=\"headerlink\" title=\"外部排序\"></a>外部排序</h3><ul>\n<li>需要将待排序的记录存储在外存上，排序时再把数据一部分一部分的调入内存进行排序。在排序过程中需要多次进行内存和外存之间的交换，对外存文件中的记录进行排序后的结果仍然被放到原有文件中。这种排序的方法就叫做外部排序。</li>\n<li>如何得到初始的归并段<ul>\n<li>置换选择排序：解决排序段放入内存的问题</li>\n</ul>\n</li>\n<li>如何减少多个归并段的归并次数<ul>\n<li>最佳归并树：最少的归并次数（I&#x2F;O次数）</li>\n</ul>\n</li>\n<li>如何每次m路归并快速得到最小的关键字<ul>\n<li>败者树：减少比较次数</li>\n</ul>\n</li>\n<li>概要: 内存容量无法容纳大量数据</li>\n</ul>\n<h2 id=\"二叉树与树与森林\"><a href=\"#二叉树与树与森林\" class=\"headerlink\" title=\"二叉树与树与森林\"></a>二叉树与树与森林</h2><h3 id=\"树与二叉树\"><a href=\"#树与二叉树\" class=\"headerlink\" title=\"树与二叉树\"></a>树与二叉树</h3><ul>\n<li>如何将一棵树转化成二叉树？<ul>\n<li>树的孩子兄弟表示法与二叉树的二叉链表表示法都是用到两个指针<ul>\n<li>将孩子兄弟表示法理解成二叉链表</li>\n</ul>\n</li>\n<li>树转换成二叉树的手动模拟方法：<ul>\n<li>①将同一结点的各个孩子用线串连起来</li>\n<li>②将每个结点的子树分支，从左往右，除了第一个以外全部删除</li>\n<li>概要: 例子</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>如何将一棵二叉树转化成树？<ul>\n<li>二叉树转换成树的手动模拟方法：<ul>\n<li>①将二叉树从上到下分层，并调节成水平方向。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>(分层方法：每遇到左孩子则为一层)<br>        * ②找到每一层的双亲结点，方法为它的上一层相连的那个结点就是双亲结点。<br>例如bcd这一层，与它相连的上一层结点即为a,所以bcd这三个结点的双亲结点都是a.<br>        * ③将每一层结点和其双亲结点相连，同时删除该双亲结点各个孩子结点之间的联系。<br>        * 概要: 例子</p>\n<h3 id=\"森林与二叉树\"><a href=\"#森林与二叉树\" class=\"headerlink\" title=\"森林与二叉树\"></a>森林与二叉树</h3><ul>\n<li>森林：森林是m（m≥0）棵互不相交的树的集合</li>\n<li>如何将森林转换成二叉树？<ul>\n<li>森林转换成树的手动模拟方法：<ul>\n<li>①将森林中每棵树都转换成二叉树</li>\n<li>②将第二棵树作为第一棵树的根结点的右子树，将第三棵树作为第二棵树的根结点的右子树..依次类推</li>\n<li>概要: 例子</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>如何将二叉树转换成森林？<ul>\n<li>二叉树转换成森林的手动模拟方法：<ul>\n<li>反复断开二叉树根结点的右孩子的右子树指针，直到不存在根结点有右孩子的二叉树为止。</li>\n<li>概要: 例子</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"树与森林的遍历\"><a href=\"#树与森林的遍历\" class=\"headerlink\" title=\"树与森林的遍历\"></a>树与森林的遍历</h3><ul>\n<li>先序：先访问根结点，再访问根结点的每棵子树。           访问子树也是按照先序的要求</li>\n<li>后序：先访问根结点的每棵子树，再访问根结点。           访问子树也是按照先序的要求</li>\n<li>树的先序遍历等于它对应二叉树的先序遍历，后序遍历等于它对应的二叉树的中序遍历</li>\n<li>概要: 例子</li>\n</ul>\n"},{"_content":"## 一键开启\n### Chrome 浏览器，地址栏输入并回车：chrome://flags/#enable-parallel-downloading\n### Edge 新版浏览器，地址栏输入并回车：edge://flags/#enable-parallel-downloading\n\n### 将 `Parallel downloading` 默认的Default 改为 Enabled 即可！\n### 重启浏览器\n","source":"_posts/2023-06-20-Chrome、Edge浏览器开启多线程下载.md","raw":"## 一键开启\n### Chrome 浏览器，地址栏输入并回车：chrome://flags/#enable-parallel-downloading\n### Edge 新版浏览器，地址栏输入并回车：edge://flags/#enable-parallel-downloading\n\n### 将 `Parallel downloading` 默认的Default 改为 Enabled 即可！\n### 重启浏览器\n","slug":"2023-06-20-Chrome、Edge浏览器开启多线程下载","published":1,"date":"2023-12-15T02:31:42.319Z","updated":"2023-12-15T02:31:42.327Z","_id":"clq60joyq000d4zgs7r7rdglg","title":"","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"一键开启\"><a href=\"#一键开启\" class=\"headerlink\" title=\"一键开启\"></a>一键开启</h2><h3 id=\"Chrome-浏览器，地址栏输入并回车：chrome-flags-enable-parallel-downloading\"><a href=\"#Chrome-浏览器，地址栏输入并回车：chrome-flags-enable-parallel-downloading\" class=\"headerlink\" title=\"Chrome 浏览器，地址栏输入并回车：chrome:&#x2F;&#x2F;flags&#x2F;#enable-parallel-downloading\"></a>Chrome 浏览器，地址栏输入并回车：chrome:&#x2F;&#x2F;flags&#x2F;#enable-parallel-downloading</h3><h3 id=\"Edge-新版浏览器，地址栏输入并回车：edge-flags-enable-parallel-downloading\"><a href=\"#Edge-新版浏览器，地址栏输入并回车：edge-flags-enable-parallel-downloading\" class=\"headerlink\" title=\"Edge 新版浏览器，地址栏输入并回车：edge:&#x2F;&#x2F;flags&#x2F;#enable-parallel-downloading\"></a>Edge 新版浏览器，地址栏输入并回车：edge:&#x2F;&#x2F;flags&#x2F;#enable-parallel-downloading</h3><h3 id=\"将-Parallel-downloading-默认的Default-改为-Enabled-即可！\"><a href=\"#将-Parallel-downloading-默认的Default-改为-Enabled-即可！\" class=\"headerlink\" title=\"将 Parallel downloading 默认的Default 改为 Enabled 即可！\"></a>将 <code>Parallel downloading</code> 默认的Default 改为 Enabled 即可！</h3><h3 id=\"重启浏览器\"><a href=\"#重启浏览器\" class=\"headerlink\" title=\"重启浏览器\"></a>重启浏览器</h3>","excerpt":"","more":"<h2 id=\"一键开启\"><a href=\"#一键开启\" class=\"headerlink\" title=\"一键开启\"></a>一键开启</h2><h3 id=\"Chrome-浏览器，地址栏输入并回车：chrome-flags-enable-parallel-downloading\"><a href=\"#Chrome-浏览器，地址栏输入并回车：chrome-flags-enable-parallel-downloading\" class=\"headerlink\" title=\"Chrome 浏览器，地址栏输入并回车：chrome:&#x2F;&#x2F;flags&#x2F;#enable-parallel-downloading\"></a>Chrome 浏览器，地址栏输入并回车：chrome:&#x2F;&#x2F;flags&#x2F;#enable-parallel-downloading</h3><h3 id=\"Edge-新版浏览器，地址栏输入并回车：edge-flags-enable-parallel-downloading\"><a href=\"#Edge-新版浏览器，地址栏输入并回车：edge-flags-enable-parallel-downloading\" class=\"headerlink\" title=\"Edge 新版浏览器，地址栏输入并回车：edge:&#x2F;&#x2F;flags&#x2F;#enable-parallel-downloading\"></a>Edge 新版浏览器，地址栏输入并回车：edge:&#x2F;&#x2F;flags&#x2F;#enable-parallel-downloading</h3><h3 id=\"将-Parallel-downloading-默认的Default-改为-Enabled-即可！\"><a href=\"#将-Parallel-downloading-默认的Default-改为-Enabled-即可！\" class=\"headerlink\" title=\"将 Parallel downloading 默认的Default 改为 Enabled 即可！\"></a>将 <code>Parallel downloading</code> 默认的Default 改为 Enabled 即可！</h3><h3 id=\"重启浏览器\"><a href=\"#重启浏览器\" class=\"headerlink\" title=\"重启浏览器\"></a>重启浏览器</h3>"},{"_content":"## 已安装IDM请先执行完全卸载清除\n\n## 官网下载最新版本IDM并安装完成  \n- [IDM官网下载地址](https://www.internetdownloadmanager.com/download.html)  \n- [Chrome 扩展下载地址](https://chrome.google.com/webstore/detail/idm-integration-module/ngpampappnmepgilojfohadhhmbhlaek)\n\n## 打开powershell命令端，粘贴以下代码\n```\niwr -useb https://raw.githubusercontent.com/lstprjct/IDM-Activation-Script/main/IAS.ps1 | iex\n```\n\n## 根据提示命令，输入相应的操作序号，激活选择数字：1\n\n## 根据弹出窗口，输入name，可随便写入  回车\n\n## 等待完成激活\n\n## 稍等片刻， 激活完成。\n","source":"_posts/2023-08-10-IDM Activate 激活.md","raw":"## 已安装IDM请先执行完全卸载清除\n\n## 官网下载最新版本IDM并安装完成  \n- [IDM官网下载地址](https://www.internetdownloadmanager.com/download.html)  \n- [Chrome 扩展下载地址](https://chrome.google.com/webstore/detail/idm-integration-module/ngpampappnmepgilojfohadhhmbhlaek)\n\n## 打开powershell命令端，粘贴以下代码\n```\niwr -useb https://raw.githubusercontent.com/lstprjct/IDM-Activation-Script/main/IAS.ps1 | iex\n```\n\n## 根据提示命令，输入相应的操作序号，激活选择数字：1\n\n## 根据弹出窗口，输入name，可随便写入  回车\n\n## 等待完成激活\n\n## 稍等片刻， 激活完成。\n","slug":"2023-08-10-IDM Activate 激活","published":1,"date":"2023-12-15T02:31:42.631Z","updated":"2023-12-15T02:31:42.639Z","_id":"clq60jp78000e4zgsfb936tkt","title":"","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"已安装IDM请先执行完全卸载清除\"><a href=\"#已安装IDM请先执行完全卸载清除\" class=\"headerlink\" title=\"已安装IDM请先执行完全卸载清除\"></a>已安装IDM请先执行完全卸载清除</h2><h2 id=\"官网下载最新版本IDM并安装完成\"><a href=\"#官网下载最新版本IDM并安装完成\" class=\"headerlink\" title=\"官网下载最新版本IDM并安装完成\"></a>官网下载最新版本IDM并安装完成</h2><ul>\n<li><a href=\"https://www.internetdownloadmanager.com/download.html\">IDM官网下载地址</a>  </li>\n<li><a href=\"https://chrome.google.com/webstore/detail/idm-integration-module/ngpampappnmepgilojfohadhhmbhlaek\">Chrome 扩展下载地址</a></li>\n</ul>\n<h2 id=\"打开powershell命令端，粘贴以下代码\"><a href=\"#打开powershell命令端，粘贴以下代码\" class=\"headerlink\" title=\"打开powershell命令端，粘贴以下代码\"></a>打开powershell命令端，粘贴以下代码</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iwr -useb https://raw.githubusercontent.com/lstprjct/IDM-Activation-Script/main/IAS.ps1 | iex</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"根据提示命令，输入相应的操作序号，激活选择数字：1\"><a href=\"#根据提示命令，输入相应的操作序号，激活选择数字：1\" class=\"headerlink\" title=\"根据提示命令，输入相应的操作序号，激活选择数字：1\"></a>根据提示命令，输入相应的操作序号，激活选择数字：1</h2><h2 id=\"根据弹出窗口，输入name，可随便写入-回车\"><a href=\"#根据弹出窗口，输入name，可随便写入-回车\" class=\"headerlink\" title=\"根据弹出窗口，输入name，可随便写入  回车\"></a>根据弹出窗口，输入name，可随便写入  回车</h2><h2 id=\"等待完成激活\"><a href=\"#等待完成激活\" class=\"headerlink\" title=\"等待完成激活\"></a>等待完成激活</h2><h2 id=\"稍等片刻，-激活完成。\"><a href=\"#稍等片刻，-激活完成。\" class=\"headerlink\" title=\"稍等片刻， 激活完成。\"></a>稍等片刻， 激活完成。</h2>","excerpt":"","more":"<h2 id=\"已安装IDM请先执行完全卸载清除\"><a href=\"#已安装IDM请先执行完全卸载清除\" class=\"headerlink\" title=\"已安装IDM请先执行完全卸载清除\"></a>已安装IDM请先执行完全卸载清除</h2><h2 id=\"官网下载最新版本IDM并安装完成\"><a href=\"#官网下载最新版本IDM并安装完成\" class=\"headerlink\" title=\"官网下载最新版本IDM并安装完成\"></a>官网下载最新版本IDM并安装完成</h2><ul>\n<li><a href=\"https://www.internetdownloadmanager.com/download.html\">IDM官网下载地址</a>  </li>\n<li><a href=\"https://chrome.google.com/webstore/detail/idm-integration-module/ngpampappnmepgilojfohadhhmbhlaek\">Chrome 扩展下载地址</a></li>\n</ul>\n<h2 id=\"打开powershell命令端，粘贴以下代码\"><a href=\"#打开powershell命令端，粘贴以下代码\" class=\"headerlink\" title=\"打开powershell命令端，粘贴以下代码\"></a>打开powershell命令端，粘贴以下代码</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iwr -useb https://raw.githubusercontent.com/lstprjct/IDM-Activation-Script/main/IAS.ps1 | iex</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"根据提示命令，输入相应的操作序号，激活选择数字：1\"><a href=\"#根据提示命令，输入相应的操作序号，激活选择数字：1\" class=\"headerlink\" title=\"根据提示命令，输入相应的操作序号，激活选择数字：1\"></a>根据提示命令，输入相应的操作序号，激活选择数字：1</h2><h2 id=\"根据弹出窗口，输入name，可随便写入-回车\"><a href=\"#根据弹出窗口，输入name，可随便写入-回车\" class=\"headerlink\" title=\"根据弹出窗口，输入name，可随便写入  回车\"></a>根据弹出窗口，输入name，可随便写入  回车</h2><h2 id=\"等待完成激活\"><a href=\"#等待完成激活\" class=\"headerlink\" title=\"等待完成激活\"></a>等待完成激活</h2><h2 id=\"稍等片刻，-激活完成。\"><a href=\"#稍等片刻，-激活完成。\" class=\"headerlink\" title=\"稍等片刻， 激活完成。\"></a>稍等片刻， 激活完成。</h2>"},{"_content":"## 清理残留\n```\nsudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n```\n\n# 一、yum 安装\n\n## Install using the rpm repository\n```\nsudo yum install -y yum-utils\n\nsudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n```\n\n## Install Docker Engine\n```\nsudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n```\n\n## Start Docker\n```\nsudo systemctl start docker\n```\n\n# 二、rpm 安装\n\n## 下载安装包 [安装地址](https://download.docker.com/linux/centos/)\n\n## 安装\n```\nsudo yum install /path/to/package.rpm\n```\n\n## 启动\n```\nsudo systemctl start docker\n```\n","source":"_posts/2023-08-25-Centos安装Docker.md","raw":"## 清理残留\n```\nsudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n```\n\n# 一、yum 安装\n\n## Install using the rpm repository\n```\nsudo yum install -y yum-utils\n\nsudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n```\n\n## Install Docker Engine\n```\nsudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n```\n\n## Start Docker\n```\nsudo systemctl start docker\n```\n\n# 二、rpm 安装\n\n## 下载安装包 [安装地址](https://download.docker.com/linux/centos/)\n\n## 安装\n```\nsudo yum install /path/to/package.rpm\n```\n\n## 启动\n```\nsudo systemctl start docker\n```\n","slug":"2023-08-25-Centos安装Docker","published":1,"date":"2023-12-15T02:31:42.655Z","updated":"2023-12-15T02:31:42.663Z","_id":"clq60jp78000f4zgs2e0he1vo","title":"","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"清理残留\"><a href=\"#清理残留\" class=\"headerlink\" title=\"清理残留\"></a>清理残留</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum remove docker \\</span><br><span class=\"line\">                  docker-client \\</span><br><span class=\"line\">                  docker-client-latest \\</span><br><span class=\"line\">                  docker-common \\</span><br><span class=\"line\">                  docker-latest \\</span><br><span class=\"line\">                  docker-latest-logrotate \\</span><br><span class=\"line\">                  docker-logrotate \\</span><br><span class=\"line\">                  docker-engine</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"一、yum-安装\"><a href=\"#一、yum-安装\" class=\"headerlink\" title=\"一、yum 安装\"></a>一、yum 安装</h1><h2 id=\"Install-using-the-rpm-repository\"><a href=\"#Install-using-the-rpm-repository\" class=\"headerlink\" title=\"Install using the rpm repository\"></a>Install using the rpm repository</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y yum-utils</span><br><span class=\"line\"></span><br><span class=\"line\">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Install-Docker-Engine\"><a href=\"#Install-Docker-Engine\" class=\"headerlink\" title=\"Install Docker Engine\"></a>Install Docker Engine</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Start-Docker\"><a href=\"#Start-Docker\" class=\"headerlink\" title=\"Start Docker\"></a>Start Docker</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl start docker</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、rpm-安装\"><a href=\"#二、rpm-安装\" class=\"headerlink\" title=\"二、rpm 安装\"></a>二、rpm 安装</h1><h2 id=\"下载安装包-安装地址\"><a href=\"#下载安装包-安装地址\" class=\"headerlink\" title=\"下载安装包 安装地址\"></a>下载安装包 <a href=\"https://download.docker.com/linux/centos/\">安装地址</a></h2><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install /path/to/package.rpm</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl start docker</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"清理残留\"><a href=\"#清理残留\" class=\"headerlink\" title=\"清理残留\"></a>清理残留</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum remove docker \\</span><br><span class=\"line\">                  docker-client \\</span><br><span class=\"line\">                  docker-client-latest \\</span><br><span class=\"line\">                  docker-common \\</span><br><span class=\"line\">                  docker-latest \\</span><br><span class=\"line\">                  docker-latest-logrotate \\</span><br><span class=\"line\">                  docker-logrotate \\</span><br><span class=\"line\">                  docker-engine</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"一、yum-安装\"><a href=\"#一、yum-安装\" class=\"headerlink\" title=\"一、yum 安装\"></a>一、yum 安装</h1><h2 id=\"Install-using-the-rpm-repository\"><a href=\"#Install-using-the-rpm-repository\" class=\"headerlink\" title=\"Install using the rpm repository\"></a>Install using the rpm repository</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install -y yum-utils</span><br><span class=\"line\"></span><br><span class=\"line\">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Install-Docker-Engine\"><a href=\"#Install-Docker-Engine\" class=\"headerlink\" title=\"Install Docker Engine\"></a>Install Docker Engine</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Start-Docker\"><a href=\"#Start-Docker\" class=\"headerlink\" title=\"Start Docker\"></a>Start Docker</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl start docker</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、rpm-安装\"><a href=\"#二、rpm-安装\" class=\"headerlink\" title=\"二、rpm 安装\"></a>二、rpm 安装</h1><h2 id=\"下载安装包-安装地址\"><a href=\"#下载安装包-安装地址\" class=\"headerlink\" title=\"下载安装包 安装地址\"></a>下载安装包 <a href=\"https://download.docker.com/linux/centos/\">安装地址</a></h2><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install /path/to/package.rpm</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl start docker</span><br></pre></td></tr></table></figure>\n"},{"_content":"## 第一种方式\n- 1、访问https://hexed.it/\n- 2、点击左上角的打开文件，选择/opt/sublime_text/sublime_text\n- 3、 按 `CTRL + F` 或左侧面板中的搜索栏并查找：80 78 05 00 0f 94 C1\n- 4、现在在编辑器中，单击第一个字节 (80) 并开始将每个字节替换为：C6 40 05 01 48 85 C9\n- 5、最后，再次在左上角单击“导出”按钮。这会将文件下载到您的下载文件夹中。\n- 6、执行 sudo cp ~/Downloads/sublime_text /opt/sublime_text/sublime_text 替换原文件。\n\n\n## 第二种方式\n- 1、选择二进制工具打开sublime text可执行文件\n- 2、通过单击 Ctrl F 搜索：41 57 41 56 56 57 55 53 B8 28 21 00 00 并将其替换为：33 C0 FE C0 C3 57 55 53 B8 28 21 00 00（RSA 密钥补丁）\n- 3、搜索：6C6963656E73652E7375626C696D6568712E636F6D 并将其替换为：7375626C696D6568712E6C6F63616C686F73740000 （禁用许可证检查）\n- 4、导出修改后的文件并将其另存为桌面上的 sublime_text.exe 重命名原始文件\n- 5、打开新导出文件，然后单击“输入许可证”\n- 6、```—– BEGIN LICENSE —– Zer0Daylab Unlimited User License EA7E-81044230 0C0CD4A8 CAA317D9 CCABD1AC 434C984C 7E4A0B13 77893C3E DD0A5BA1 B2EB721C 4BAAB4C4 9B96437D 14EB743E 7DB55D9C 7CA26EE2 67C3B4EC 29B2C65A 88D90C59 CB6CCBA5 7DE6177B C02C2826 8C9A21B0 6AB1A5B6 20B09EA2 01C979BD 29670B19 92DC6D90 6E365849 4AB84739 5B4C3EA1 048CC1D0 9748ED54 CAC9D585 90CAD815 —— END LICENSE ——```\n- 7、完成！\n","source":"_posts/2023-07-17-sublime text 破解.md","raw":"## 第一种方式\n- 1、访问https://hexed.it/\n- 2、点击左上角的打开文件，选择/opt/sublime_text/sublime_text\n- 3、 按 `CTRL + F` 或左侧面板中的搜索栏并查找：80 78 05 00 0f 94 C1\n- 4、现在在编辑器中，单击第一个字节 (80) 并开始将每个字节替换为：C6 40 05 01 48 85 C9\n- 5、最后，再次在左上角单击“导出”按钮。这会将文件下载到您的下载文件夹中。\n- 6、执行 sudo cp ~/Downloads/sublime_text /opt/sublime_text/sublime_text 替换原文件。\n\n\n## 第二种方式\n- 1、选择二进制工具打开sublime text可执行文件\n- 2、通过单击 Ctrl F 搜索：41 57 41 56 56 57 55 53 B8 28 21 00 00 并将其替换为：33 C0 FE C0 C3 57 55 53 B8 28 21 00 00（RSA 密钥补丁）\n- 3、搜索：6C6963656E73652E7375626C696D6568712E636F6D 并将其替换为：7375626C696D6568712E6C6F63616C686F73740000 （禁用许可证检查）\n- 4、导出修改后的文件并将其另存为桌面上的 sublime_text.exe 重命名原始文件\n- 5、打开新导出文件，然后单击“输入许可证”\n- 6、```—– BEGIN LICENSE —– Zer0Daylab Unlimited User License EA7E-81044230 0C0CD4A8 CAA317D9 CCABD1AC 434C984C 7E4A0B13 77893C3E DD0A5BA1 B2EB721C 4BAAB4C4 9B96437D 14EB743E 7DB55D9C 7CA26EE2 67C3B4EC 29B2C65A 88D90C59 CB6CCBA5 7DE6177B C02C2826 8C9A21B0 6AB1A5B6 20B09EA2 01C979BD 29670B19 92DC6D90 6E365849 4AB84739 5B4C3EA1 048CC1D0 9748ED54 CAC9D585 90CAD815 —— END LICENSE ——```\n- 7、完成！\n","slug":"2023-07-17-sublime text 破解","published":1,"date":"2023-12-15T02:31:42.571Z","updated":"2023-12-15T02:31:42.579Z","_id":"clq60jp79000g4zgs4mq09zov","title":"","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"第一种方式\"><a href=\"#第一种方式\" class=\"headerlink\" title=\"第一种方式\"></a>第一种方式</h2><ul>\n<li>1、访问<a href=\"https://hexed.it/\">https://hexed.it/</a></li>\n<li>2、点击左上角的打开文件，选择&#x2F;opt&#x2F;sublime_text&#x2F;sublime_text</li>\n<li>3、 按 <code>CTRL + F</code> 或左侧面板中的搜索栏并查找：80 78 05 00 0f 94 C1</li>\n<li>4、现在在编辑器中，单击第一个字节 (80) 并开始将每个字节替换为：C6 40 05 01 48 85 C9</li>\n<li>5、最后，再次在左上角单击“导出”按钮。这会将文件下载到您的下载文件夹中。</li>\n<li>6、执行 sudo cp ~&#x2F;Downloads&#x2F;sublime_text &#x2F;opt&#x2F;sublime_text&#x2F;sublime_text 替换原文件。</li>\n</ul>\n<h2 id=\"第二种方式\"><a href=\"#第二种方式\" class=\"headerlink\" title=\"第二种方式\"></a>第二种方式</h2><ul>\n<li>1、选择二进制工具打开sublime text可执行文件</li>\n<li>2、通过单击 Ctrl F 搜索：41 57 41 56 56 57 55 53 B8 28 21 00 00 并将其替换为：33 C0 FE C0 C3 57 55 53 B8 28 21 00 00（RSA 密钥补丁）</li>\n<li>3、搜索：6C6963656E73652E7375626C696D6568712E636F6D 并将其替换为：7375626C696D6568712E6C6F63616C686F73740000 （禁用许可证检查）</li>\n<li>4、导出修改后的文件并将其另存为桌面上的 sublime_text.exe 重命名原始文件</li>\n<li>5、打开新导出文件，然后单击“输入许可证”</li>\n<li>6、<code>—– BEGIN LICENSE —– Zer0Daylab Unlimited User License EA7E-81044230 0C0CD4A8 CAA317D9 CCABD1AC 434C984C 7E4A0B13 77893C3E DD0A5BA1 B2EB721C 4BAAB4C4 9B96437D 14EB743E 7DB55D9C 7CA26EE2 67C3B4EC 29B2C65A 88D90C59 CB6CCBA5 7DE6177B C02C2826 8C9A21B0 6AB1A5B6 20B09EA2 01C979BD 29670B19 92DC6D90 6E365849 4AB84739 5B4C3EA1 048CC1D0 9748ED54 CAC9D585 90CAD815 —— END LICENSE ——</code></li>\n<li>7、完成！</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"第一种方式\"><a href=\"#第一种方式\" class=\"headerlink\" title=\"第一种方式\"></a>第一种方式</h2><ul>\n<li>1、访问<a href=\"https://hexed.it/\">https://hexed.it/</a></li>\n<li>2、点击左上角的打开文件，选择&#x2F;opt&#x2F;sublime_text&#x2F;sublime_text</li>\n<li>3、 按 <code>CTRL + F</code> 或左侧面板中的搜索栏并查找：80 78 05 00 0f 94 C1</li>\n<li>4、现在在编辑器中，单击第一个字节 (80) 并开始将每个字节替换为：C6 40 05 01 48 85 C9</li>\n<li>5、最后，再次在左上角单击“导出”按钮。这会将文件下载到您的下载文件夹中。</li>\n<li>6、执行 sudo cp ~&#x2F;Downloads&#x2F;sublime_text &#x2F;opt&#x2F;sublime_text&#x2F;sublime_text 替换原文件。</li>\n</ul>\n<h2 id=\"第二种方式\"><a href=\"#第二种方式\" class=\"headerlink\" title=\"第二种方式\"></a>第二种方式</h2><ul>\n<li>1、选择二进制工具打开sublime text可执行文件</li>\n<li>2、通过单击 Ctrl F 搜索：41 57 41 56 56 57 55 53 B8 28 21 00 00 并将其替换为：33 C0 FE C0 C3 57 55 53 B8 28 21 00 00（RSA 密钥补丁）</li>\n<li>3、搜索：6C6963656E73652E7375626C696D6568712E636F6D 并将其替换为：7375626C696D6568712E6C6F63616C686F73740000 （禁用许可证检查）</li>\n<li>4、导出修改后的文件并将其另存为桌面上的 sublime_text.exe 重命名原始文件</li>\n<li>5、打开新导出文件，然后单击“输入许可证”</li>\n<li>6、<code>—– BEGIN LICENSE —– Zer0Daylab Unlimited User License EA7E-81044230 0C0CD4A8 CAA317D9 CCABD1AC 434C984C 7E4A0B13 77893C3E DD0A5BA1 B2EB721C 4BAAB4C4 9B96437D 14EB743E 7DB55D9C 7CA26EE2 67C3B4EC 29B2C65A 88D90C59 CB6CCBA5 7DE6177B C02C2826 8C9A21B0 6AB1A5B6 20B09EA2 01C979BD 29670B19 92DC6D90 6E365849 4AB84739 5B4C3EA1 048CC1D0 9748ED54 CAC9D585 90CAD815 —— END LICENSE ——</code></li>\n<li>7、完成！</li>\n</ul>\n"},{"_content":"## UBUNTU:\n\n```\n# os update\napt-get update\n\n# install depends\napt-get install -y --no-install-recommends \\\n  build-essential \\\n  curl \\\n  libffi-dev \\\n  libssl-dev \\\n  zlib1g-dev \\\n  liblzma-dev \\\n  libbz2-dev \\\n  libreadline-dev \\\n  libsqlite3-dev\n\n# download python package\nwget https://www.python.org/ftp/python/3.10.0/Python-3.10.0.tgz \\\n    && tar -xvf Python-3.10.0.tgz \\\n    && cd Python-3.10.0 \\\n    && ./configure --enable-optimizations \\\n    && make altinstall\n\n# install pip package manager\ncurl https://bootstrap.pypa.io/get-pip.py -o get-pip.py \\\n    && python3.10 get-pip.py\n\n# create env\npython3.10 -m venv /py && \\\n  /py/bin/pip install --upgrade pip && \\\n  /py/bin/pip install --no-cache-dir -r /tmp/requirements.txt && \\\n  rm /tmp/requirements.txt\n```\n\n## Docker:\n```\nFROM ubuntu:latest\nCOPY ./requirements.txt /tmp/requirements.txt\nCOPY ./app /app\nCOPY ./scripts /scripts\n\nRUN apt-get update \\\n    && apt-get install -y --no-install-recommends \\\n        build-essential \\\n        curl \\\n        libffi-dev \\\n        libssl-dev \\\n        zlib1g-dev \\\n        liblzma-dev \\\n        libbz2-dev \\\n        libreadline-dev \\\n        libsqlite3-dev\n\nRUN wget https://www.python.org/ftp/python/3.10.0/Python-3.10.0.tgz \\\n    && tar -xvf Python-3.10.0.tgz \\\n    && cd Python-3.10.0 \\\n    && ./configure --enable-optimizations \\\n    && make altinstall\n\nRUN curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py \\\n    && python3.10 get-pip.py\n\nRUN python3.10 -m venv /py && \\\n  /py/bin/pip install --upgrade pip && \\\n  /py/bin/pip install --no-cache-dir -r /tmp/requirements.txt && \\\n  rm /tmp/requirements.txt\n```\n","source":"_posts/2023-08-07-ubuntu install python3.10.md","raw":"## UBUNTU:\n\n```\n# os update\napt-get update\n\n# install depends\napt-get install -y --no-install-recommends \\\n  build-essential \\\n  curl \\\n  libffi-dev \\\n  libssl-dev \\\n  zlib1g-dev \\\n  liblzma-dev \\\n  libbz2-dev \\\n  libreadline-dev \\\n  libsqlite3-dev\n\n# download python package\nwget https://www.python.org/ftp/python/3.10.0/Python-3.10.0.tgz \\\n    && tar -xvf Python-3.10.0.tgz \\\n    && cd Python-3.10.0 \\\n    && ./configure --enable-optimizations \\\n    && make altinstall\n\n# install pip package manager\ncurl https://bootstrap.pypa.io/get-pip.py -o get-pip.py \\\n    && python3.10 get-pip.py\n\n# create env\npython3.10 -m venv /py && \\\n  /py/bin/pip install --upgrade pip && \\\n  /py/bin/pip install --no-cache-dir -r /tmp/requirements.txt && \\\n  rm /tmp/requirements.txt\n```\n\n## Docker:\n```\nFROM ubuntu:latest\nCOPY ./requirements.txt /tmp/requirements.txt\nCOPY ./app /app\nCOPY ./scripts /scripts\n\nRUN apt-get update \\\n    && apt-get install -y --no-install-recommends \\\n        build-essential \\\n        curl \\\n        libffi-dev \\\n        libssl-dev \\\n        zlib1g-dev \\\n        liblzma-dev \\\n        libbz2-dev \\\n        libreadline-dev \\\n        libsqlite3-dev\n\nRUN wget https://www.python.org/ftp/python/3.10.0/Python-3.10.0.tgz \\\n    && tar -xvf Python-3.10.0.tgz \\\n    && cd Python-3.10.0 \\\n    && ./configure --enable-optimizations \\\n    && make altinstall\n\nRUN curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py \\\n    && python3.10 get-pip.py\n\nRUN python3.10 -m venv /py && \\\n  /py/bin/pip install --upgrade pip && \\\n  /py/bin/pip install --no-cache-dir -r /tmp/requirements.txt && \\\n  rm /tmp/requirements.txt\n```\n","slug":"2023-08-07-ubuntu install python3.10","published":1,"date":"2023-12-15T02:31:42.599Z","updated":"2023-12-15T02:31:42.611Z","_id":"clq60jp7a000h4zgsdppl1tyv","title":"","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"UBUNTU\"><a href=\"#UBUNTU\" class=\"headerlink\" title=\"UBUNTU:\"></a>UBUNTU:</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># os update</span><br><span class=\"line\">apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\"># install depends</span><br><span class=\"line\">apt-get install -y --no-install-recommends \\</span><br><span class=\"line\">  build-essential \\</span><br><span class=\"line\">  curl \\</span><br><span class=\"line\">  libffi-dev \\</span><br><span class=\"line\">  libssl-dev \\</span><br><span class=\"line\">  zlib1g-dev \\</span><br><span class=\"line\">  liblzma-dev \\</span><br><span class=\"line\">  libbz2-dev \\</span><br><span class=\"line\">  libreadline-dev \\</span><br><span class=\"line\">  libsqlite3-dev</span><br><span class=\"line\"></span><br><span class=\"line\"># download python package</span><br><span class=\"line\">wget https://www.python.org/ftp/python/3.10.0/Python-3.10.0.tgz \\</span><br><span class=\"line\">    &amp;&amp; tar -xvf Python-3.10.0.tgz \\</span><br><span class=\"line\">    &amp;&amp; cd Python-3.10.0 \\</span><br><span class=\"line\">    &amp;&amp; ./configure --enable-optimizations \\</span><br><span class=\"line\">    &amp;&amp; make altinstall</span><br><span class=\"line\"></span><br><span class=\"line\"># install pip package manager</span><br><span class=\"line\">curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py \\</span><br><span class=\"line\">    &amp;&amp; python3.10 get-pip.py</span><br><span class=\"line\"></span><br><span class=\"line\"># create env</span><br><span class=\"line\">python3.10 -m venv /py &amp;&amp; \\</span><br><span class=\"line\">  /py/bin/pip install --upgrade pip &amp;&amp; \\</span><br><span class=\"line\">  /py/bin/pip install --no-cache-dir -r /tmp/requirements.txt &amp;&amp; \\</span><br><span class=\"line\">  rm /tmp/requirements.txt</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker:\"></a>Docker:</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM ubuntu:latest</span><br><span class=\"line\">COPY ./requirements.txt /tmp/requirements.txt</span><br><span class=\"line\">COPY ./app /app</span><br><span class=\"line\">COPY ./scripts /scripts</span><br><span class=\"line\"></span><br><span class=\"line\">RUN apt-get update \\</span><br><span class=\"line\">    &amp;&amp; apt-get install -y --no-install-recommends \\</span><br><span class=\"line\">        build-essential \\</span><br><span class=\"line\">        curl \\</span><br><span class=\"line\">        libffi-dev \\</span><br><span class=\"line\">        libssl-dev \\</span><br><span class=\"line\">        zlib1g-dev \\</span><br><span class=\"line\">        liblzma-dev \\</span><br><span class=\"line\">        libbz2-dev \\</span><br><span class=\"line\">        libreadline-dev \\</span><br><span class=\"line\">        libsqlite3-dev</span><br><span class=\"line\"></span><br><span class=\"line\">RUN wget https://www.python.org/ftp/python/3.10.0/Python-3.10.0.tgz \\</span><br><span class=\"line\">    &amp;&amp; tar -xvf Python-3.10.0.tgz \\</span><br><span class=\"line\">    &amp;&amp; cd Python-3.10.0 \\</span><br><span class=\"line\">    &amp;&amp; ./configure --enable-optimizations \\</span><br><span class=\"line\">    &amp;&amp; make altinstall</span><br><span class=\"line\"></span><br><span class=\"line\">RUN curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py \\</span><br><span class=\"line\">    &amp;&amp; python3.10 get-pip.py</span><br><span class=\"line\"></span><br><span class=\"line\">RUN python3.10 -m venv /py &amp;&amp; \\</span><br><span class=\"line\">  /py/bin/pip install --upgrade pip &amp;&amp; \\</span><br><span class=\"line\">  /py/bin/pip install --no-cache-dir -r /tmp/requirements.txt &amp;&amp; \\</span><br><span class=\"line\">  rm /tmp/requirements.txt</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"UBUNTU\"><a href=\"#UBUNTU\" class=\"headerlink\" title=\"UBUNTU:\"></a>UBUNTU:</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># os update</span><br><span class=\"line\">apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\"># install depends</span><br><span class=\"line\">apt-get install -y --no-install-recommends \\</span><br><span class=\"line\">  build-essential \\</span><br><span class=\"line\">  curl \\</span><br><span class=\"line\">  libffi-dev \\</span><br><span class=\"line\">  libssl-dev \\</span><br><span class=\"line\">  zlib1g-dev \\</span><br><span class=\"line\">  liblzma-dev \\</span><br><span class=\"line\">  libbz2-dev \\</span><br><span class=\"line\">  libreadline-dev \\</span><br><span class=\"line\">  libsqlite3-dev</span><br><span class=\"line\"></span><br><span class=\"line\"># download python package</span><br><span class=\"line\">wget https://www.python.org/ftp/python/3.10.0/Python-3.10.0.tgz \\</span><br><span class=\"line\">    &amp;&amp; tar -xvf Python-3.10.0.tgz \\</span><br><span class=\"line\">    &amp;&amp; cd Python-3.10.0 \\</span><br><span class=\"line\">    &amp;&amp; ./configure --enable-optimizations \\</span><br><span class=\"line\">    &amp;&amp; make altinstall</span><br><span class=\"line\"></span><br><span class=\"line\"># install pip package manager</span><br><span class=\"line\">curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py \\</span><br><span class=\"line\">    &amp;&amp; python3.10 get-pip.py</span><br><span class=\"line\"></span><br><span class=\"line\"># create env</span><br><span class=\"line\">python3.10 -m venv /py &amp;&amp; \\</span><br><span class=\"line\">  /py/bin/pip install --upgrade pip &amp;&amp; \\</span><br><span class=\"line\">  /py/bin/pip install --no-cache-dir -r /tmp/requirements.txt &amp;&amp; \\</span><br><span class=\"line\">  rm /tmp/requirements.txt</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker:\"></a>Docker:</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM ubuntu:latest</span><br><span class=\"line\">COPY ./requirements.txt /tmp/requirements.txt</span><br><span class=\"line\">COPY ./app /app</span><br><span class=\"line\">COPY ./scripts /scripts</span><br><span class=\"line\"></span><br><span class=\"line\">RUN apt-get update \\</span><br><span class=\"line\">    &amp;&amp; apt-get install -y --no-install-recommends \\</span><br><span class=\"line\">        build-essential \\</span><br><span class=\"line\">        curl \\</span><br><span class=\"line\">        libffi-dev \\</span><br><span class=\"line\">        libssl-dev \\</span><br><span class=\"line\">        zlib1g-dev \\</span><br><span class=\"line\">        liblzma-dev \\</span><br><span class=\"line\">        libbz2-dev \\</span><br><span class=\"line\">        libreadline-dev \\</span><br><span class=\"line\">        libsqlite3-dev</span><br><span class=\"line\"></span><br><span class=\"line\">RUN wget https://www.python.org/ftp/python/3.10.0/Python-3.10.0.tgz \\</span><br><span class=\"line\">    &amp;&amp; tar -xvf Python-3.10.0.tgz \\</span><br><span class=\"line\">    &amp;&amp; cd Python-3.10.0 \\</span><br><span class=\"line\">    &amp;&amp; ./configure --enable-optimizations \\</span><br><span class=\"line\">    &amp;&amp; make altinstall</span><br><span class=\"line\"></span><br><span class=\"line\">RUN curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py \\</span><br><span class=\"line\">    &amp;&amp; python3.10 get-pip.py</span><br><span class=\"line\"></span><br><span class=\"line\">RUN python3.10 -m venv /py &amp;&amp; \\</span><br><span class=\"line\">  /py/bin/pip install --upgrade pip &amp;&amp; \\</span><br><span class=\"line\">  /py/bin/pip install --no-cache-dir -r /tmp/requirements.txt &amp;&amp; \\</span><br><span class=\"line\">  rm /tmp/requirements.txt</span><br></pre></td></tr></table></figure>\n"},{"_content":"```\nMXMQUYT815-eyJsaWNlbnNlSWQiOiJNWE1RVVlUODE1IiwibGljZW5zZWVOYW1lIjoiSHVuYW4gSW5zdGl0dXRlIG9mIFNjaWVuY2UgYW5kIFRlY2hub2xvZ3kiLCJhc3NpZ25lZU5hbWUiOiJqaWtlIGNvZGUiLC\nJhc3NpZ25lZUVtYWlsIjoiamV0YnJhaW5zMjMwMjA2QG91dGxvb2suY29tIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiRm9yIGVkdWNhdGlvbmFsIHVzZSBvbmx5IiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSw\nicHJvZHVjdHMiOlt7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNl\nfSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6Il\nJTQyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJHTyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiRE0iLCJwYWlkVXBUb\nyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTRiIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJEUyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wO\nSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQi\nOmZhbHNlfSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29\nkZSI6IlJEIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJNIiwicG\nFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNWIiwicGFpZFVwVG8iOiIyM\nDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IkRDIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJl\neHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRQIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBEQiIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnV\nlfSx7ImNvZGUiOiJQV1MiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFNJIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6Il\nBQUyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQQ1dNUCIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQR08iLCJwYWlkV\nXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFBDIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBSQiIsInBhaWRVcFRvIjoiMjAyNC0w\nMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQU1ciLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUlMiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbm\nRlZCI6dHJ1ZX1dLCJtZXRhZGF0YSI6IjAxMjAyMzAyMDZMUEFBMDA4MDA5IiwiaGFzaCI6IjQyNTQ5NjcyLzIwMDk1Nzk5Oi03OTk2MzgyNTgiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6\nZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-OXfbtL5lwz9bDhPZ0POhH6h8h1ubDm0bzkRWX33IjJlRmK4BkGzO65BWjIJ+ndT0stY8uOUWo4FM1Aej+YGXMTlyD3rcCBkcFN6dB6FEVelLYoBevxN9m\nyhp0IGvfHaLQ6hoVxAKr0AkSAlSsgKVN6gOYw7Nn8lR/ivpuXXteZWiG4x7KCxHM/6/oPXAbQQmD1sy2q05s1tsvxBltZbsFJ3/Yv6lG89h0YlN9FvFciqUM6B1Cc5Fo7a6oUOfpyCJKPSwzyzkxLOhlL4QO6/LfQ3\nzNO9wirnz506mZXh3oB+wS1gDFLk7RehEQMqdqnjh+zaNKi1QKB/cyK1Op0oDTQ==-MIIETDCCAjSgAwIBAgIBDzANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIyMTAxMDE2MDU0\nNFoXDTI0MTAxMTE2MDU0NFowHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMjEwMTAwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC/W3uCpU5M2y48rUR/3fFR6y4xj1nOm3rIuGp2brELVGzdgK2Bez\njnDXpAxVDw5657hBkAUMoyByiDs2MgmVi9IcqdAwpk988/Daaajq9xuU1of59jH9eQ9c3BmsEtdA4boN3VpenYKATwmpKYkJKVc07ZKoXL6kSyZuF7Jq7HoQZcclChbF75QJPGbri3cw9vDk/e46kuzfwpGftvl6+v\nKibpInO6Dv0ocwImDbOutyZC7E+BwpEm1TJZW4XovMBegHhWC04cJvpH1u98xoR94ichw0jKhdppywARe43rGU96163RckIuFmFDQKZV9SMUrwpQFu4Z2D5yTNqnlLRfAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBg\nNVHQ4EFgQU5FZqQ4gnVc+inIeZF+o3ID+VhcEwSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcD\nATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBANLG1anEKid4W87vQkqWaQTkRtFKJ2GFtBeMhvLhIyM6Cg3FdQnMZr0qr9mlV0w289pf/+M14J7S7SgsfwxMJvFbw9gZlwHvhBl24N349GuthshGO9P9eK\nmNPgyTJzTtw6FedXrrHV99nC7spaY84e+DqfHGYOzMJDrg8xHDYLLHk5Q2z5TlrztXMbtLhjPKrc2+ZajFFshgE5eowfkutSYxeX8uA5czFNT1ZxmDwX1KIelbqhh6XkMQFJui8v8Eo396/sN3RAQSfvBd7Syhch2v\nlaMP4FAB11AlMKO2x/1hoKiHBU3oU3OKRTfoUTfy1uH3T+t03k1Qkr0dqgHLxiv6QU5WrarR9tx/dapqbsSmrYapmJ7S5+ghc4FTWxXJB1cjJRh3X+gwJIHjOVW+5ZVqXTG2s2Jwi2daDt6XYeigxgL2SlQpeL5kvXN\nCcuSJurJVcRZFYUkzVv85XfDauqGxYqaehPcK2TzmcXOUWPfxQxLJd2TrqSiO+mseqqkNTb3ZDiYS/ZqdQoGYIUwJqXo+EDgqlmuWUhkWwCkyo4rtTZeAj+nP00v3n8JmXtO30Fip+lxpfsVR3tO1hk4Vi2kmVjXyRk\nW2G7D7WAVt+91ahFoSeRWlKyb4KcvGvwUaa43fWLem2hyI4di2pZdr3fcYJ3xvL5ejL3m14bKsfoOv\n```\n","source":"_posts/2023-09-01-Goland License.md","raw":"```\nMXMQUYT815-eyJsaWNlbnNlSWQiOiJNWE1RVVlUODE1IiwibGljZW5zZWVOYW1lIjoiSHVuYW4gSW5zdGl0dXRlIG9mIFNjaWVuY2UgYW5kIFRlY2hub2xvZ3kiLCJhc3NpZ25lZU5hbWUiOiJqaWtlIGNvZGUiLC\nJhc3NpZ25lZUVtYWlsIjoiamV0YnJhaW5zMjMwMjA2QG91dGxvb2suY29tIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiRm9yIGVkdWNhdGlvbmFsIHVzZSBvbmx5IiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSw\nicHJvZHVjdHMiOlt7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNl\nfSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6Il\nJTQyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJHTyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiRE0iLCJwYWlkVXBUb\nyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTRiIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJEUyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wO\nSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQi\nOmZhbHNlfSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29\nkZSI6IlJEIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJNIiwicG\nFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNWIiwicGFpZFVwVG8iOiIyM\nDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IkRDIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJl\neHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRQIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBEQiIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnV\nlfSx7ImNvZGUiOiJQV1MiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFNJIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6Il\nBQUyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQQ1dNUCIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQR08iLCJwYWlkV\nXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFBDIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBSQiIsInBhaWRVcFRvIjoiMjAyNC0w\nMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQU1ciLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUlMiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbm\nRlZCI6dHJ1ZX1dLCJtZXRhZGF0YSI6IjAxMjAyMzAyMDZMUEFBMDA4MDA5IiwiaGFzaCI6IjQyNTQ5NjcyLzIwMDk1Nzk5Oi03OTk2MzgyNTgiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6\nZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-OXfbtL5lwz9bDhPZ0POhH6h8h1ubDm0bzkRWX33IjJlRmK4BkGzO65BWjIJ+ndT0stY8uOUWo4FM1Aej+YGXMTlyD3rcCBkcFN6dB6FEVelLYoBevxN9m\nyhp0IGvfHaLQ6hoVxAKr0AkSAlSsgKVN6gOYw7Nn8lR/ivpuXXteZWiG4x7KCxHM/6/oPXAbQQmD1sy2q05s1tsvxBltZbsFJ3/Yv6lG89h0YlN9FvFciqUM6B1Cc5Fo7a6oUOfpyCJKPSwzyzkxLOhlL4QO6/LfQ3\nzNO9wirnz506mZXh3oB+wS1gDFLk7RehEQMqdqnjh+zaNKi1QKB/cyK1Op0oDTQ==-MIIETDCCAjSgAwIBAgIBDzANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIyMTAxMDE2MDU0\nNFoXDTI0MTAxMTE2MDU0NFowHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMjEwMTAwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC/W3uCpU5M2y48rUR/3fFR6y4xj1nOm3rIuGp2brELVGzdgK2Bez\njnDXpAxVDw5657hBkAUMoyByiDs2MgmVi9IcqdAwpk988/Daaajq9xuU1of59jH9eQ9c3BmsEtdA4boN3VpenYKATwmpKYkJKVc07ZKoXL6kSyZuF7Jq7HoQZcclChbF75QJPGbri3cw9vDk/e46kuzfwpGftvl6+v\nKibpInO6Dv0ocwImDbOutyZC7E+BwpEm1TJZW4XovMBegHhWC04cJvpH1u98xoR94ichw0jKhdppywARe43rGU96163RckIuFmFDQKZV9SMUrwpQFu4Z2D5yTNqnlLRfAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBg\nNVHQ4EFgQU5FZqQ4gnVc+inIeZF+o3ID+VhcEwSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcD\nATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBANLG1anEKid4W87vQkqWaQTkRtFKJ2GFtBeMhvLhIyM6Cg3FdQnMZr0qr9mlV0w289pf/+M14J7S7SgsfwxMJvFbw9gZlwHvhBl24N349GuthshGO9P9eK\nmNPgyTJzTtw6FedXrrHV99nC7spaY84e+DqfHGYOzMJDrg8xHDYLLHk5Q2z5TlrztXMbtLhjPKrc2+ZajFFshgE5eowfkutSYxeX8uA5czFNT1ZxmDwX1KIelbqhh6XkMQFJui8v8Eo396/sN3RAQSfvBd7Syhch2v\nlaMP4FAB11AlMKO2x/1hoKiHBU3oU3OKRTfoUTfy1uH3T+t03k1Qkr0dqgHLxiv6QU5WrarR9tx/dapqbsSmrYapmJ7S5+ghc4FTWxXJB1cjJRh3X+gwJIHjOVW+5ZVqXTG2s2Jwi2daDt6XYeigxgL2SlQpeL5kvXN\nCcuSJurJVcRZFYUkzVv85XfDauqGxYqaehPcK2TzmcXOUWPfxQxLJd2TrqSiO+mseqqkNTb3ZDiYS/ZqdQoGYIUwJqXo+EDgqlmuWUhkWwCkyo4rtTZeAj+nP00v3n8JmXtO30Fip+lxpfsVR3tO1hk4Vi2kmVjXyRk\nW2G7D7WAVt+91ahFoSeRWlKyb4KcvGvwUaa43fWLem2hyI4di2pZdr3fcYJ3xvL5ejL3m14bKsfoOv\n```\n","slug":"2023-09-01-Goland License","published":1,"date":"2023-12-15T02:31:42.683Z","updated":"2023-12-15T02:31:42.699Z","_id":"clq60jp93000i4zgs1fg22f5i","title":"","comments":1,"layout":"post","photos":[],"content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MXMQUYT815-eyJsaWNlbnNlSWQiOiJNWE1RVVlUODE1IiwibGljZW5zZWVOYW1lIjoiSHVuYW4gSW5zdGl0dXRlIG9mIFNjaWVuY2UgYW5kIFRlY2hub2xvZ3kiLCJhc3NpZ25lZU5hbWUiOiJqaWtlIGNvZGUiLC</span><br><span class=\"line\">Jhc3NpZ25lZUVtYWlsIjoiamV0YnJhaW5zMjMwMjA2QG91dGxvb2suY29tIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiRm9yIGVkdWNhdGlvbmFsIHVzZSBvbmx5IiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSw</span><br><span class=\"line\">icHJvZHVjdHMiOlt7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNl</span><br><span class=\"line\">fSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6Il</span><br><span class=\"line\">JTQyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJHTyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiRE0iLCJwYWlkVXBUb</span><br><span class=\"line\">yI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTRiIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJEUyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wO</span><br><span class=\"line\">SIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQi</span><br><span class=\"line\">OmZhbHNlfSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29</span><br><span class=\"line\">kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJNIiwicG</span><br><span class=\"line\">FpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNWIiwicGFpZFVwVG8iOiIyM</span><br><span class=\"line\">DI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IkRDIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJl</span><br><span class=\"line\">eHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRQIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBEQiIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnV</span><br><span class=\"line\">lfSx7ImNvZGUiOiJQV1MiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFNJIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6Il</span><br><span class=\"line\">BQUyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQQ1dNUCIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQR08iLCJwYWlkV</span><br><span class=\"line\">XBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFBDIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBSQiIsInBhaWRVcFRvIjoiMjAyNC0w</span><br><span class=\"line\">Mi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQU1ciLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUlMiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbm</span><br><span class=\"line\">RlZCI6dHJ1ZX1dLCJtZXRhZGF0YSI6IjAxMjAyMzAyMDZMUEFBMDA4MDA5IiwiaGFzaCI6IjQyNTQ5NjcyLzIwMDk1Nzk5Oi03OTk2MzgyNTgiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6</span><br><span class=\"line\">ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-OXfbtL5lwz9bDhPZ0POhH6h8h1ubDm0bzkRWX33IjJlRmK4BkGzO65BWjIJ+ndT0stY8uOUWo4FM1Aej+YGXMTlyD3rcCBkcFN6dB6FEVelLYoBevxN9m</span><br><span class=\"line\">yhp0IGvfHaLQ6hoVxAKr0AkSAlSsgKVN6gOYw7Nn8lR/ivpuXXteZWiG4x7KCxHM/6/oPXAbQQmD1sy2q05s1tsvxBltZbsFJ3/Yv6lG89h0YlN9FvFciqUM6B1Cc5Fo7a6oUOfpyCJKPSwzyzkxLOhlL4QO6/LfQ3</span><br><span class=\"line\">zNO9wirnz506mZXh3oB+wS1gDFLk7RehEQMqdqnjh+zaNKi1QKB/cyK1Op0oDTQ==-MIIETDCCAjSgAwIBAgIBDzANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIyMTAxMDE2MDU0</span><br><span class=\"line\">NFoXDTI0MTAxMTE2MDU0NFowHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMjEwMTAwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC/W3uCpU5M2y48rUR/3fFR6y4xj1nOm3rIuGp2brELVGzdgK2Bez</span><br><span class=\"line\">jnDXpAxVDw5657hBkAUMoyByiDs2MgmVi9IcqdAwpk988/Daaajq9xuU1of59jH9eQ9c3BmsEtdA4boN3VpenYKATwmpKYkJKVc07ZKoXL6kSyZuF7Jq7HoQZcclChbF75QJPGbri3cw9vDk/e46kuzfwpGftvl6+v</span><br><span class=\"line\">KibpInO6Dv0ocwImDbOutyZC7E+BwpEm1TJZW4XovMBegHhWC04cJvpH1u98xoR94ichw0jKhdppywARe43rGU96163RckIuFmFDQKZV9SMUrwpQFu4Z2D5yTNqnlLRfAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBg</span><br><span class=\"line\">NVHQ4EFgQU5FZqQ4gnVc+inIeZF+o3ID+VhcEwSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcD</span><br><span class=\"line\">ATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBANLG1anEKid4W87vQkqWaQTkRtFKJ2GFtBeMhvLhIyM6Cg3FdQnMZr0qr9mlV0w289pf/+M14J7S7SgsfwxMJvFbw9gZlwHvhBl24N349GuthshGO9P9eK</span><br><span class=\"line\">mNPgyTJzTtw6FedXrrHV99nC7spaY84e+DqfHGYOzMJDrg8xHDYLLHk5Q2z5TlrztXMbtLhjPKrc2+ZajFFshgE5eowfkutSYxeX8uA5czFNT1ZxmDwX1KIelbqhh6XkMQFJui8v8Eo396/sN3RAQSfvBd7Syhch2v</span><br><span class=\"line\">laMP4FAB11AlMKO2x/1hoKiHBU3oU3OKRTfoUTfy1uH3T+t03k1Qkr0dqgHLxiv6QU5WrarR9tx/dapqbsSmrYapmJ7S5+ghc4FTWxXJB1cjJRh3X+gwJIHjOVW+5ZVqXTG2s2Jwi2daDt6XYeigxgL2SlQpeL5kvXN</span><br><span class=\"line\">CcuSJurJVcRZFYUkzVv85XfDauqGxYqaehPcK2TzmcXOUWPfxQxLJd2TrqSiO+mseqqkNTb3ZDiYS/ZqdQoGYIUwJqXo+EDgqlmuWUhkWwCkyo4rtTZeAj+nP00v3n8JmXtO30Fip+lxpfsVR3tO1hk4Vi2kmVjXyRk</span><br><span class=\"line\">W2G7D7WAVt+91ahFoSeRWlKyb4KcvGvwUaa43fWLem2hyI4di2pZdr3fcYJ3xvL5ejL3m14bKsfoOv</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MXMQUYT815-eyJsaWNlbnNlSWQiOiJNWE1RVVlUODE1IiwibGljZW5zZWVOYW1lIjoiSHVuYW4gSW5zdGl0dXRlIG9mIFNjaWVuY2UgYW5kIFRlY2hub2xvZ3kiLCJhc3NpZ25lZU5hbWUiOiJqaWtlIGNvZGUiLC</span><br><span class=\"line\">Jhc3NpZ25lZUVtYWlsIjoiamV0YnJhaW5zMjMwMjA2QG91dGxvb2suY29tIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiRm9yIGVkdWNhdGlvbmFsIHVzZSBvbmx5IiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSw</span><br><span class=\"line\">icHJvZHVjdHMiOlt7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNl</span><br><span class=\"line\">fSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6Il</span><br><span class=\"line\">JTQyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJHTyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiRE0iLCJwYWlkVXBUb</span><br><span class=\"line\">yI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTRiIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJEUyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wO</span><br><span class=\"line\">SIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQi</span><br><span class=\"line\">OmZhbHNlfSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29</span><br><span class=\"line\">kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJNIiwicG</span><br><span class=\"line\">FpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNWIiwicGFpZFVwVG8iOiIyM</span><br><span class=\"line\">DI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IkRDIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJl</span><br><span class=\"line\">eHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRQIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBEQiIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnV</span><br><span class=\"line\">lfSx7ImNvZGUiOiJQV1MiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFNJIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6Il</span><br><span class=\"line\">BQUyIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQQ1dNUCIsInBhaWRVcFRvIjoiMjAyNC0wMi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQR08iLCJwYWlkV</span><br><span class=\"line\">XBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFBDIiwicGFpZFVwVG8iOiIyMDI0LTAyLTA5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBSQiIsInBhaWRVcFRvIjoiMjAyNC0w</span><br><span class=\"line\">Mi0wOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQU1ciLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUlMiLCJwYWlkVXBUbyI6IjIwMjQtMDItMDkiLCJleHRlbm</span><br><span class=\"line\">RlZCI6dHJ1ZX1dLCJtZXRhZGF0YSI6IjAxMjAyMzAyMDZMUEFBMDA4MDA5IiwiaGFzaCI6IjQyNTQ5NjcyLzIwMDk1Nzk5Oi03OTk2MzgyNTgiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6</span><br><span class=\"line\">ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-OXfbtL5lwz9bDhPZ0POhH6h8h1ubDm0bzkRWX33IjJlRmK4BkGzO65BWjIJ+ndT0stY8uOUWo4FM1Aej+YGXMTlyD3rcCBkcFN6dB6FEVelLYoBevxN9m</span><br><span class=\"line\">yhp0IGvfHaLQ6hoVxAKr0AkSAlSsgKVN6gOYw7Nn8lR/ivpuXXteZWiG4x7KCxHM/6/oPXAbQQmD1sy2q05s1tsvxBltZbsFJ3/Yv6lG89h0YlN9FvFciqUM6B1Cc5Fo7a6oUOfpyCJKPSwzyzkxLOhlL4QO6/LfQ3</span><br><span class=\"line\">zNO9wirnz506mZXh3oB+wS1gDFLk7RehEQMqdqnjh+zaNKi1QKB/cyK1Op0oDTQ==-MIIETDCCAjSgAwIBAgIBDzANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIyMTAxMDE2MDU0</span><br><span class=\"line\">NFoXDTI0MTAxMTE2MDU0NFowHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMjEwMTAwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC/W3uCpU5M2y48rUR/3fFR6y4xj1nOm3rIuGp2brELVGzdgK2Bez</span><br><span class=\"line\">jnDXpAxVDw5657hBkAUMoyByiDs2MgmVi9IcqdAwpk988/Daaajq9xuU1of59jH9eQ9c3BmsEtdA4boN3VpenYKATwmpKYkJKVc07ZKoXL6kSyZuF7Jq7HoQZcclChbF75QJPGbri3cw9vDk/e46kuzfwpGftvl6+v</span><br><span class=\"line\">KibpInO6Dv0ocwImDbOutyZC7E+BwpEm1TJZW4XovMBegHhWC04cJvpH1u98xoR94ichw0jKhdppywARe43rGU96163RckIuFmFDQKZV9SMUrwpQFu4Z2D5yTNqnlLRfAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBg</span><br><span class=\"line\">NVHQ4EFgQU5FZqQ4gnVc+inIeZF+o3ID+VhcEwSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcD</span><br><span class=\"line\">ATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBANLG1anEKid4W87vQkqWaQTkRtFKJ2GFtBeMhvLhIyM6Cg3FdQnMZr0qr9mlV0w289pf/+M14J7S7SgsfwxMJvFbw9gZlwHvhBl24N349GuthshGO9P9eK</span><br><span class=\"line\">mNPgyTJzTtw6FedXrrHV99nC7spaY84e+DqfHGYOzMJDrg8xHDYLLHk5Q2z5TlrztXMbtLhjPKrc2+ZajFFshgE5eowfkutSYxeX8uA5czFNT1ZxmDwX1KIelbqhh6XkMQFJui8v8Eo396/sN3RAQSfvBd7Syhch2v</span><br><span class=\"line\">laMP4FAB11AlMKO2x/1hoKiHBU3oU3OKRTfoUTfy1uH3T+t03k1Qkr0dqgHLxiv6QU5WrarR9tx/dapqbsSmrYapmJ7S5+ghc4FTWxXJB1cjJRh3X+gwJIHjOVW+5ZVqXTG2s2Jwi2daDt6XYeigxgL2SlQpeL5kvXN</span><br><span class=\"line\">CcuSJurJVcRZFYUkzVv85XfDauqGxYqaehPcK2TzmcXOUWPfxQxLJd2TrqSiO+mseqqkNTb3ZDiYS/ZqdQoGYIUwJqXo+EDgqlmuWUhkWwCkyo4rtTZeAj+nP00v3n8JmXtO30Fip+lxpfsVR3tO1hk4Vi2kmVjXyRk</span><br><span class=\"line\">W2G7D7WAVt+91ahFoSeRWlKyb4KcvGvwUaa43fWLem2hyI4di2pZdr3fcYJ3xvL5ejL3m14bKsfoOv</span><br></pre></td></tr></table></figure>\n"},{"_content":"## 以下是HWID 2使用方法：\n\n### 打开管理员模式PowerShell  (注意不是CMD命令提示符，这里必须使用管理员模式PowerShell)\n### 执行命令：irm https://massgrave.dev/get | iex   (请复制这段命令粘贴，如果手打请注意 | 两边都有空格)\n### 由于开发者服务器位于国外按回车执行命令时需要获取数据流，数据流获取速度较慢、请耐心等待自动弹窗。\n### 弹窗出现后按 1 进行HWID激活，之后激活脚本自动工作，匹配系统版本并重新使用HWID硬件标识符激活。\n### 脚本执行完毕后即可转到Windows 11设置、系统、激活里查看，此时这里显示账户关联的数字许可证激活。\n### 至此在微软封杀Windows 7/8.1免费升级漏洞后，我们又可以重新使用HWID硬件标识符进行永久激活操作。\n\n## 图文操作步骤：\n![image](https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/c0b1e9d1-39c1-46f7-85b1-62143e260390)\n\n![image](https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/eb86071a-729b-4cde-aa2a-f1b59f5da53c)\n\n![image](https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/3b28cf65-88fa-4ce2-bf4f-a8b995946335)\n\n![image](https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/985747ff-9520-4473-99f7-c48fff7f345f)\n\n![image](https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/7aabdd9d-aabc-45e6-be14-af8aba62d9be)\n\n![image](https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/dbc4dd0d-04d6-4685-89a1-57122fdfe1f2)\n\n![image](https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/8813acb3-c2e5-44ff-875a-efb1780d2605)\n\n","source":"_posts/2023-10-09-[教程] Windows 10~11重新支持永久激活 新方法为HWID 2可数字权利.md","raw":"## 以下是HWID 2使用方法：\n\n### 打开管理员模式PowerShell  (注意不是CMD命令提示符，这里必须使用管理员模式PowerShell)\n### 执行命令：irm https://massgrave.dev/get | iex   (请复制这段命令粘贴，如果手打请注意 | 两边都有空格)\n### 由于开发者服务器位于国外按回车执行命令时需要获取数据流，数据流获取速度较慢、请耐心等待自动弹窗。\n### 弹窗出现后按 1 进行HWID激活，之后激活脚本自动工作，匹配系统版本并重新使用HWID硬件标识符激活。\n### 脚本执行完毕后即可转到Windows 11设置、系统、激活里查看，此时这里显示账户关联的数字许可证激活。\n### 至此在微软封杀Windows 7/8.1免费升级漏洞后，我们又可以重新使用HWID硬件标识符进行永久激活操作。\n\n## 图文操作步骤：\n![image](https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/c0b1e9d1-39c1-46f7-85b1-62143e260390)\n\n![image](https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/eb86071a-729b-4cde-aa2a-f1b59f5da53c)\n\n![image](https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/3b28cf65-88fa-4ce2-bf4f-a8b995946335)\n\n![image](https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/985747ff-9520-4473-99f7-c48fff7f345f)\n\n![image](https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/7aabdd9d-aabc-45e6-be14-af8aba62d9be)\n\n![image](https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/dbc4dd0d-04d6-4685-89a1-57122fdfe1f2)\n\n![image](https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/8813acb3-c2e5-44ff-875a-efb1780d2605)\n\n","slug":"2023-10-09-[教程] Windows 10~11重新支持永久激活 新方法为HWID 2可数字权利","published":1,"date":"2023-12-15T02:31:42.715Z","updated":"2023-12-15T02:31:42.747Z","_id":"clq60jpeo000j4zgs2lstg9y2","title":"","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"以下是HWID-2使用方法：\"><a href=\"#以下是HWID-2使用方法：\" class=\"headerlink\" title=\"以下是HWID 2使用方法：\"></a>以下是HWID 2使用方法：</h2><h3 id=\"打开管理员模式PowerShell-注意不是CMD命令提示符，这里必须使用管理员模式PowerShell\"><a href=\"#打开管理员模式PowerShell-注意不是CMD命令提示符，这里必须使用管理员模式PowerShell\" class=\"headerlink\" title=\"打开管理员模式PowerShell  (注意不是CMD命令提示符，这里必须使用管理员模式PowerShell)\"></a>打开管理员模式PowerShell  (注意不是CMD命令提示符，这里必须使用管理员模式PowerShell)</h3><h3 id=\"执行命令：irm-https-massgrave-dev-get-iex-请复制这段命令粘贴，如果手打请注意-两边都有空格\"><a href=\"#执行命令：irm-https-massgrave-dev-get-iex-请复制这段命令粘贴，如果手打请注意-两边都有空格\" class=\"headerlink\" title=\"执行命令：irm https://massgrave.dev/get | iex   (请复制这段命令粘贴，如果手打请注意 | 两边都有空格)\"></a>执行命令：irm <a href=\"https://massgrave.dev/get\">https://massgrave.dev/get</a> | iex   (请复制这段命令粘贴，如果手打请注意 | 两边都有空格)</h3><h3 id=\"由于开发者服务器位于国外按回车执行命令时需要获取数据流，数据流获取速度较慢、请耐心等待自动弹窗。\"><a href=\"#由于开发者服务器位于国外按回车执行命令时需要获取数据流，数据流获取速度较慢、请耐心等待自动弹窗。\" class=\"headerlink\" title=\"由于开发者服务器位于国外按回车执行命令时需要获取数据流，数据流获取速度较慢、请耐心等待自动弹窗。\"></a>由于开发者服务器位于国外按回车执行命令时需要获取数据流，数据流获取速度较慢、请耐心等待自动弹窗。</h3><h3 id=\"弹窗出现后按-1-进行HWID激活，之后激活脚本自动工作，匹配系统版本并重新使用HWID硬件标识符激活。\"><a href=\"#弹窗出现后按-1-进行HWID激活，之后激活脚本自动工作，匹配系统版本并重新使用HWID硬件标识符激活。\" class=\"headerlink\" title=\"弹窗出现后按 1 进行HWID激活，之后激活脚本自动工作，匹配系统版本并重新使用HWID硬件标识符激活。\"></a>弹窗出现后按 1 进行HWID激活，之后激活脚本自动工作，匹配系统版本并重新使用HWID硬件标识符激活。</h3><h3 id=\"脚本执行完毕后即可转到Windows-11设置、系统、激活里查看，此时这里显示账户关联的数字许可证激活。\"><a href=\"#脚本执行完毕后即可转到Windows-11设置、系统、激活里查看，此时这里显示账户关联的数字许可证激活。\" class=\"headerlink\" title=\"脚本执行完毕后即可转到Windows 11设置、系统、激活里查看，此时这里显示账户关联的数字许可证激活。\"></a>脚本执行完毕后即可转到Windows 11设置、系统、激活里查看，此时这里显示账户关联的数字许可证激活。</h3><h3 id=\"至此在微软封杀Windows-7-8-1免费升级漏洞后，我们又可以重新使用HWID硬件标识符进行永久激活操作。\"><a href=\"#至此在微软封杀Windows-7-8-1免费升级漏洞后，我们又可以重新使用HWID硬件标识符进行永久激活操作。\" class=\"headerlink\" title=\"至此在微软封杀Windows 7&#x2F;8.1免费升级漏洞后，我们又可以重新使用HWID硬件标识符进行永久激活操作。\"></a>至此在微软封杀Windows 7&#x2F;8.1免费升级漏洞后，我们又可以重新使用HWID硬件标识符进行永久激活操作。</h3><h2 id=\"图文操作步骤：\"><a href=\"#图文操作步骤：\" class=\"headerlink\" title=\"图文操作步骤：\"></a>图文操作步骤：</h2><p><img src=\"https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/c0b1e9d1-39c1-46f7-85b1-62143e260390\" alt=\"image\"></p>\n<p><img src=\"https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/eb86071a-729b-4cde-aa2a-f1b59f5da53c\" alt=\"image\"></p>\n<p><img src=\"https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/3b28cf65-88fa-4ce2-bf4f-a8b995946335\" alt=\"image\"></p>\n<p><img src=\"https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/985747ff-9520-4473-99f7-c48fff7f345f\" alt=\"image\"></p>\n<p><img src=\"https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/7aabdd9d-aabc-45e6-be14-af8aba62d9be\" alt=\"image\"></p>\n<p><img src=\"https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/dbc4dd0d-04d6-4685-89a1-57122fdfe1f2\" alt=\"image\"></p>\n<p><img src=\"https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/8813acb3-c2e5-44ff-875a-efb1780d2605\" alt=\"image\"></p>\n","excerpt":"","more":"<h2 id=\"以下是HWID-2使用方法：\"><a href=\"#以下是HWID-2使用方法：\" class=\"headerlink\" title=\"以下是HWID 2使用方法：\"></a>以下是HWID 2使用方法：</h2><h3 id=\"打开管理员模式PowerShell-注意不是CMD命令提示符，这里必须使用管理员模式PowerShell\"><a href=\"#打开管理员模式PowerShell-注意不是CMD命令提示符，这里必须使用管理员模式PowerShell\" class=\"headerlink\" title=\"打开管理员模式PowerShell  (注意不是CMD命令提示符，这里必须使用管理员模式PowerShell)\"></a>打开管理员模式PowerShell  (注意不是CMD命令提示符，这里必须使用管理员模式PowerShell)</h3><h3 id=\"执行命令：irm-https-massgrave-dev-get-iex-请复制这段命令粘贴，如果手打请注意-两边都有空格\"><a href=\"#执行命令：irm-https-massgrave-dev-get-iex-请复制这段命令粘贴，如果手打请注意-两边都有空格\" class=\"headerlink\" title=\"执行命令：irm https://massgrave.dev/get | iex   (请复制这段命令粘贴，如果手打请注意 | 两边都有空格)\"></a>执行命令：irm <a href=\"https://massgrave.dev/get\">https://massgrave.dev/get</a> | iex   (请复制这段命令粘贴，如果手打请注意 | 两边都有空格)</h3><h3 id=\"由于开发者服务器位于国外按回车执行命令时需要获取数据流，数据流获取速度较慢、请耐心等待自动弹窗。\"><a href=\"#由于开发者服务器位于国外按回车执行命令时需要获取数据流，数据流获取速度较慢、请耐心等待自动弹窗。\" class=\"headerlink\" title=\"由于开发者服务器位于国外按回车执行命令时需要获取数据流，数据流获取速度较慢、请耐心等待自动弹窗。\"></a>由于开发者服务器位于国外按回车执行命令时需要获取数据流，数据流获取速度较慢、请耐心等待自动弹窗。</h3><h3 id=\"弹窗出现后按-1-进行HWID激活，之后激活脚本自动工作，匹配系统版本并重新使用HWID硬件标识符激活。\"><a href=\"#弹窗出现后按-1-进行HWID激活，之后激活脚本自动工作，匹配系统版本并重新使用HWID硬件标识符激活。\" class=\"headerlink\" title=\"弹窗出现后按 1 进行HWID激活，之后激活脚本自动工作，匹配系统版本并重新使用HWID硬件标识符激活。\"></a>弹窗出现后按 1 进行HWID激活，之后激活脚本自动工作，匹配系统版本并重新使用HWID硬件标识符激活。</h3><h3 id=\"脚本执行完毕后即可转到Windows-11设置、系统、激活里查看，此时这里显示账户关联的数字许可证激活。\"><a href=\"#脚本执行完毕后即可转到Windows-11设置、系统、激活里查看，此时这里显示账户关联的数字许可证激活。\" class=\"headerlink\" title=\"脚本执行完毕后即可转到Windows 11设置、系统、激活里查看，此时这里显示账户关联的数字许可证激活。\"></a>脚本执行完毕后即可转到Windows 11设置、系统、激活里查看，此时这里显示账户关联的数字许可证激活。</h3><h3 id=\"至此在微软封杀Windows-7-8-1免费升级漏洞后，我们又可以重新使用HWID硬件标识符进行永久激活操作。\"><a href=\"#至此在微软封杀Windows-7-8-1免费升级漏洞后，我们又可以重新使用HWID硬件标识符进行永久激活操作。\" class=\"headerlink\" title=\"至此在微软封杀Windows 7&#x2F;8.1免费升级漏洞后，我们又可以重新使用HWID硬件标识符进行永久激活操作。\"></a>至此在微软封杀Windows 7&#x2F;8.1免费升级漏洞后，我们又可以重新使用HWID硬件标识符进行永久激活操作。</h3><h2 id=\"图文操作步骤：\"><a href=\"#图文操作步骤：\" class=\"headerlink\" title=\"图文操作步骤：\"></a>图文操作步骤：</h2><p><img src=\"https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/c0b1e9d1-39c1-46f7-85b1-62143e260390\" alt=\"image\"></p>\n<p><img src=\"https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/eb86071a-729b-4cde-aa2a-f1b59f5da53c\" alt=\"image\"></p>\n<p><img src=\"https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/3b28cf65-88fa-4ce2-bf4f-a8b995946335\" alt=\"image\"></p>\n<p><img src=\"https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/985747ff-9520-4473-99f7-c48fff7f345f\" alt=\"image\"></p>\n<p><img src=\"https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/7aabdd9d-aabc-45e6-be14-af8aba62d9be\" alt=\"image\"></p>\n<p><img src=\"https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/dbc4dd0d-04d6-4685-89a1-57122fdfe1f2\" alt=\"image\"></p>\n<p><img src=\"https://github.com/crazyZSShuo/crazyZSShuo.github.io/assets/33218762/8813acb3-c2e5-44ff-875a-efb1780d2605\" alt=\"image\"></p>\n"},{"_content":"### 安装依赖\nyum -y groupinstall \"Development tools\"\n\nyum install -y ncurses-devel gdbm-devel xz-devel sqlite-devel tk-devel uuid-devel readline-devel bzip2-devel libffi-devel\n\nyum install -y openssl-devel openssl11 openssl11-devel\n\n\n### 下载\nmkdir -p /doc/temp && cd /doc/temp\n\nwget https://www.python.org/ftp/python/3.10.4/Python-3.10.4.tgz\n\n\n### 编译\nexport CFLAGS=$(pkg-config --cflags openssl11)\n\nexport LDFLAGS=$(pkg-config --libs openssl11)\n\n\ntar xvzf Python-3.10.4.tgz\n\ncd Python-3.10.4\n\n./configure --enable-optimizations && make altinstall\n\n\n### 验证\n/usr/local/bin/python3.10 --version\n\n/usr/local/bin/pip3.10 --version\n\n\n### 配置\nln -sf /usr/local/bin/python3.10 /usr/bin/python3\n\nln -sf /usr/local/bin/pip3.10  /usr/bin/pip3\n\n\n### 配置pip源\nmkdir -p ~/.pip\n\ntouch ~/.pip/pip.conf\n\nvim ~/.pip/pip.conf\n\n[global]\n\nindex-url=https://pypi.tuna.tsinghua.edu.cn/simple/\n\nextra-index-url=\n        http://pypi.douban.com/simple/\n        http://mirrors.aliyun.com/pypi/simple/\n        \n#proxy = [user:passwd@]proxy.server:port\n\n[install]\n\ntrusted-host=\n        pypi.tuna.tsinghua.edu.cn\n        pypi.douban.com\n        mirrors.aliyun.com\n        \nssl_verify: false\n\npip3 install --upgrade pip\n\n\n\n\n\n","source":"_posts/2023-10-31-Centos安装python3.10流程.md","raw":"### 安装依赖\nyum -y groupinstall \"Development tools\"\n\nyum install -y ncurses-devel gdbm-devel xz-devel sqlite-devel tk-devel uuid-devel readline-devel bzip2-devel libffi-devel\n\nyum install -y openssl-devel openssl11 openssl11-devel\n\n\n### 下载\nmkdir -p /doc/temp && cd /doc/temp\n\nwget https://www.python.org/ftp/python/3.10.4/Python-3.10.4.tgz\n\n\n### 编译\nexport CFLAGS=$(pkg-config --cflags openssl11)\n\nexport LDFLAGS=$(pkg-config --libs openssl11)\n\n\ntar xvzf Python-3.10.4.tgz\n\ncd Python-3.10.4\n\n./configure --enable-optimizations && make altinstall\n\n\n### 验证\n/usr/local/bin/python3.10 --version\n\n/usr/local/bin/pip3.10 --version\n\n\n### 配置\nln -sf /usr/local/bin/python3.10 /usr/bin/python3\n\nln -sf /usr/local/bin/pip3.10  /usr/bin/pip3\n\n\n### 配置pip源\nmkdir -p ~/.pip\n\ntouch ~/.pip/pip.conf\n\nvim ~/.pip/pip.conf\n\n[global]\n\nindex-url=https://pypi.tuna.tsinghua.edu.cn/simple/\n\nextra-index-url=\n        http://pypi.douban.com/simple/\n        http://mirrors.aliyun.com/pypi/simple/\n        \n#proxy = [user:passwd@]proxy.server:port\n\n[install]\n\ntrusted-host=\n        pypi.tuna.tsinghua.edu.cn\n        pypi.douban.com\n        mirrors.aliyun.com\n        \nssl_verify: false\n\npip3 install --upgrade pip\n\n\n\n\n\n","slug":"2023-10-31-Centos安装python3.10流程","published":1,"date":"2023-12-15T02:31:42.919Z","updated":"2023-12-15T02:31:42.947Z","_id":"clq60jpft000k4zgs9945399z","title":"","comments":1,"layout":"post","photos":[],"content":"<h3 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h3><p>yum -y groupinstall “Development tools”</p>\n<p>yum install -y ncurses-devel gdbm-devel xz-devel sqlite-devel tk-devel uuid-devel readline-devel bzip2-devel libffi-devel</p>\n<p>yum install -y openssl-devel openssl11 openssl11-devel</p>\n<h3 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h3><p>mkdir -p &#x2F;doc&#x2F;temp &amp;&amp; cd &#x2F;doc&#x2F;temp</p>\n<p>wget <a href=\"https://www.python.org/ftp/python/3.10.4/Python-3.10.4.tgz\">https://www.python.org/ftp/python/3.10.4/Python-3.10.4.tgz</a></p>\n<h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><p>export CFLAGS&#x3D;$(pkg-config –cflags openssl11)</p>\n<p>export LDFLAGS&#x3D;$(pkg-config –libs openssl11)</p>\n<p>tar xvzf Python-3.10.4.tgz</p>\n<p>cd Python-3.10.4</p>\n<p>.&#x2F;configure –enable-optimizations &amp;&amp; make altinstall</p>\n<h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3><p>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.10 –version</p>\n<p>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;pip3.10 –version</p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>ln -sf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.10 &#x2F;usr&#x2F;bin&#x2F;python3</p>\n<p>ln -sf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pip3.10  &#x2F;usr&#x2F;bin&#x2F;pip3</p>\n<h3 id=\"配置pip源\"><a href=\"#配置pip源\" class=\"headerlink\" title=\"配置pip源\"></a>配置pip源</h3><p>mkdir -p ~&#x2F;.pip</p>\n<p>touch ~&#x2F;.pip&#x2F;pip.conf</p>\n<p>vim ~&#x2F;.pip&#x2F;pip.conf</p>\n<p>[global]</p>\n<p>index-url&#x3D;<a href=\"https://pypi.tuna.tsinghua.edu.cn/simple/\">https://pypi.tuna.tsinghua.edu.cn/simple/</a></p>\n<p>extra-index-url&#x3D;<br>        <a href=\"http://pypi.douban.com/simple/\">http://pypi.douban.com/simple/</a><br>        <a href=\"http://mirrors.aliyun.com/pypi/simple/\">http://mirrors.aliyun.com/pypi/simple/</a></p>\n<p>#proxy &#x3D; [user:passwd@]proxy.server:port</p>\n<p>[install]</p>\n<p>trusted-host&#x3D;<br>        pypi.tuna.tsinghua.edu.cn<br>        pypi.douban.com<br>        mirrors.aliyun.com</p>\n<p>ssl_verify: false</p>\n<p>pip3 install –upgrade pip</p>\n","excerpt":"","more":"<h3 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h3><p>yum -y groupinstall “Development tools”</p>\n<p>yum install -y ncurses-devel gdbm-devel xz-devel sqlite-devel tk-devel uuid-devel readline-devel bzip2-devel libffi-devel</p>\n<p>yum install -y openssl-devel openssl11 openssl11-devel</p>\n<h3 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h3><p>mkdir -p &#x2F;doc&#x2F;temp &amp;&amp; cd &#x2F;doc&#x2F;temp</p>\n<p>wget <a href=\"https://www.python.org/ftp/python/3.10.4/Python-3.10.4.tgz\">https://www.python.org/ftp/python/3.10.4/Python-3.10.4.tgz</a></p>\n<h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><p>export CFLAGS&#x3D;$(pkg-config –cflags openssl11)</p>\n<p>export LDFLAGS&#x3D;$(pkg-config –libs openssl11)</p>\n<p>tar xvzf Python-3.10.4.tgz</p>\n<p>cd Python-3.10.4</p>\n<p>.&#x2F;configure –enable-optimizations &amp;&amp; make altinstall</p>\n<h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3><p>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.10 –version</p>\n<p>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;pip3.10 –version</p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>ln -sf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.10 &#x2F;usr&#x2F;bin&#x2F;python3</p>\n<p>ln -sf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pip3.10  &#x2F;usr&#x2F;bin&#x2F;pip3</p>\n<h3 id=\"配置pip源\"><a href=\"#配置pip源\" class=\"headerlink\" title=\"配置pip源\"></a>配置pip源</h3><p>mkdir -p ~&#x2F;.pip</p>\n<p>touch ~&#x2F;.pip&#x2F;pip.conf</p>\n<p>vim ~&#x2F;.pip&#x2F;pip.conf</p>\n<p>[global]</p>\n<p>index-url&#x3D;<a href=\"https://pypi.tuna.tsinghua.edu.cn/simple/\">https://pypi.tuna.tsinghua.edu.cn/simple/</a></p>\n<p>extra-index-url&#x3D;<br>        <a href=\"http://pypi.douban.com/simple/\">http://pypi.douban.com/simple/</a><br>        <a href=\"http://mirrors.aliyun.com/pypi/simple/\">http://mirrors.aliyun.com/pypi/simple/</a></p>\n<p>#proxy &#x3D; [user:passwd@]proxy.server:port</p>\n<p>[install]</p>\n<p>trusted-host&#x3D;<br>        pypi.tuna.tsinghua.edu.cn<br>        pypi.douban.com<br>        mirrors.aliyun.com</p>\n<p>ssl_verify: false</p>\n<p>pip3 install –upgrade pip</p>\n"},{"_content":"### 使用公钥\n\nwget -qO - https://www.mongodb.org/static/pgp/server-5.0.asc | sudo apt-key add -\n\n### 创建mongodb列表文件\n\nmkdir /etc/apt/sources.list.d/mongodb-org-5.0.list\n\n### 查看当前系统版本\n\nlsb_release -dc\n\n### 注册mongo源\n\necho \"deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu focal/mongodb-org/5.0 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-5.0.list\n\n### 更新源\n\nsudo apt-get update\n\n### 开始安装\n\nsudo apt-get install -y mongodb-org=5.0.6 mongodb-org-server=5.0.6 mongodb-org-shell=5.0.6 mongodb-org-mongos=5.0.6 mongodb-org-tools=5.0.6\n\n### 创建数据存储目录\n\nsudo mkdir -p /opt/database/mongodb/data/db\n\n### 查看配置文件\n\nvim /etc/mongod.conf\n\n### 更改数据库目录路径\n\nstorage:\n  #dbPath: /var/lib/mongodb\n  dbPath: /opt/database/mongodb/data/db\n\n### 修改目录权限，该文件只属于mongodb用户组\n\ncd /opt/database/ && sudo chown -R mongodb:mongodb mongodb/\n\n\n### 管理mongo服务 \n\nsudo systemctl daemon-reload\n\nsudo systemctl restart mongod.service\n\nsudo systemctl start/status mongod.service\n\n\n\n","source":"_posts/2023-11-03-ubuntu安装mongodb.md","raw":"### 使用公钥\n\nwget -qO - https://www.mongodb.org/static/pgp/server-5.0.asc | sudo apt-key add -\n\n### 创建mongodb列表文件\n\nmkdir /etc/apt/sources.list.d/mongodb-org-5.0.list\n\n### 查看当前系统版本\n\nlsb_release -dc\n\n### 注册mongo源\n\necho \"deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu focal/mongodb-org/5.0 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-5.0.list\n\n### 更新源\n\nsudo apt-get update\n\n### 开始安装\n\nsudo apt-get install -y mongodb-org=5.0.6 mongodb-org-server=5.0.6 mongodb-org-shell=5.0.6 mongodb-org-mongos=5.0.6 mongodb-org-tools=5.0.6\n\n### 创建数据存储目录\n\nsudo mkdir -p /opt/database/mongodb/data/db\n\n### 查看配置文件\n\nvim /etc/mongod.conf\n\n### 更改数据库目录路径\n\nstorage:\n  #dbPath: /var/lib/mongodb\n  dbPath: /opt/database/mongodb/data/db\n\n### 修改目录权限，该文件只属于mongodb用户组\n\ncd /opt/database/ && sudo chown -R mongodb:mongodb mongodb/\n\n\n### 管理mongo服务 \n\nsudo systemctl daemon-reload\n\nsudo systemctl restart mongod.service\n\nsudo systemctl start/status mongod.service\n\n\n\n","slug":"2023-11-03-ubuntu安装mongodb","published":1,"date":"2023-12-15T02:31:43.035Z","updated":"2023-12-15T02:31:43.051Z","_id":"clq60jpj2000l4zgs18a3e3qz","title":"","comments":1,"layout":"post","photos":[],"content":"<h3 id=\"使用公钥\"><a href=\"#使用公钥\" class=\"headerlink\" title=\"使用公钥\"></a>使用公钥</h3><p>wget -qO - <a href=\"https://www.mongodb.org/static/pgp/server-5.0.asc\">https://www.mongodb.org/static/pgp/server-5.0.asc</a> | sudo apt-key add -</p>\n<h3 id=\"创建mongodb列表文件\"><a href=\"#创建mongodb列表文件\" class=\"headerlink\" title=\"创建mongodb列表文件\"></a>创建mongodb列表文件</h3><p>mkdir &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;mongodb-org-5.0.list</p>\n<h3 id=\"查看当前系统版本\"><a href=\"#查看当前系统版本\" class=\"headerlink\" title=\"查看当前系统版本\"></a>查看当前系统版本</h3><p>lsb_release -dc</p>\n<h3 id=\"注册mongo源\"><a href=\"#注册mongo源\" class=\"headerlink\" title=\"注册mongo源\"></a>注册mongo源</h3><p>echo “deb [ arch&#x3D;amd64,arm64 ] <a href=\"https://repo.mongodb.org/apt/ubuntu\">https://repo.mongodb.org/apt/ubuntu</a> focal&#x2F;mongodb-org&#x2F;5.0 multiverse” | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;mongodb-org-5.0.list</p>\n<h3 id=\"更新源\"><a href=\"#更新源\" class=\"headerlink\" title=\"更新源\"></a>更新源</h3><p>sudo apt-get update</p>\n<h3 id=\"开始安装\"><a href=\"#开始安装\" class=\"headerlink\" title=\"开始安装\"></a>开始安装</h3><p>sudo apt-get install -y mongodb-org&#x3D;5.0.6 mongodb-org-server&#x3D;5.0.6 mongodb-org-shell&#x3D;5.0.6 mongodb-org-mongos&#x3D;5.0.6 mongodb-org-tools&#x3D;5.0.6</p>\n<h3 id=\"创建数据存储目录\"><a href=\"#创建数据存储目录\" class=\"headerlink\" title=\"创建数据存储目录\"></a>创建数据存储目录</h3><p>sudo mkdir -p &#x2F;opt&#x2F;database&#x2F;mongodb&#x2F;data&#x2F;db</p>\n<h3 id=\"查看配置文件\"><a href=\"#查看配置文件\" class=\"headerlink\" title=\"查看配置文件\"></a>查看配置文件</h3><p>vim &#x2F;etc&#x2F;mongod.conf</p>\n<h3 id=\"更改数据库目录路径\"><a href=\"#更改数据库目录路径\" class=\"headerlink\" title=\"更改数据库目录路径\"></a>更改数据库目录路径</h3><p>storage:<br>  #dbPath: &#x2F;var&#x2F;lib&#x2F;mongodb<br>  dbPath: &#x2F;opt&#x2F;database&#x2F;mongodb&#x2F;data&#x2F;db</p>\n<h3 id=\"修改目录权限，该文件只属于mongodb用户组\"><a href=\"#修改目录权限，该文件只属于mongodb用户组\" class=\"headerlink\" title=\"修改目录权限，该文件只属于mongodb用户组\"></a>修改目录权限，该文件只属于mongodb用户组</h3><p>cd &#x2F;opt&#x2F;database&#x2F; &amp;&amp; sudo chown -R mongodb:mongodb mongodb&#x2F;</p>\n<h3 id=\"管理mongo服务\"><a href=\"#管理mongo服务\" class=\"headerlink\" title=\"管理mongo服务\"></a>管理mongo服务</h3><p>sudo systemctl daemon-reload</p>\n<p>sudo systemctl restart mongod.service</p>\n<p>sudo systemctl start&#x2F;status mongod.service</p>\n","excerpt":"","more":"<h3 id=\"使用公钥\"><a href=\"#使用公钥\" class=\"headerlink\" title=\"使用公钥\"></a>使用公钥</h3><p>wget -qO - <a href=\"https://www.mongodb.org/static/pgp/server-5.0.asc\">https://www.mongodb.org/static/pgp/server-5.0.asc</a> | sudo apt-key add -</p>\n<h3 id=\"创建mongodb列表文件\"><a href=\"#创建mongodb列表文件\" class=\"headerlink\" title=\"创建mongodb列表文件\"></a>创建mongodb列表文件</h3><p>mkdir &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;mongodb-org-5.0.list</p>\n<h3 id=\"查看当前系统版本\"><a href=\"#查看当前系统版本\" class=\"headerlink\" title=\"查看当前系统版本\"></a>查看当前系统版本</h3><p>lsb_release -dc</p>\n<h3 id=\"注册mongo源\"><a href=\"#注册mongo源\" class=\"headerlink\" title=\"注册mongo源\"></a>注册mongo源</h3><p>echo “deb [ arch&#x3D;amd64,arm64 ] <a href=\"https://repo.mongodb.org/apt/ubuntu\">https://repo.mongodb.org/apt/ubuntu</a> focal&#x2F;mongodb-org&#x2F;5.0 multiverse” | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;mongodb-org-5.0.list</p>\n<h3 id=\"更新源\"><a href=\"#更新源\" class=\"headerlink\" title=\"更新源\"></a>更新源</h3><p>sudo apt-get update</p>\n<h3 id=\"开始安装\"><a href=\"#开始安装\" class=\"headerlink\" title=\"开始安装\"></a>开始安装</h3><p>sudo apt-get install -y mongodb-org&#x3D;5.0.6 mongodb-org-server&#x3D;5.0.6 mongodb-org-shell&#x3D;5.0.6 mongodb-org-mongos&#x3D;5.0.6 mongodb-org-tools&#x3D;5.0.6</p>\n<h3 id=\"创建数据存储目录\"><a href=\"#创建数据存储目录\" class=\"headerlink\" title=\"创建数据存储目录\"></a>创建数据存储目录</h3><p>sudo mkdir -p &#x2F;opt&#x2F;database&#x2F;mongodb&#x2F;data&#x2F;db</p>\n<h3 id=\"查看配置文件\"><a href=\"#查看配置文件\" class=\"headerlink\" title=\"查看配置文件\"></a>查看配置文件</h3><p>vim &#x2F;etc&#x2F;mongod.conf</p>\n<h3 id=\"更改数据库目录路径\"><a href=\"#更改数据库目录路径\" class=\"headerlink\" title=\"更改数据库目录路径\"></a>更改数据库目录路径</h3><p>storage:<br>  #dbPath: &#x2F;var&#x2F;lib&#x2F;mongodb<br>  dbPath: &#x2F;opt&#x2F;database&#x2F;mongodb&#x2F;data&#x2F;db</p>\n<h3 id=\"修改目录权限，该文件只属于mongodb用户组\"><a href=\"#修改目录权限，该文件只属于mongodb用户组\" class=\"headerlink\" title=\"修改目录权限，该文件只属于mongodb用户组\"></a>修改目录权限，该文件只属于mongodb用户组</h3><p>cd &#x2F;opt&#x2F;database&#x2F; &amp;&amp; sudo chown -R mongodb:mongodb mongodb&#x2F;</p>\n<h3 id=\"管理mongo服务\"><a href=\"#管理mongo服务\" class=\"headerlink\" title=\"管理mongo服务\"></a>管理mongo服务</h3><p>sudo systemctl daemon-reload</p>\n<p>sudo systemctl restart mongod.service</p>\n<p>sudo systemctl start&#x2F;status mongod.service</p>\n"},{"_content":"### Ubuntu 22.04 阿里源\n\ndeb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse\n","source":"_posts/2023-11-24-ubuntu22.04配置国内源.md","raw":"### Ubuntu 22.04 阿里源\n\ndeb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse\n\ndeb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse\n\ndeb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse\n","slug":"2023-11-24-ubuntu22.04配置国内源","published":1,"date":"2023-12-15T02:31:43.143Z","updated":"2023-12-15T02:31:43.151Z","_id":"clq60jpj3000m4zgs3du6alzy","title":"","comments":1,"layout":"post","photos":[],"content":"<h3 id=\"Ubuntu-22-04-阿里源\"><a href=\"#Ubuntu-22-04-阿里源\" class=\"headerlink\" title=\"Ubuntu 22.04 阿里源\"></a>Ubuntu 22.04 阿里源</h3><p>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy main restricted universe multiverse</p>\n<p>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy main restricted universe multiverse</p>\n<p>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-security main restricted universe multiverse</p>\n<p>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-security main restricted universe multiverse</p>\n<p>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-updates main restricted universe multiverse</p>\n<p>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-updates main restricted universe multiverse</p>\n<p>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-proposed main restricted universe multiverse</p>\n<p>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-proposed main restricted universe multiverse</p>\n<p>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-backports main restricted universe multiverse</p>\n<p>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-backports main restricted universe multiverse</p>\n","excerpt":"","more":"<h3 id=\"Ubuntu-22-04-阿里源\"><a href=\"#Ubuntu-22-04-阿里源\" class=\"headerlink\" title=\"Ubuntu 22.04 阿里源\"></a>Ubuntu 22.04 阿里源</h3><p>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy main restricted universe multiverse</p>\n<p>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy main restricted universe multiverse</p>\n<p>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-security main restricted universe multiverse</p>\n<p>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-security main restricted universe multiverse</p>\n<p>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-updates main restricted universe multiverse</p>\n<p>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-updates main restricted universe multiverse</p>\n<p>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-proposed main restricted universe multiverse</p>\n<p>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-proposed main restricted universe multiverse</p>\n<p>deb <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-backports main restricted universe multiverse</p>\n<p>deb-src <a href=\"http://mirrors.aliyun.com/ubuntu/\">http://mirrors.aliyun.com/ubuntu/</a> jammy-backports main restricted universe multiverse</p>\n"},{"_content":"### 卸载残留\n\nsudo apt-get remove --purge mysql-server mysql-client mysql-common\n\nsudo apt-get autoremove\n\nsudo apt-get autoclean\n\n### 删除MySQL数据目录\n\nsudo rm -rf /var/lib/mysql\n\n\n### 安装\n\nsudo apt-get update\n\nsudo apt-get install mysql-server\n\n### 启动和关闭mysql服务器\n\nsystemctl status mysql.service\n\nsystemctl start mysql.service\n\n\n### 进入MySQL命令端\n\nmysql -uroot -p （直接回车不需要密码）\n\n\n### 退出\n\nexit；\n\n### 自定义mysql的存储路径为\n\nmysql默认存储路径为: /var/lib/mysql\n\n将默认路径里的数据拷贝到自定义路径下：（此处自定义路径为：/opt/database/mysql）\n\ncp -arp /var/lib/mysql /opt/database/mysql (-arp参数是递归复制并且保留权限)\n\n\n默认配置文件路径：/etc/mysql/mysql.conf.d/mysqld.cnf\n\n去掉#注释，将路径改为自定义路径，比如：datadir=/opt/database/mysql\n\n继续修改：\n\nvim /etc/apparmor.d/usr.sbin.mysqld\n\n找到此行并修改：\n\n#Allow data dir access\n\n  #/var/lib/mysql/ r,\n  \n  #/var/lib/mysql/** rwk,\n  \n  /opt/database/mysql/ r,\n  \n  /opt/database/mysql/** rwk,\n\n### 重启 apparmor 服务：\n\nsystemctl status apparmor.service\n\n或：\n\nservice apparmor restart\n\n\n### 创建新用户并授权\n\ncreate user 'zs'@'%' identified by 'zs1024';\n\nGRANT ALL PRIVILEGES ON *.* TO 'zs'@'%' WITH GRANT OPTION;\n\nFLUSH PRIVILEGES;\n\n\n### 可能会遇到的问题：\n\n#### MySQL中文乱码的问题\n\nshow variables like \"char%\";\n\n如果character_set_server参数是latin1，则使用如下命令修改，否则跳过此步骤；\n\nvi /etc/mysql/mysql.conf.d/mysqld.cnf\n\n在[mysqld]下添加一行character_set_server=utf8mb4\n\n\n#### 重启MySQL服务\n\nsystemctl restart mysql.service\n\n#### Host is not allowed to connect to this MySQL server错误\n\n1. 进入命令端： mysql -u root -p\n\n2. use mysql\n\n3. select user, host from user ;\n\n4. 将root的host改为\"%\"\n\n5. update user set host='%' where user='root';\n\n#### Mysql服务出现error 1698(28000)错误 (密码校验插件问题)\n\n1. SELECT user,host,plugin FROM mysql.user;\n\n2. ALTER USER ‘root’@‘%’ IDENTIFIED WITH mysql_native_password BY’自定义密码';\n\n3. flush privileges;\n\n#### 修改root密码\n\n1.use mysql;\n \n2.ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY'自定义密码';\n\n3.flush privileges; #更新所有操作权限\n\n### 开启数据库慢日志\n\n默认配置文件在/etc/my.cnf,在配置文件加上上述内容开启慢日志和定义存储路径。\n\n[mysqld]\n\nslow_query_log = 1\n\nslow_query_log_file = /opt/database/mysql/mysql-slow.log\n\nlong_query_time = 2\n\n\n[参考文章地址链接1](https://www.wake.wiki/archives/ubuntu1804-an-zhuang-mysql-shu-ju-ku)\n\n[参考文章地址链接2](https://www.cnblogs.com/RioTian/p/16066917.html)\n\n\n\n\n\n\n","source":"_posts/2023-11-06-ubuntu20.04安装Mysql8.0数据库.md","raw":"### 卸载残留\n\nsudo apt-get remove --purge mysql-server mysql-client mysql-common\n\nsudo apt-get autoremove\n\nsudo apt-get autoclean\n\n### 删除MySQL数据目录\n\nsudo rm -rf /var/lib/mysql\n\n\n### 安装\n\nsudo apt-get update\n\nsudo apt-get install mysql-server\n\n### 启动和关闭mysql服务器\n\nsystemctl status mysql.service\n\nsystemctl start mysql.service\n\n\n### 进入MySQL命令端\n\nmysql -uroot -p （直接回车不需要密码）\n\n\n### 退出\n\nexit；\n\n### 自定义mysql的存储路径为\n\nmysql默认存储路径为: /var/lib/mysql\n\n将默认路径里的数据拷贝到自定义路径下：（此处自定义路径为：/opt/database/mysql）\n\ncp -arp /var/lib/mysql /opt/database/mysql (-arp参数是递归复制并且保留权限)\n\n\n默认配置文件路径：/etc/mysql/mysql.conf.d/mysqld.cnf\n\n去掉#注释，将路径改为自定义路径，比如：datadir=/opt/database/mysql\n\n继续修改：\n\nvim /etc/apparmor.d/usr.sbin.mysqld\n\n找到此行并修改：\n\n#Allow data dir access\n\n  #/var/lib/mysql/ r,\n  \n  #/var/lib/mysql/** rwk,\n  \n  /opt/database/mysql/ r,\n  \n  /opt/database/mysql/** rwk,\n\n### 重启 apparmor 服务：\n\nsystemctl status apparmor.service\n\n或：\n\nservice apparmor restart\n\n\n### 创建新用户并授权\n\ncreate user 'zs'@'%' identified by 'zs1024';\n\nGRANT ALL PRIVILEGES ON *.* TO 'zs'@'%' WITH GRANT OPTION;\n\nFLUSH PRIVILEGES;\n\n\n### 可能会遇到的问题：\n\n#### MySQL中文乱码的问题\n\nshow variables like \"char%\";\n\n如果character_set_server参数是latin1，则使用如下命令修改，否则跳过此步骤；\n\nvi /etc/mysql/mysql.conf.d/mysqld.cnf\n\n在[mysqld]下添加一行character_set_server=utf8mb4\n\n\n#### 重启MySQL服务\n\nsystemctl restart mysql.service\n\n#### Host is not allowed to connect to this MySQL server错误\n\n1. 进入命令端： mysql -u root -p\n\n2. use mysql\n\n3. select user, host from user ;\n\n4. 将root的host改为\"%\"\n\n5. update user set host='%' where user='root';\n\n#### Mysql服务出现error 1698(28000)错误 (密码校验插件问题)\n\n1. SELECT user,host,plugin FROM mysql.user;\n\n2. ALTER USER ‘root’@‘%’ IDENTIFIED WITH mysql_native_password BY’自定义密码';\n\n3. flush privileges;\n\n#### 修改root密码\n\n1.use mysql;\n \n2.ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY'自定义密码';\n\n3.flush privileges; #更新所有操作权限\n\n### 开启数据库慢日志\n\n默认配置文件在/etc/my.cnf,在配置文件加上上述内容开启慢日志和定义存储路径。\n\n[mysqld]\n\nslow_query_log = 1\n\nslow_query_log_file = /opt/database/mysql/mysql-slow.log\n\nlong_query_time = 2\n\n\n[参考文章地址链接1](https://www.wake.wiki/archives/ubuntu1804-an-zhuang-mysql-shu-ju-ku)\n\n[参考文章地址链接2](https://www.cnblogs.com/RioTian/p/16066917.html)\n\n\n\n\n\n\n","slug":"2023-11-06-ubuntu20.04安装Mysql8.0数据库","published":1,"date":"2023-12-15T02:31:43.067Z","updated":"2023-12-15T02:31:43.075Z","_id":"clq60jpjh000n4zgs08lp6ir1","title":"","comments":1,"layout":"post","photos":[],"content":"<h3 id=\"卸载残留\"><a href=\"#卸载残留\" class=\"headerlink\" title=\"卸载残留\"></a>卸载残留</h3><p>sudo apt-get remove –purge mysql-server mysql-client mysql-common</p>\n<p>sudo apt-get autoremove</p>\n<p>sudo apt-get autoclean</p>\n<h3 id=\"删除MySQL数据目录\"><a href=\"#删除MySQL数据目录\" class=\"headerlink\" title=\"删除MySQL数据目录\"></a>删除MySQL数据目录</h3><p>sudo rm -rf &#x2F;var&#x2F;lib&#x2F;mysql</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>sudo apt-get update</p>\n<p>sudo apt-get install mysql-server</p>\n<h3 id=\"启动和关闭mysql服务器\"><a href=\"#启动和关闭mysql服务器\" class=\"headerlink\" title=\"启动和关闭mysql服务器\"></a>启动和关闭mysql服务器</h3><p>systemctl status mysql.service</p>\n<p>systemctl start mysql.service</p>\n<h3 id=\"进入MySQL命令端\"><a href=\"#进入MySQL命令端\" class=\"headerlink\" title=\"进入MySQL命令端\"></a>进入MySQL命令端</h3><p>mysql -uroot -p （直接回车不需要密码）</p>\n<h3 id=\"退出\"><a href=\"#退出\" class=\"headerlink\" title=\"退出\"></a>退出</h3><p>exit；</p>\n<h3 id=\"自定义mysql的存储路径为\"><a href=\"#自定义mysql的存储路径为\" class=\"headerlink\" title=\"自定义mysql的存储路径为\"></a>自定义mysql的存储路径为</h3><p>mysql默认存储路径为: &#x2F;var&#x2F;lib&#x2F;mysql</p>\n<p>将默认路径里的数据拷贝到自定义路径下：（此处自定义路径为：&#x2F;opt&#x2F;database&#x2F;mysql）</p>\n<p>cp -arp &#x2F;var&#x2F;lib&#x2F;mysql &#x2F;opt&#x2F;database&#x2F;mysql (-arp参数是递归复制并且保留权限)</p>\n<p>默认配置文件路径：&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</p>\n<p>去掉#注释，将路径改为自定义路径，比如：datadir&#x3D;&#x2F;opt&#x2F;database&#x2F;mysql</p>\n<p>继续修改：</p>\n<p>vim &#x2F;etc&#x2F;apparmor.d&#x2F;usr.sbin.mysqld</p>\n<p>找到此行并修改：</p>\n<p>#Allow data dir access</p>\n<p>  #&#x2F;var&#x2F;lib&#x2F;mysql&#x2F; r,</p>\n<p>  #&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;** rwk,</p>\n<p>  &#x2F;opt&#x2F;database&#x2F;mysql&#x2F; r,</p>\n<p>  &#x2F;opt&#x2F;database&#x2F;mysql&#x2F;** rwk,</p>\n<h3 id=\"重启-apparmor-服务：\"><a href=\"#重启-apparmor-服务：\" class=\"headerlink\" title=\"重启 apparmor 服务：\"></a>重启 apparmor 服务：</h3><p>systemctl status apparmor.service</p>\n<p>或：</p>\n<p>service apparmor restart</p>\n<h3 id=\"创建新用户并授权\"><a href=\"#创建新用户并授权\" class=\"headerlink\" title=\"创建新用户并授权\"></a>创建新用户并授权</h3><p>create user ‘zs‘@’%’ identified by ‘zs1024’;</p>\n<p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘zs‘@’%’ WITH GRANT OPTION;</p>\n<p>FLUSH PRIVILEGES;</p>\n<h3 id=\"可能会遇到的问题：\"><a href=\"#可能会遇到的问题：\" class=\"headerlink\" title=\"可能会遇到的问题：\"></a>可能会遇到的问题：</h3><h4 id=\"MySQL中文乱码的问题\"><a href=\"#MySQL中文乱码的问题\" class=\"headerlink\" title=\"MySQL中文乱码的问题\"></a>MySQL中文乱码的问题</h4><p>show variables like “char%”;</p>\n<p>如果character_set_server参数是latin1，则使用如下命令修改，否则跳过此步骤；</p>\n<p>vi &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</p>\n<p>在[mysqld]下添加一行character_set_server&#x3D;utf8mb4</p>\n<h4 id=\"重启MySQL服务\"><a href=\"#重启MySQL服务\" class=\"headerlink\" title=\"重启MySQL服务\"></a>重启MySQL服务</h4><p>systemctl restart mysql.service</p>\n<h4 id=\"Host-is-not-allowed-to-connect-to-this-MySQL-server错误\"><a href=\"#Host-is-not-allowed-to-connect-to-this-MySQL-server错误\" class=\"headerlink\" title=\"Host is not allowed to connect to this MySQL server错误\"></a>Host is not allowed to connect to this MySQL server错误</h4><ol>\n<li><p>进入命令端： mysql -u root -p</p>\n</li>\n<li><p>use mysql</p>\n</li>\n<li><p>select user, host from user ;</p>\n</li>\n<li><p>将root的host改为”%”</p>\n</li>\n<li><p>update user set host&#x3D;’%’ where user&#x3D;’root’;</p>\n</li>\n</ol>\n<h4 id=\"Mysql服务出现error-1698-28000-错误-密码校验插件问题\"><a href=\"#Mysql服务出现error-1698-28000-错误-密码校验插件问题\" class=\"headerlink\" title=\"Mysql服务出现error 1698(28000)错误 (密码校验插件问题)\"></a>Mysql服务出现error 1698(28000)错误 (密码校验插件问题)</h4><ol>\n<li><p>SELECT user,host,plugin FROM mysql.user;</p>\n</li>\n<li><p>ALTER USER ‘root’@‘%’ IDENTIFIED WITH mysql_native_password BY’自定义密码’;</p>\n</li>\n<li><p>flush privileges;</p>\n</li>\n</ol>\n<h4 id=\"修改root密码\"><a href=\"#修改root密码\" class=\"headerlink\" title=\"修改root密码\"></a>修改root密码</h4><p>1.use mysql;</p>\n<p>2.ALTER USER ‘root‘@’%’ IDENTIFIED WITH mysql_native_password BY’自定义密码’;</p>\n<p>3.flush privileges; #更新所有操作权限</p>\n<h3 id=\"开启数据库慢日志\"><a href=\"#开启数据库慢日志\" class=\"headerlink\" title=\"开启数据库慢日志\"></a>开启数据库慢日志</h3><p>默认配置文件在&#x2F;etc&#x2F;my.cnf,在配置文件加上上述内容开启慢日志和定义存储路径。</p>\n<p>[mysqld]</p>\n<p>slow_query_log &#x3D; 1</p>\n<p>slow_query_log_file &#x3D; &#x2F;opt&#x2F;database&#x2F;mysql&#x2F;mysql-slow.log</p>\n<p>long_query_time &#x3D; 2</p>\n<p><a href=\"https://www.wake.wiki/archives/ubuntu1804-an-zhuang-mysql-shu-ju-ku\">参考文章地址链接1</a></p>\n<p><a href=\"https://www.cnblogs.com/RioTian/p/16066917.html\">参考文章地址链接2</a></p>\n","excerpt":"","more":"<h3 id=\"卸载残留\"><a href=\"#卸载残留\" class=\"headerlink\" title=\"卸载残留\"></a>卸载残留</h3><p>sudo apt-get remove –purge mysql-server mysql-client mysql-common</p>\n<p>sudo apt-get autoremove</p>\n<p>sudo apt-get autoclean</p>\n<h3 id=\"删除MySQL数据目录\"><a href=\"#删除MySQL数据目录\" class=\"headerlink\" title=\"删除MySQL数据目录\"></a>删除MySQL数据目录</h3><p>sudo rm -rf &#x2F;var&#x2F;lib&#x2F;mysql</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>sudo apt-get update</p>\n<p>sudo apt-get install mysql-server</p>\n<h3 id=\"启动和关闭mysql服务器\"><a href=\"#启动和关闭mysql服务器\" class=\"headerlink\" title=\"启动和关闭mysql服务器\"></a>启动和关闭mysql服务器</h3><p>systemctl status mysql.service</p>\n<p>systemctl start mysql.service</p>\n<h3 id=\"进入MySQL命令端\"><a href=\"#进入MySQL命令端\" class=\"headerlink\" title=\"进入MySQL命令端\"></a>进入MySQL命令端</h3><p>mysql -uroot -p （直接回车不需要密码）</p>\n<h3 id=\"退出\"><a href=\"#退出\" class=\"headerlink\" title=\"退出\"></a>退出</h3><p>exit；</p>\n<h3 id=\"自定义mysql的存储路径为\"><a href=\"#自定义mysql的存储路径为\" class=\"headerlink\" title=\"自定义mysql的存储路径为\"></a>自定义mysql的存储路径为</h3><p>mysql默认存储路径为: &#x2F;var&#x2F;lib&#x2F;mysql</p>\n<p>将默认路径里的数据拷贝到自定义路径下：（此处自定义路径为：&#x2F;opt&#x2F;database&#x2F;mysql）</p>\n<p>cp -arp &#x2F;var&#x2F;lib&#x2F;mysql &#x2F;opt&#x2F;database&#x2F;mysql (-arp参数是递归复制并且保留权限)</p>\n<p>默认配置文件路径：&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</p>\n<p>去掉#注释，将路径改为自定义路径，比如：datadir&#x3D;&#x2F;opt&#x2F;database&#x2F;mysql</p>\n<p>继续修改：</p>\n<p>vim &#x2F;etc&#x2F;apparmor.d&#x2F;usr.sbin.mysqld</p>\n<p>找到此行并修改：</p>\n<p>#Allow data dir access</p>\n<p>  #&#x2F;var&#x2F;lib&#x2F;mysql&#x2F; r,</p>\n<p>  #&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;** rwk,</p>\n<p>  &#x2F;opt&#x2F;database&#x2F;mysql&#x2F; r,</p>\n<p>  &#x2F;opt&#x2F;database&#x2F;mysql&#x2F;** rwk,</p>\n<h3 id=\"重启-apparmor-服务：\"><a href=\"#重启-apparmor-服务：\" class=\"headerlink\" title=\"重启 apparmor 服务：\"></a>重启 apparmor 服务：</h3><p>systemctl status apparmor.service</p>\n<p>或：</p>\n<p>service apparmor restart</p>\n<h3 id=\"创建新用户并授权\"><a href=\"#创建新用户并授权\" class=\"headerlink\" title=\"创建新用户并授权\"></a>创建新用户并授权</h3><p>create user ‘zs‘@’%’ identified by ‘zs1024’;</p>\n<p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘zs‘@’%’ WITH GRANT OPTION;</p>\n<p>FLUSH PRIVILEGES;</p>\n<h3 id=\"可能会遇到的问题：\"><a href=\"#可能会遇到的问题：\" class=\"headerlink\" title=\"可能会遇到的问题：\"></a>可能会遇到的问题：</h3><h4 id=\"MySQL中文乱码的问题\"><a href=\"#MySQL中文乱码的问题\" class=\"headerlink\" title=\"MySQL中文乱码的问题\"></a>MySQL中文乱码的问题</h4><p>show variables like “char%”;</p>\n<p>如果character_set_server参数是latin1，则使用如下命令修改，否则跳过此步骤；</p>\n<p>vi &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</p>\n<p>在[mysqld]下添加一行character_set_server&#x3D;utf8mb4</p>\n<h4 id=\"重启MySQL服务\"><a href=\"#重启MySQL服务\" class=\"headerlink\" title=\"重启MySQL服务\"></a>重启MySQL服务</h4><p>systemctl restart mysql.service</p>\n<h4 id=\"Host-is-not-allowed-to-connect-to-this-MySQL-server错误\"><a href=\"#Host-is-not-allowed-to-connect-to-this-MySQL-server错误\" class=\"headerlink\" title=\"Host is not allowed to connect to this MySQL server错误\"></a>Host is not allowed to connect to this MySQL server错误</h4><ol>\n<li><p>进入命令端： mysql -u root -p</p>\n</li>\n<li><p>use mysql</p>\n</li>\n<li><p>select user, host from user ;</p>\n</li>\n<li><p>将root的host改为”%”</p>\n</li>\n<li><p>update user set host&#x3D;’%’ where user&#x3D;’root’;</p>\n</li>\n</ol>\n<h4 id=\"Mysql服务出现error-1698-28000-错误-密码校验插件问题\"><a href=\"#Mysql服务出现error-1698-28000-错误-密码校验插件问题\" class=\"headerlink\" title=\"Mysql服务出现error 1698(28000)错误 (密码校验插件问题)\"></a>Mysql服务出现error 1698(28000)错误 (密码校验插件问题)</h4><ol>\n<li><p>SELECT user,host,plugin FROM mysql.user;</p>\n</li>\n<li><p>ALTER USER ‘root’@‘%’ IDENTIFIED WITH mysql_native_password BY’自定义密码’;</p>\n</li>\n<li><p>flush privileges;</p>\n</li>\n</ol>\n<h4 id=\"修改root密码\"><a href=\"#修改root密码\" class=\"headerlink\" title=\"修改root密码\"></a>修改root密码</h4><p>1.use mysql;</p>\n<p>2.ALTER USER ‘root‘@’%’ IDENTIFIED WITH mysql_native_password BY’自定义密码’;</p>\n<p>3.flush privileges; #更新所有操作权限</p>\n<h3 id=\"开启数据库慢日志\"><a href=\"#开启数据库慢日志\" class=\"headerlink\" title=\"开启数据库慢日志\"></a>开启数据库慢日志</h3><p>默认配置文件在&#x2F;etc&#x2F;my.cnf,在配置文件加上上述内容开启慢日志和定义存储路径。</p>\n<p>[mysqld]</p>\n<p>slow_query_log &#x3D; 1</p>\n<p>slow_query_log_file &#x3D; &#x2F;opt&#x2F;database&#x2F;mysql&#x2F;mysql-slow.log</p>\n<p>long_query_time &#x3D; 2</p>\n<p><a href=\"https://www.wake.wiki/archives/ubuntu1804-an-zhuang-mysql-shu-ju-ku\">参考文章地址链接1</a></p>\n<p><a href=\"https://www.cnblogs.com/RioTian/p/16066917.html\">参考文章地址链接2</a></p>\n"},{"_content":"### 手动下载并启动\n\n下载 http://download.redis.io/redis-stable.tar.gz\n\n解压运行\n\n### apt安装\n\nsudo apt update\n\nsudo apt install redis-server\n\n### 启动、停止、重启\n\n#### 查看状态\nsystemctl status redis-server.service\n\n#### 启动\nsystemctl start redis-server.service\n\n#### 停止\nsystemctl stop redis-server.service\n\n#### 重启\nsystemctl restart redis-server.service\n\n#### 设置开机启动\nsystemctl enable redis-server.service\n\n### 配置\n\n/etc/redis/redis.conf\n\n注释 bind这一行\n\n### 修改密码\n\nrequirepass 密码\n\n### 修改端口\n\nport 6379\n\n","source":"_posts/2023-11-06-ubuntu20.04安装Redis.md","raw":"### 手动下载并启动\n\n下载 http://download.redis.io/redis-stable.tar.gz\n\n解压运行\n\n### apt安装\n\nsudo apt update\n\nsudo apt install redis-server\n\n### 启动、停止、重启\n\n#### 查看状态\nsystemctl status redis-server.service\n\n#### 启动\nsystemctl start redis-server.service\n\n#### 停止\nsystemctl stop redis-server.service\n\n#### 重启\nsystemctl restart redis-server.service\n\n#### 设置开机启动\nsystemctl enable redis-server.service\n\n### 配置\n\n/etc/redis/redis.conf\n\n注释 bind这一行\n\n### 修改密码\n\nrequirepass 密码\n\n### 修改端口\n\nport 6379\n\n","slug":"2023-11-06-ubuntu20.04安装Redis","published":1,"date":"2023-12-15T02:31:43.091Z","updated":"2023-12-15T02:31:43.099Z","_id":"clq60jpk2000o4zgs4wd63bky","title":"","comments":1,"layout":"post","photos":[],"content":"<h3 id=\"手动下载并启动\"><a href=\"#手动下载并启动\" class=\"headerlink\" title=\"手动下载并启动\"></a>手动下载并启动</h3><p>下载 <a href=\"http://download.redis.io/redis-stable.tar.gz\">http://download.redis.io/redis-stable.tar.gz</a></p>\n<p>解压运行</p>\n<h3 id=\"apt安装\"><a href=\"#apt安装\" class=\"headerlink\" title=\"apt安装\"></a>apt安装</h3><p>sudo apt update</p>\n<p>sudo apt install redis-server</p>\n<h3 id=\"启动、停止、重启\"><a href=\"#启动、停止、重启\" class=\"headerlink\" title=\"启动、停止、重启\"></a>启动、停止、重启</h3><h4 id=\"查看状态\"><a href=\"#查看状态\" class=\"headerlink\" title=\"查看状态\"></a>查看状态</h4><p>systemctl status redis-server.service</p>\n<h4 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h4><p>systemctl start redis-server.service</p>\n<h4 id=\"停止\"><a href=\"#停止\" class=\"headerlink\" title=\"停止\"></a>停止</h4><p>systemctl stop redis-server.service</p>\n<h4 id=\"重启\"><a href=\"#重启\" class=\"headerlink\" title=\"重启\"></a>重启</h4><p>systemctl restart redis-server.service</p>\n<h4 id=\"设置开机启动\"><a href=\"#设置开机启动\" class=\"headerlink\" title=\"设置开机启动\"></a>设置开机启动</h4><p>systemctl enable redis-server.service</p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>&#x2F;etc&#x2F;redis&#x2F;redis.conf</p>\n<p>注释 bind这一行</p>\n<h3 id=\"修改密码\"><a href=\"#修改密码\" class=\"headerlink\" title=\"修改密码\"></a>修改密码</h3><p>requirepass 密码</p>\n<h3 id=\"修改端口\"><a href=\"#修改端口\" class=\"headerlink\" title=\"修改端口\"></a>修改端口</h3><p>port 6379</p>\n","excerpt":"","more":"<h3 id=\"手动下载并启动\"><a href=\"#手动下载并启动\" class=\"headerlink\" title=\"手动下载并启动\"></a>手动下载并启动</h3><p>下载 <a href=\"http://download.redis.io/redis-stable.tar.gz\">http://download.redis.io/redis-stable.tar.gz</a></p>\n<p>解压运行</p>\n<h3 id=\"apt安装\"><a href=\"#apt安装\" class=\"headerlink\" title=\"apt安装\"></a>apt安装</h3><p>sudo apt update</p>\n<p>sudo apt install redis-server</p>\n<h3 id=\"启动、停止、重启\"><a href=\"#启动、停止、重启\" class=\"headerlink\" title=\"启动、停止、重启\"></a>启动、停止、重启</h3><h4 id=\"查看状态\"><a href=\"#查看状态\" class=\"headerlink\" title=\"查看状态\"></a>查看状态</h4><p>systemctl status redis-server.service</p>\n<h4 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h4><p>systemctl start redis-server.service</p>\n<h4 id=\"停止\"><a href=\"#停止\" class=\"headerlink\" title=\"停止\"></a>停止</h4><p>systemctl stop redis-server.service</p>\n<h4 id=\"重启\"><a href=\"#重启\" class=\"headerlink\" title=\"重启\"></a>重启</h4><p>systemctl restart redis-server.service</p>\n<h4 id=\"设置开机启动\"><a href=\"#设置开机启动\" class=\"headerlink\" title=\"设置开机启动\"></a>设置开机启动</h4><p>systemctl enable redis-server.service</p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>&#x2F;etc&#x2F;redis&#x2F;redis.conf</p>\n<p>注释 bind这一行</p>\n<h3 id=\"修改密码\"><a href=\"#修改密码\" class=\"headerlink\" title=\"修改密码\"></a>修改密码</h3><p>requirepass 密码</p>\n<h3 id=\"修改端口\"><a href=\"#修改端口\" class=\"headerlink\" title=\"修改端口\"></a>修改端口</h3><p>port 6379</p>\n"},{"_content":"### 安装流程\n\n1、更新软件包索引：\n\nsudo apt update\n\n2、安装必要的依赖项，以允许apt通过HTTPS使用存储库：\n\nsudo apt install apt-transport-https ca-certificates curl software-properties-common\n\n3、添加Docker的官方GPG密钥：\n\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg\n\n4、添加Docker的稳定版存储库：\n\necho \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\n\n5、再次更新软件包索引：\n\nsudo apt update\n\n6、安装Docker Engine：\n\nsudo apt install docker-ce docker-ce-cli containerd.io\n\n7、验证Docker是否成功安装，运行以下命令检查Docker版本：\n\ndocker version\n","source":"_posts/2023-11-24-ubuntu22.04安装docker.md","raw":"### 安装流程\n\n1、更新软件包索引：\n\nsudo apt update\n\n2、安装必要的依赖项，以允许apt通过HTTPS使用存储库：\n\nsudo apt install apt-transport-https ca-certificates curl software-properties-common\n\n3、添加Docker的官方GPG密钥：\n\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg\n\n4、添加Docker的稳定版存储库：\n\necho \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\n\n5、再次更新软件包索引：\n\nsudo apt update\n\n6、安装Docker Engine：\n\nsudo apt install docker-ce docker-ce-cli containerd.io\n\n7、验证Docker是否成功安装，运行以下命令检查Docker版本：\n\ndocker version\n","slug":"2023-11-24-ubuntu22.04安装docker","published":1,"date":"2023-12-15T02:31:43.119Z","updated":"2023-12-15T02:31:43.127Z","_id":"clq60jpkv000p4zgs7vw0b7fb","title":"","comments":1,"layout":"post","photos":[],"content":"<h3 id=\"安装流程\"><a href=\"#安装流程\" class=\"headerlink\" title=\"安装流程\"></a>安装流程</h3><p>1、更新软件包索引：</p>\n<p>sudo apt update</p>\n<p>2、安装必要的依赖项，以允许apt通过HTTPS使用存储库：</p>\n<p>sudo apt install apt-transport-https ca-certificates curl software-properties-common</p>\n<p>3、添加Docker的官方GPG密钥：</p>\n<p>curl -fsSL <a href=\"https://download.docker.com/linux/ubuntu/gpg\">https://download.docker.com/linux/ubuntu/gpg</a> | sudo gpg –dearmor -o &#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;docker-archive-keyring.gpg</p>\n<p>4、添加Docker的稳定版存储库：</p>\n<p>echo “deb [arch&#x3D;amd64 signed-by&#x3D;&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;docker-archive-keyring.gpg] <a href=\"https://download.docker.com/linux/ubuntu\">https://download.docker.com/linux/ubuntu</a> $(lsb_release -cs) stable” | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;docker.list &gt; &#x2F;dev&#x2F;null</p>\n<p>5、再次更新软件包索引：</p>\n<p>sudo apt update</p>\n<p>6、安装Docker Engine：</p>\n<p>sudo apt install docker-ce docker-ce-cli containerd.io</p>\n<p>7、验证Docker是否成功安装，运行以下命令检查Docker版本：</p>\n<p>docker version</p>\n","excerpt":"","more":"<h3 id=\"安装流程\"><a href=\"#安装流程\" class=\"headerlink\" title=\"安装流程\"></a>安装流程</h3><p>1、更新软件包索引：</p>\n<p>sudo apt update</p>\n<p>2、安装必要的依赖项，以允许apt通过HTTPS使用存储库：</p>\n<p>sudo apt install apt-transport-https ca-certificates curl software-properties-common</p>\n<p>3、添加Docker的官方GPG密钥：</p>\n<p>curl -fsSL <a href=\"https://download.docker.com/linux/ubuntu/gpg\">https://download.docker.com/linux/ubuntu/gpg</a> | sudo gpg –dearmor -o &#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;docker-archive-keyring.gpg</p>\n<p>4、添加Docker的稳定版存储库：</p>\n<p>echo “deb [arch&#x3D;amd64 signed-by&#x3D;&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;docker-archive-keyring.gpg] <a href=\"https://download.docker.com/linux/ubuntu\">https://download.docker.com/linux/ubuntu</a> $(lsb_release -cs) stable” | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;docker.list &gt; &#x2F;dev&#x2F;null</p>\n<p>5、再次更新软件包索引：</p>\n<p>sudo apt update</p>\n<p>6、安装Docker Engine：</p>\n<p>sudo apt install docker-ce docker-ce-cli containerd.io</p>\n<p>7、验证Docker是否成功安装，运行以下命令检查Docker版本：</p>\n<p>docker version</p>\n"},{"_content":"## 永久关闭小米电视开机广告\n\n### 1、小米商城App找到人工客服，称关闭电视广告，坚持要求关闭；\n\n### 2、随后客服会让你提供 MAC 地址，三个（以太网MAC、WiFi MAC、BT MAC，在电视设置里找）；\n\n### 3、发给客服后，2-3个工作日就会永久关闭电视开机广告（亲测秒关，重新开机广告已去除)\n","source":"_posts/2023-11-6-永久关闭小米电视广告.md","raw":"## 永久关闭小米电视开机广告\n\n### 1、小米商城App找到人工客服，称关闭电视广告，坚持要求关闭；\n\n### 2、随后客服会让你提供 MAC 地址，三个（以太网MAC、WiFi MAC、BT MAC，在电视设置里找）；\n\n### 3、发给客服后，2-3个工作日就会永久关闭电视开机广告（亲测秒关，重新开机广告已去除)\n","slug":"2023-11-6-永久关闭小米电视广告","published":1,"date":"2023-12-15T02:31:43.167Z","updated":"2023-12-15T02:31:43.171Z","_id":"clq60jpm6000q4zgs5o7e9g8o","title":"","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"永久关闭小米电视开机广告\"><a href=\"#永久关闭小米电视开机广告\" class=\"headerlink\" title=\"永久关闭小米电视开机广告\"></a>永久关闭小米电视开机广告</h2><h3 id=\"1、小米商城App找到人工客服，称关闭电视广告，坚持要求关闭；\"><a href=\"#1、小米商城App找到人工客服，称关闭电视广告，坚持要求关闭；\" class=\"headerlink\" title=\"1、小米商城App找到人工客服，称关闭电视广告，坚持要求关闭；\"></a>1、小米商城App找到人工客服，称关闭电视广告，坚持要求关闭；</h3><h3 id=\"2、随后客服会让你提供-MAC-地址，三个（以太网MAC、WiFi-MAC、BT-MAC，在电视设置里找）；\"><a href=\"#2、随后客服会让你提供-MAC-地址，三个（以太网MAC、WiFi-MAC、BT-MAC，在电视设置里找）；\" class=\"headerlink\" title=\"2、随后客服会让你提供 MAC 地址，三个（以太网MAC、WiFi MAC、BT MAC，在电视设置里找）；\"></a>2、随后客服会让你提供 MAC 地址，三个（以太网MAC、WiFi MAC、BT MAC，在电视设置里找）；</h3><h3 id=\"3、发给客服后，2-3个工作日就会永久关闭电视开机广告（亲测秒关，重新开机广告已去除\"><a href=\"#3、发给客服后，2-3个工作日就会永久关闭电视开机广告（亲测秒关，重新开机广告已去除\" class=\"headerlink\" title=\"3、发给客服后，2-3个工作日就会永久关闭电视开机广告（亲测秒关，重新开机广告已去除)\"></a>3、发给客服后，2-3个工作日就会永久关闭电视开机广告（亲测秒关，重新开机广告已去除)</h3>","excerpt":"","more":"<h2 id=\"永久关闭小米电视开机广告\"><a href=\"#永久关闭小米电视开机广告\" class=\"headerlink\" title=\"永久关闭小米电视开机广告\"></a>永久关闭小米电视开机广告</h2><h3 id=\"1、小米商城App找到人工客服，称关闭电视广告，坚持要求关闭；\"><a href=\"#1、小米商城App找到人工客服，称关闭电视广告，坚持要求关闭；\" class=\"headerlink\" title=\"1、小米商城App找到人工客服，称关闭电视广告，坚持要求关闭；\"></a>1、小米商城App找到人工客服，称关闭电视广告，坚持要求关闭；</h3><h3 id=\"2、随后客服会让你提供-MAC-地址，三个（以太网MAC、WiFi-MAC、BT-MAC，在电视设置里找）；\"><a href=\"#2、随后客服会让你提供-MAC-地址，三个（以太网MAC、WiFi-MAC、BT-MAC，在电视设置里找）；\" class=\"headerlink\" title=\"2、随后客服会让你提供 MAC 地址，三个（以太网MAC、WiFi MAC、BT MAC，在电视设置里找）；\"></a>2、随后客服会让你提供 MAC 地址，三个（以太网MAC、WiFi MAC、BT MAC，在电视设置里找）；</h3><h3 id=\"3、发给客服后，2-3个工作日就会永久关闭电视开机广告（亲测秒关，重新开机广告已去除\"><a href=\"#3、发给客服后，2-3个工作日就会永久关闭电视开机广告（亲测秒关，重新开机广告已去除\" class=\"headerlink\" title=\"3、发给客服后，2-3个工作日就会永久关闭电视开机广告（亲测秒关，重新开机广告已去除)\"></a>3、发给客服后，2-3个工作日就会永久关闭电视开机广告（亲测秒关，重新开机广告已去除)</h3>"},{"_content":"#### Running docker container : iptables: No chain/target/match by that name\n\n1. Clear all chains:\n\nsudo iptables -t filter -F\n\nsudo iptables -t filter -X\n\n\n2. Then restart Docker Service:\n\nsystemctl restart docker\n","source":"_posts/2023-12-05-docker容器启动提示iptables问题.md","raw":"#### Running docker container : iptables: No chain/target/match by that name\n\n1. Clear all chains:\n\nsudo iptables -t filter -F\n\nsudo iptables -t filter -X\n\n\n2. Then restart Docker Service:\n\nsystemctl restart docker\n","slug":"2023-12-05-docker容器启动提示iptables问题","published":1,"date":"2023-12-15T02:31:43.191Z","updated":"2023-12-15T02:31:43.199Z","_id":"clq60jpmx000r4zgs9ozv8c9w","title":"","comments":1,"layout":"post","photos":[],"content":"<h4 id=\"Running-docker-container-iptables-No-chain-target-match-by-that-name\"><a href=\"#Running-docker-container-iptables-No-chain-target-match-by-that-name\" class=\"headerlink\" title=\"Running docker container : iptables: No chain&#x2F;target&#x2F;match by that name\"></a>Running docker container : iptables: No chain&#x2F;target&#x2F;match by that name</h4><ol>\n<li>Clear all chains:</li>\n</ol>\n<p>sudo iptables -t filter -F</p>\n<p>sudo iptables -t filter -X</p>\n<ol start=\"2\">\n<li>Then restart Docker Service:</li>\n</ol>\n<p>systemctl restart docker</p>\n","excerpt":"","more":"<h4 id=\"Running-docker-container-iptables-No-chain-target-match-by-that-name\"><a href=\"#Running-docker-container-iptables-No-chain-target-match-by-that-name\" class=\"headerlink\" title=\"Running docker container : iptables: No chain&#x2F;target&#x2F;match by that name\"></a>Running docker container : iptables: No chain&#x2F;target&#x2F;match by that name</h4><ol>\n<li>Clear all chains:</li>\n</ol>\n<p>sudo iptables -t filter -F</p>\n<p>sudo iptables -t filter -X</p>\n<ol start=\"2\">\n<li>Then restart Docker Service:</li>\n</ol>\n<p>systemctl restart docker</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}